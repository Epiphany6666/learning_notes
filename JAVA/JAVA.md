注意：

​	用记事本打开本文档，格式较差。

​	可安装typora软件后再次打开。

​	安装包位于：day01\资料\其他软件\阅读笔记的软件\typora-setup-x64.exe

# day01 - Java基础语法

# 2.人机交互-图形化界面的小故事

## 一、图形化界面的小故事

计算机在刚开始出现的时候，因为占地广、造价高、耗电多，一般都是给军队或者政府使用的，而并不是给个人使用的。然后随着计算机不断地发展，体积越来越小，出现了微型机，进入了千家万户，这个时候个人才能够开始使用。在刚开始使用的个人电脑是没有像我们今天这样的图形化界面的。在以前都是在黑屏下面输入一些命令去操作计算机的。

![image-20240325203817549](assets/image-20240325203817549.png)

比如说我想打开一个文件夹，在现在的电脑当中，用鼠标双击就可以，这就是图形化界面给我们带来的方便。但是在以前是需要输入一些命令才能够打开文件的，相对来讲还是有点麻烦的。

这个时候比较典型的操作系统是在1981年的时候由IBM和微软共同推出的，它的名字叫做：MS-DOS。这个系统是一律在黑屏下面使用一些命令去操作计算机的，没有任何的图形化界面，所以在当时，没有一点计算机的功底还真玩不转它。

![image-20240325203842844](assets/image-20240325203842844.png)

![image-20240325203855322](assets/image-20240325203855322.png)

所以是谁第一个发明图形化界面的操作系统的呢？很可惜，既不是微软，也不是苹果，而是施乐这家公司。

![image-20240325203915335](assets/image-20240325203915335.png)

施乐这家公司在1981年4月27号的时候推出了一台叫做施乐之星的电脑，其创新程度在当年堪称惊天动地，就是因为它有图形化界面了，它就是长下面那样。

![image-20240325203944333](assets/image-20240325203944333.png)

将它放大看一下，施乐推出的操作系统引入了窗口模式，你能同时打开几个窗口干不同的事。你可以建文件夹，把不同的东西归类放在一起，用到的时候双击就可以了，那基本上就是我们现在使用图形化界面的雏形。

![image-20240325204001086](assets/image-20240325204001086.png)

你可能会觉得这个界面丑爆了，但是在当时，它是神一样的存在，而就是这个技术成功引起了业界两位大佬的相爱相杀，即乔布斯和比尔盖茨。

![image-20240325204012979](assets/image-20240325204012979.png)

乔布斯看见了图形化界面的将来，推出了 `apple lisa`，同样的，刚开始页面比较丑。

![image-20240325204114124](assets/image-20240325204114124.png)

那么作为乔布斯的平生对手，比尔盖茨也推出了 `Windows1.0`。

![image-20240325204139822](assets/image-20240325204139822.png)

你有没有觉得也是花里花俏的，很那看。但就是这么难看的系统，还引起了两位大佬的撕逼，因为苹果是先推出 `apple lisa`，微软的 `windows1.0` 是在后面推出来的。所以乔布斯曾经当面怒斥比尔盖茨：你在盗用我的器械，也就是说你在抄我的作品。

而比尔盖茨不慌不忙，说出了他平生最金典的一句台词：“我们都有一个充裕的邻居，名叫施乐。有一天我闯进了他家，妄图偷走它的电脑。却发现你已经捷足先登。”

![image-20240325204159000](assets/image-20240325204159000.png)

其实比尔盖茨的话里的意思是这样的：你别发火，咱哥俩都是抄的，谁也别说谁。那后来苹果跟微软就开始了相爱相杀。这个也是我们现在图形化界面的由来，图形化界面对计算机的普及做出了不可磨灭的贡献。

![image-20240325204409432](assets/image-20240325204409432.png)

但是它也有自身的缺点，因为使用图形化界面去操作计算机，它要额外加载很多很多的图片，所以用图形化界面的方式去操作计算机，它需要消耗更多的内存，而且运行的速度没有命令行方式来的快。

大家在电视上看到的一些顶级黑客，他们一般都是在用命令行的方式去操作计算机的，如果说你有幸，以后碰见一些比较高级的黑客，你可以问一问它们，为什么不使用图形化界面呢？基本上所有的人都会回答你：太low太慢了。

![image-20240325204621146](assets/image-20240325204621146.png)

那么在windows操作系统中，其实也保留了命令行这一功能，它就是CMD。所以，什么是cmd？

----

## 二、什么是cmd？

就是在windows操作系统中，利用命令行的方式去操作计算机。我们可以利用cmd命令去操作计算机，比如：打开文件，打开文件夹，创建文件夹等。



---



# 3.打开CMD

步骤：

1. 按下快捷键：win + R。

   	此时会出现运行窗口。

2. 在运行窗口中输出cmd

3. 输出回车。

解惑：cmd默认操作C盘下的Users文件夹下的XXX文件夹。（XXX就是计算机名），好就好比在图形化界面中，我们默认都是在桌面上进行操作的一样

![image-20210923091350952](assets\cmd.png)

查看 `User\XXX` 文件夹：1、win + E，打开此电脑，点进C盘； 2、双击打开用户； 3、双击 `XXX` 文件夹

![image-20240326130211521](assets/image-20240326130211521.png)

扩展：其实windows的桌面也是个文件夹，它的名字叫 `desktop` ，位于 `C:\User\XXX\桌面` 文件夹下



----

# 4.常用CMD命令

扩展一个小点：在很多资料中都会把CMD命令说成是DOS命令，其实是不对的。真正的DOS命令是1981年微软和IBM出品的MS-DOS操作系统中的命令才叫做DOS命令。

而在Windows中，win98之前的操作系统是以非图形化的DOS为基础的，可以叫做DOS命令。到了2000年以后，windows逐渐的以图形化界面为主了，这个时候就不能叫DOS命令了，他只是模拟了DOS环境而已，很多的原本的DOS命令已经无法使用了，所以这个时候叫做**CMD命令**会更准确一些。

常见的CMD命令如下：

| 操作               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| 盘符名称:          | 盘符切换。E:回车，表示切换到E盘。                            |
| dir                | 查看当前路径下的内容。<br />包含所有的文件、文件夹，包括隐藏的内容全部展示出来。 |
| cd 目录            | 进入单级目录。cd itheima                                     |
| cd ..              | 回退到上一级目录。                                           |
| cd 目录1\目录2\... | 进入多级目录。cd itheima\JavaSE                              |
| cd \               | 回退到盘符目录。                                             |
| cls                | 清屏。                                                       |
| exit               | 退出命令提示符窗口。                                         |

补充操作：

- 盘符切换必须使用英文的冒号
- `ctrl + 滚轮` 可以调节命令行窗口的大小。

- 使用 `tab` 键可以补全目录。

- 如下图，使用 dir 有时候会出现 `.`、`..` 目录，这个是隐藏的文件夹。

  ![image-20240326132208327](assets/image-20240326132208327.png)

- 关闭命令行窗口

  1. 使用图形化界面的方式：直接点击上方的 `×` 
  2. 使用cmd命令的方式： `exit` 

- 在windows操作系统当中，文件名或者文件夹名是忽略大小写的。



---

# 5. 练习：利用CMD打开QQ并配置环境变量

## 一、需求

利用cmd命令打开自己电脑上的QQ。

完成步骤：

```java
1：确定自己电脑上的QQ安装在哪里
2：启动cmd
3：进入到启动程序QQ.exe所在的路径（qq\bin）。
4：输出qq.exe加回车表示启动qq。
```

假设我们电脑是没有图形化界面的。而QQ是经常打开的软件，每次打开的时候都要切换盘符，并且进入多层文件夹，太麻烦了！

----

## 二、设置环境变量的作用

作用：如果我想要在CMD的任意目录下，都可以启动某一个软件，那么就可以把这个软件的路径配置到环境变量中的PATH里面。

在启动软件的时候，操作系统会先在当前路径下找，如果在当前路径没有再到环境变量的路径中去找。如果都找不到就提示无法启动。

----

## 三、`设置环境变量` 步骤

**第一步：右键点击我的电脑并选择属性。（如果无法出现第二步界面，可以打开 `此电脑` 之后右键点击空白处）**

<img src="./assets/image-20240412094250204.png" alt="image-20240412094250204" style="zoom:50%;" />



**第二步：点击高级系统设置。**

<img src="assets/image-20240326133541905.png" alt="image-20240326133541905" style="zoom:50%;" />



**第三步：选择高级，再点击下面的环境变量。**

<img src="./assets/image-20240412094852822.png" alt="image-20240412094852822" style="zoom: 50%;" />



**第四步：找系统变量里面的PATH**

> 上面的那个不用管，因为上面那个是moon用户的用户变量，如果你的电脑里面有多个用户的话，那么设置在moon里面是不能通用的，所以我们要找到下面的系统变量。

<img src="./assets/image-20240412094920209.png" alt="image-20240412094920209" style="zoom:50%;" />



**第五步：点击新建，把QQ的完整路径，配置到PATH当中，再点击确定即可。**



**第六步：（可做可不做）点击上移，把当前配置的路径移动到最上面。**

移动的好处：在CMD中打开软件时，会先找当前路径，再找环境变量，在环境变量中是从上往下依次查找的，如果路径放在最上面查找的速度比较快。

 ![image-20210923091350952](assets\5.png)



**第七步：在任意目录下重新打开cmd窗口，然后输入 `qq.exe`，可以发现qq成功被启动！**



---

# 6. 学习方法和Java概述

## 一、学习方法

作为一个0基础入门的同学，在刚开始学习的时候，我们不要追求知识点的深度，而是要追求知识点的广度。简单来说，学一个知识点不要想的太深，应该先学习如何用，然后把尽可能多的知识点综合的用起来，锻炼我们的思维能力才是第一要素，等入门后，再来学习更加深入的知识点，才是符合我们平时学东西的思维逻辑。

![image-20240326135826735](assets/image-20240326135826735.png)



---



## 二、Java是什么？

Java是一门非常火的计算机语言。（也叫做编程语言）

> 语言：人与人交流沟通的表达方式
>
> 计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言

如果我们想让计算机按照我们的指令去做事情，就需要说计算机能听得懂的语言。JAVA就是一门非常火的计算机语言。至于到底有多火，我们可以看一下JAVA的市场占有率，这个是截止到2021年上半年全球编程语言的排行榜，其中上面的绿色的就是JAVA。

![image-20240326140028774](assets/image-20240326140028774.png)

我们知道，没有一款语言能够牢牢占据排行榜的榜首，起起伏伏是一种正常情况，但是可以看见它基本上都是保持在前三名之内。

看完了全球的，我们再来看看国内的，截止2021年上半年JAVA以`28%`的市场占有率在国内排名第一。

<img src="assets/image-20240326140244607.png" alt="image-20240326140244607" style="zoom:50%;" />

并且我们可以看看招聘网站，其中火热职位就有JAVA的一席之地，比如从BOSS直聘上截出来的一张图，在BOSS直聘的热门职位当中，第一个就是JAVA。

![image-20240326140408560](assets/image-20240326140408560.png)

51job（前程无忧）热门推荐里面也有JAVA。

![image-20240326140443851](assets/image-20240326140443851.png)

再来看智联招聘，互联网IT分类的第一个也是JAVA。

<img src="assets/image-20240326140542192.png" alt="image-20240326140542192" style="zoom: 80%;" />

所以由此可见，JAVA的火热程度。



---

# 7.JDK下载和安装 & JDK目录介绍

## 一、引入

写JAVA代码不是随随便便能写的，我们得先做一点准备工作。例如，我们平时想要玩一把游戏，就需要先下载、安装才能玩游戏。JAVA也是一样的，也是需要下载并安装相关的软件，它的名字就叫做：JDK。然后才能编写JAVA的第一个案例 —— HelloWorld。

----

## 二、下载

通过官方网站获取JDK：[http://www.oracle.com](http://www.oracle.com/)

**注意1**：针对不同的操作系统，需要下载对应版本的JDK。

**注意2**：如果你的电脑是windows32位的，建议重装系统，重装成64位的操作系统。因为Java从9版本开始，就已经不提供32位版本的安装包了。

首先点击官网导航栏的 `Products `选项，然后在弹出的下拉框中点击 `JAVA`

![image-20240326141348036](assets/image-20240326141348036.png)

然后点击右上角的 `Download Java`，表示要下载JAVA

![image-20240326141514955](assets/image-20240326141514955.png)

然后在上面它会有两个提示：1、`Java downloads`：下载JAVA； 2、`Java archive`：Java的历史版本

![image-20240326141634406](assets/image-20240326141634406.png)

在第一个界面中表示你下载的是最新的Java，但如果说你不要下载最新的，需要下载以前的，就可以点击第三个选项。本套课程采用的是2021年9月份刚推出来的 `Java17`，这个版本是长期支持版本，所以会有一个 `LTS` 后缀。

![image-20240327105811980](assets/image-20240327105811980.png)

然后根据自己的操作系统下载对应的版本，下面就以windows举例。

选中windows，然后点击中间这个进行下载，因为只有中间这个是最干净的安装包。第一个是zip包，在这个里面你下载完之后是一个压缩包，压缩包里面会有安装包还有一些其他说明性文件，但那些说明性文件对我来讲没有用，我只要一个安装包就可以了。

![image-20240327105933833](assets/image-20240327105933833.png)

----

## 三、安装

双击打开安装包，然后傻瓜式安装，下一步即可。默认的安装路径是在C:\Program Files下。

建议：

- 安装路径不要有中文，不要有空格等一些特殊的符号。

  因为这些软件是老外编写的，对中文的支持不够完美，所以如果以后路径中有中文，以后在使用的时候，容易出现一些问题。在选择路径的时候，我们就写`英文单词` 或者 `加一点数字`就行了。

- 以后跟开发相关的所有软件建议都安装在同一个目录（文件夹）中，方便管理。

例如这里就将开发所有的软件都装在E盘的develop文件夹当中。

![image-20240327110411089](assets/image-20240327110411089.png)

然后点击右上角的新建文件夹按钮，新建一个文件夹，名为：`JDK17`。<img src="assets/image-20240327114516811.png" alt="image-20240327114516811" style="zoom:50%;" />

----

## 四、JDK的安装目录介绍

安装完毕后，就可以去对应的文件里找到以下文件夹。

重点需要掌握的是 `bin` 文件夹。

| 目录名称 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| bin      | 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 |
| conf     | 该路径下存放了JDK的相关配置文件。                            |
| include  | 该路径下存放了一些平台特定的头文件。                         |
| jmods    | 该路径下存放了JDK的各种模块。                                |
| legal    | 该路径下存放了JDK各模块的授权文档。                          |
| lib      | 该路径下存放了JDK工具的一些补充JAR包。                       |



---

# 8.HelloWorld小案例

## 一、引入

HelloWorld案例是指在计算机屏幕上输出 `“HelloWorld”` 这行文字。各种计算机语言都习惯使用该案例作为第一个演示案例。这已经是程序员圈里约定俗称的一个规矩了，`"HelloWorld"` 就是程序员的启蒙代码。

---

## 二、Java程序开发运行流程

开发Java程序，需要三个步骤：

1. 用记事本编写程序
2. 编译文件
3. 运行程序。

----

## 三、如何理解编译？

Java在操作系统中，是不可以直接运行的，因为操作系统它是不认识Java代码的。

![image-20240327111954958](assets/image-20240327111954958.png)

运行的办法就是需要将Java代码翻译成操作系统能看得懂的东西。所以说编译的动作其实就是翻译把操作系统看不懂的内容变成操作系统能看懂的内容。

![image-20240327112105278](assets/image-20240327112105278.png)

所以第二步的编译，我们也可以理解成翻译的意思。翻译完后会产生一个新的文件，然后在第三步就可以运行翻译之后的文件了。

---

## 四、HelloWorld案例的编写

> 新版本的JDK不需要先配置环境变量。直接按照以下步骤编写即可。

### 1、新建文本文档文件，修改名称为HelloWorld.java。

<img src="assets/image-20240327112611211.png" alt="image-20240327112611211" style="zoom:50%;" />

**注意**：

- 后缀名为java的才是java文件。修改文件名后缀的时候会出现一个弹窗，点击yes即可。

  <img src="assets/image-20240327112843317.png" alt="image-20240327112843317" style="zoom:50%;" />

- 如果文件后缀名并没有展示，需要按如下步骤进行设置。勾选上文件扩展名，文件扩展名就是后缀名。

  <img src="assets/image-20240327113113809.png" alt="image-20240327113113809" style="zoom:50%;" />

----

### 2、用记事本打开HelloWorld.java文件，输写程序内容。代码要跟我编写的完全保持一致。

右键点击文件，然后点击打开，此时就可以使用windows自带的记事本来编辑了。

<img src="assets/image-20240327113353030.png" alt="image-20240327113353030" style="zoom:50%;" />

```java
public class HelloWorld {
	public static void main(String[] args) {
		System.out.println("HelloWorld");
	}
}
```

PS：双引号里写的是其他内容也行，可以是数字，也可以是字母，但不能是中文！因为会乱码，解决方案在后面Notepad++会讲解。现在先写最基本的“HelloWorld”就可以了。

这里可以养成一个习惯，只要出现括号、引号的，都要成对出现，敲完一对括号后，再将光标移到括号中间，再去补中间的代码就可以了，这样就会防止因为忘记丢掉右括号。

<img src="assets/image-20240327113633140.png" alt="image-20240327113633140" style="zoom:50%;" />

----

### 3、<kbd>ctrl + s</kbd> 保存，或者也可以直接图形化点击保存。

<img src="assets/image-20240327113957364.png" alt="image-20240327113957364" style="zoom:50%;" />

未保存的文件在上方一般都会有 `*` 符号或其他符号标记。像我这里，如果保存了就会从 `圆点` 变为 `×`

<img src="assets/image-20240327114203429.png" alt="image-20240327114203429" style="zoom:50%;" />



### 4、编译文件。

此时就需要使用到Java当中的工具了，找到JDK的安装目录里的bin文件夹`E:\develop\JDK17\bin`，我们所要找的工具一个是 `javac`，另一个是 `java`，用 `javac` 去编译，然后再用 `java` 去运行。`javac` 是JDK提供的一个编译工具，我们可以通过这个工具，把当前路径下的java文件编译成class文件。

<img src="assets/image-20240327132509702.png" alt="image-20240327132509702" style="zoom:50%;" />

这两个工具是在cmd中使用的。cmd默认操作的是 `C:\User\XXX` 下的文件夹，如果要进入到刚刚编写的HelloWorld所在的文件夹，就需要使用cmd命令进行切换了。

![](./assets/202404121033120.png)

切换到编写的HelloWorld.java所在的文件夹后，执行 `javac HelloWorld.java`。

![image-20240412103500313](./assets/image-20240412103500313.png)

执行完后如果没有任何信息出现，表示编译成功。编译后会多一个文件，这个文件就是翻译之后的文件，它的后缀名是class，所以我们也会把这个文件叫做class文件，或者是字节码文件。这个文件就是给操作系统在运行的时候使用的，我们人是看不懂的。

<img src="assets/image-20240327131001440.png" alt="image-20240327131001440" style="zoom:50%;" />

我们可以右键点击它，然后使用记事本打开。可以发现里面的东西我们是看不懂的。

<img src="assets/image-20240327131535808.png" alt="image-20240327131535808"  />

----

### 5、运行代码。

`java` 是JKD提供的运行代码的工具。接下来使用 `java` 工具，执行 `java HelloWorld`，注意不需要加上后缀名。运行的是编译之后的class文件。此时发现，HelloWorld已经出来了。

![image-20240412103527167](./assets/image-20240412103527167.png)

小技巧：如果不想每次编译的时候都切换路径，可以在java文件当前所在的文件夹的上方，直接输入cmd，然后回车。此时打开的cmd窗口所在的路径就是java文件所在的路径。

<img src="assets/image-20240327134250790.png" alt="image-20240327134250790" style="zoom:50%;" />



---

# 9.HelloWorld案例常见问题

## BUG

BUG（小甲虫）。计算机刚开始出现的时候，因为体积比较大，一些小虫子很容易转进去。有一天有一只蟑螂钻到了计算机当中，从而导致计算机不能正常运行，此时就有两个工作人员去排查了，就是下图的两个小姐姐。

<img src="assets/image-20240327133017667.png" alt="image-20240327133017667" style="zoom:50%;" />

在电脑系统或程序中，隐藏着的一些未被发现的缺陷或问题统称为bug（漏洞）。



## BUG的解决

1. 具备识别BUG的能力：多看
2. 具备分析BUG的能力：多思考，多查资料
3. 具备解决BUG的能力：多尝试，多总结



## HelloWorld常见问题

1、非法字符问题。Java中的符号都是英文格式的。

例如，下方将分号改为了中文的分号，然后重新编译，此时它就会报错——第三行出现了问题：错误：需要 ’ ; ‘，并且出现了一个小箭头，指向了小括号的后面，意思就是说：这个符号我不认识，是不是一个中文？

![image-20240327133403977](assets/image-20240327133403977.png)

有一个小技巧，可以避免标点符号的问题：将输入法设置为 `中文时使用英文标点`，以下以搜狗输入法举例。右击搜狗输入法，选择 `更多设置` ,然后勾选上 `中文时使用英文标点`，此时以后你输入的标点符号全部都是英文状态下的了。

<img src="assets/image-20240327133852177.png" alt="image-20240327133852177" style="zoom:50%;" />



2、大小写问题。Java语言对大小写敏感（区分大小写）。

例如将 `System` 的大写 `S` 改为了小写 `s`，重新编译，就会报以下错误。此时又会出现一个小箭头，表示在小箭头的前后出现了问题。

<img src="assets/image-20240327134448882.png" alt="image-20240327134448882" style="zoom:50%;" />



---

# 10.配置Java环境变量

## 一、引入

开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在bin目录下使用，而我们想要在任意目录下都能使用，所以就要配置环境变量。

但是上面我们编写HelloWorld小案例时，并没有配置环境变量，但为什么可以在非bin目录下使用 `javac` 和 `java` 这两个小工具的呢？

这是因为现在最新从官网上下载的JDK安装时会自动配置javac、java命令的路径到Path环境变量中去 ，所以javac、java可以直接使用。

---

根据以下步骤查询环境变量，发现，在安装完JDK后，环境变量多了一个。进入到此路径后，发现Java在安装的时候将 `javac` 和 `java` 这两个命令相当于做了一个快捷方式，放到了该路径当中，然后再把这个路径配置到环境变量里。所以我们就可以在任意目录下面用到 `javac` 和 `java` 了。

![image-20210923091654365](assets/image-20210923091654365.png)

----

## 二、配置Java环境变量

以前下载的老版本的JDK是没有自动配置的，而且自动配置的也只包含了4个工具而已，如果我们要使用其他的工具还是不能使用。所以我们需要删掉已经配置完毕的，并且将该 `C:\Program Files\Common Files\Oracle\Java\javapath` 路径下的工具都删除，再次重新配置Path环境变量。

<img src="assets/image-20240327144549909.png" alt="image-20240327144549909" style="zoom:50%;" />

最简单的方式就是将JDK的bin目录直接添加到path环境变量中，但是这种方式不推荐。因为这个里面有很多变量，当我们在操作的时候，很有可能会操作到其他变量信息，如果将其它的变量修改了，那在系统里面其它的软件就有可能打不开了。所以我们应该使用以下步骤进行配置：

① **JAVA_HOME**：告诉操作系统JDK安装在了哪个位置（未来其他技术要通过 `JAVA_HOME` 找JDK），注意这个地方的路径是不带 `bin` 的。这个相当于我们自己新建了一个：`JAVA_HOME`的路径。

<img src="assets/image-20240327145454203.png" alt="image-20240327145454203" style="zoom: 67%;" />



② 然后再点击**Path**，使用两个 `%` 引用我们刚刚自己定义的路径：告诉操作系统JDK提供的javac(编译)、java(执行)命令安装到了哪个位置。

然后再将这个环境变量移动当最上面即可。

![image-20240327145149851](assets/image-20240327145149851.png)

---

## 三、win10的bug

有些win10的电脑当电脑重启之后，环境变量失效了。表示操作系统不支持自定义的环境变量。

解决方案：还是要配置JAVA_HOME给以后的相关软件去使用，我们可以把java和javac的完整路径配置到PATH当中： `D:\develop\JDK17\bin`。



---

# 11.Notepad++

## 一、引入

以前在记事本上写的代码看上去有点累，因为所有的单词看上去都是黑色的，并且当代码出现问题后，它提示第三行，我们还需要一行一行去数。这些问题都可以由一个高级记事本：`Notepad++` 来解决。

---

## 二、下载 & 安装

**下载**：[Downloads | Notepad++ (notepad-plus-plus.org)](https://notepad-plus-plus.org/downloads/)

> 官网下载的速度可能有些慢，可以借助科学上网

**安装**：傻瓜式安装，直接点击下一步就可以了。

在选择安装路径的地方建议不要放在C盘，所有东西都放在C盘后，电脑会变的比较卡，建议专门找个文件夹，用来放跟我们开发相关的软件，因此这次还是放在 `E:\develop\notepad`。

---

## 三、设置

右键点击java文件，选择edit with notepad++。

<img src="assets/image-20240327150946225.png" alt="image-20240327150946225" style="zoom:50%;" />

点击设置，再点击首选项。在弹出的页面当中，左侧选择新建，中间选择Java，右侧选择ANSI，表示使用本地的默认编码，此时在代码的地方就可以写中文了。

![image-20240327150846770](assets/image-20240327150846770.png)

---

## 四、练习

利用notepad++去编写一个HelloWorld并能成功编译和运行。

使用notepad++定位到当前文件所在的命令行就更加方便了：

<img src="assets/image-20240327151305679.png" alt="image-20240327151305679" style="zoom:50%;" />



---

# 12.Java语言的发展

JAVA语言的诞生是具有一定戏剧性的，可以说是命运多舛，差点凉凉，差点GG，差点嗝屁。

![image-20240327153343805](assets/image-20240327153343805.png)

在1990年的时候Sun（Stanford University Network：斯坦福大学网络）公司成立了一个由 `James Gosling` 领导的Green计划，准备为下一代的职能家电，也就是电视机、微波炉、电话等去编写一个通用的控制器，这个负责人就是`James Gosling`，它也名为 `Java语言之父` 。

在一开始的时候，这个团队是准备用C++来编写的，但是发现C++在很多方面存在一些问题，使用起来十分不方便，导致项目的进展非常的缓慢，但是大神不愧是大神，编程语言不方便，就自己造一个，所以他们就造了一个全新的语言：`Oak语言`，起这个名字是因为他们项目团队的门前长了一颗橡树，Oak就是橡树的意思。

到了1992年的时候，Green计划已经完成了新平台的部分功能。包括Green的操作系统、Oak的程序设计语言、类库等。简单理解就是，已经用Oak语言已经做了很多很多事情了。

Sun公司看见这个团队这么牛逼，所以就在11月份，成立了由Sun公司全资的子公司，它的名字就叫做 `FirstPerson有限公司`。因为这家公司大多数都是程序员，不太会管理，所以因为管理不善，  `FirstPerson有限公司`几乎凉凉，Oak语言也差点凉凉。

但是到了1994年，随着互联网行业进入到快速的发展阶段，Java语言之父`James Gosling`非常有商业眼光，它立马改写了Oak语言。在同年秋天，完成了第一个Oak语言的网页浏览器，它的名字叫做WebRunner，这个浏览器现在已经不用了，但是在当时，它是一个跨时代的产品，Sun公司看到它们这么牛逼，所以就准备去给Oak注册商标了，但是Oak已经被一家投资公司美国橡树资本管理有限公司给注册过了，所以只能改名叫：JAVA。因为外国的程序员都是比较爱喝咖啡，而生产咖啡豆的地方叫做爪哇岛，所以就改名，叫做JAVA。

改完名字之后，在1995年的时候，正式推出了JAVA。

![image-20240327160129987](assets/image-20240327160129987.png)

随后又出现了 `1.0、1.1、1.2、1.3、1.4` 版本，但是Sun公司发现了，每次更新只改小数点后面一位，太小家子气了，所以从5开始就改成了大版本号更新，称之为 `Java5.0`。在06年的时候又推出了6.0。到了09年的时候，Sun公司被Oracle甲骨文公司收购了。Oracle公司在全球而言是非常厉害的公司，是仅次于微软的第二大网络公司。所以Java在Oracle手中，市场份额越来越大，语言的版本也在不断更新，到目前为止，最新的就是刚推出来的Java17。通过这么多版本出现的时间可以发现，从Java9开始，基本上都是6个月出一次版本，Java之所以要保持这么快的更新速度，其实就是为了紧贴市场的发展，使得Java自己不会被淘汰。

![image-20240327160704529](assets/image-20240327160704529.png)

但是这么快的更新速度会给我们开发者造成学习上的困扰，所以为了解决这些问题，Java会把这些版本分成两种：1、普通版（过渡版本）；2、正式版（长期支持版本）（长期支持版本会有LTS后缀）。

在这么多版本当中，其中Java8、Java11、还有我们现在学习用的Java17，就是LTS长期支持版本，所以从这一方面它就降低了开发者的学习成本。在这么多版本当中，其中有三个版本非常的重要：

* Java5.0：这是Java的第一个大版本更新。
* Java8.0：这个是目前绝大数公司正在使用的版本。因为这个版本最为稳定。
* Java17.0：这个是我们课程中学习的版本。

这些版本向下兼容。新的版本只是在原有的基础上添加了一些新的功能而已。

举例：

用8版本开发的代码，用11版本能运行吗？必须可以的。

用11版本开发的代码，用8版本能运行吗？不一定。

如果11版本开发的代码，没有用到9~11的新特性，那么用8是可以运行的。

如果11版本开发的代码，用到了9~11的新特性，那么用8就无法运行了。



---

# 13.JAVA三大平台 & Java的6大应用领域 & Java能干什么？

## 一、引入

JAVA从95年以来，已经问世了20多年了，可能比部分同学的年龄还大。

Java到底能干嘛呢，此时就需要讲到Java的三大平台，其实也就是它的三个分类：JavaSE、JavaME、JavaEE。

---

## 二、Java的三大平台

### 1）JavaSE

JavaSE（Java Standard Edition）是Java语言的标准版，用于桌面应用的开发，是其他两个版本的基础。

桌面应用：用户只要打开程序，程序的界面就会让用户在最短的时间内找到他们需要的功能，同时主动带领用户完成他们的工作并得到最好的体验。其实就跟我们电脑上安装的这些软件是类似的：例如电脑中的计算器，就是比较简单的桌面应用；还有像右边类似于坦克大战的游戏，也可以做成桌面应用，双击打开就可以玩了。

<img src="assets/image-20240327162534464.png" alt="image-20240327162534464" style="zoom:50%;" />

但是在这个领域，Java是不太合适的，因为当我们写一些比较复杂的动画的时候，Java加载的速速有可能会变的很慢。在桌面应用领域，最为合适的语言是C / C++，所以在这个领域，Java可以做，但是不占优势。

所以我们学习JavaSE的目的并不是是为了写桌面应用，而是锻炼大家的逻辑思维能力，为今后要从事的JavaEE开发打基础。

---

### 2）JavaME

JavaME（Java Micro Edition）是Java语言的小型版，用于嵌入式电子设备或者小型移动设备的开发。

嵌入式设备就是电视机、微波炉、数码相机这些里面的系统，当然还有一个最主要的：小型移动设备—手机。在以前，诺基亚手机风靡全球，它用的是塞班系统，当我们双击打开一个软件的时候，会有一个小的咖啡杯弹出来，这个软件就是用JavaME写的。随着塞班系统渐渐的没（mo）落，JavaME也渐渐的凉了。当你去一些招聘网站搜索JavaME，可以发现没有这样的工作档位，它现在已经被安卓和IOS给替代了。

![image-20240327163306459](assets/image-20240327163306459.png)

但是，安卓、鸿蒙也是可以用Java来开发的。

---

### 3）JavaEE

JavaEE（Java Enterprise Edition）是Java语言的企业版，用于Web方向的网站开发。在这个领域，是当之无愧的No1。

网站开发并不是我们看见的浏览器，完整的网站开发是浏览器和服务器开发，在服务器领域，Java是最厉害的。自从95年问世以来，没有一款语言能撼动它的位置。

![image-20240327163616794](assets/image-20240327163616794.png)

---

## 三、Java的6大应用领域

- 桌面应用开发

  制作各种各样的开发工具，有我们的Java程序员用到的Idea、C/C++用到的Clion、Python程序员用到的Pycharm。这是因为Java语言是比较规范，漏洞比较少，所以用Java语言编写的编译工具就会非常的健壮，不会有那么多漏洞以及安全性问题。

  在我国，由于一些历史原因，目前有很多办公系统，或者是市场上的税务管理系统也都是使用Java来开发的。

- 企业级应用开发

  在后续课程中其实就是带着大家去做企业级应用，像微服务、SpringCloud...

  企业级应用说简单点，就是开发服务器，而服务器可能要每秒钟承担几十万，甚至几百万的访问量，例如12306春节买票的时候，高峰期每秒钟有很多很多人，有几十万，甚至是几百万的人同事买票，到目前而言，只有Java，还有Go语言能承载这么大访问量，但是在国内，Go语言是非常小众的，所以还是用Java比较好一些。

- 移动端/嵌入式开发

  例如鸿蒙、安卓，并且CT、B超的界面，它也是用Java来开发的。

- 科学计算

  因为Java语言非常的严谨。有一个软件叫：matlab，有些同学在大学里面可能会用到，如果说你要搞一些数学的建模大赛、做一些仿真，开发一个机器人，机器人怎么走路，做一些动态的仿真效果，也是需要用到matlab。这个科学计算的软件也是使用Java来开发的。

- 大数据开发

  在大数据中有一个框架：hadoop，它的logo是一头大象。这个框架也是用Java来开发的。

- 游戏开发

  《我的世界》这款像素游戏也是用Java来开发的。

![image-20240327163745049](assets/image-20240327163745049.png)

----

## 四、Java能干的事情

最后来看一下Java能干的事情：

左上角的天猫、淘宝、阿里云、京东，这些就是服务器的开发，也就是企业应用的开发。

中间有个WebStorm，这个是前端程序员用的开发工具、PhpStorm是Php程序员用到的开发工具、IntelliJ IDEA是Java程序员用到的开发工具、PyCharm是Python程序员用到的开发工具，这些开发工具都是用Java来开发的。

右上角的机械臂，它里面的控制管理程序，也是用Java来开发的。

右中间有科学计算工具：matlab。

右下角的我的世界，也是使用Java来开发的。

![image-20240327165215425](assets/image-20240327165215425.png)



---

# 14.Java为什么这么火

## 一、怎么看语言火不火

一个语言火不火、能不能长久的生存下去，主要其实是看四个方面

### 1、用户量：使用的程序员多不多。

不管在国内，还是在国外，使用Java的程序员还是非常多的。

![image-20240327165621727](assets/image-20240327165621727.png)

----

### 2、适用面：用的地方多不多。

从以下6大领域可以看出来，用到Java的地方也是非常多的。

![image-20240327165700013](assets/image-20240327165700013.png)

----

### 3、与时俱进：会不会紧跟时代一起发展。

如果一个语言跟不上时代的发展，不管它有多牛逼，总有一天会被市场淘汰。

从Java9版本开始，基本上都是保持半年一更新，保持这么快的更新速度，就是为了紧贴市场的发展，一旦其他语言有什么好的东西，或者是市场上出现了什么了不得的技术，Java都可以把它们融进来成为自己的东西，让自己永远保持生命力，永远不会被市场淘汰。

![image-20240327165716730](assets/image-20240327165716730.png)

----

### 4、语言的本身是否有什么明显的特点

它的特点主要有以下几个：面向对象、安全性、多线程、简单易用、开源、跨平台

Java在上面这四个方面都做的非常的好，所以说Java的生命力还是非常强劲的。

---

## 二、Java主要特性

### 1、面向对象

等我们以后学习完Java的面向对象之后，你可以在心里面想象一下自己对女朋友的要求：性别、年龄、身高、体重还有一些其他的要求，然后你可以把这些东西都告诉Java：我想要一个这样的女朋友。Java非常好，它会说：好的，没问题，满足你。

根据你的要求给你制造了一个女朋友，这个就是Java中的面向对象。简单理解就是根据你想的模板，把东西创建出来，这就是面向对象。创建出来的东西可以是女朋友、车子、房子、票子..... 想造什么就造什么，这个就是Java当中最难理解的面向对象

----

### 2、安全性

Java写出来的代码非常的安全，漏洞非常的少。

----

### 3、多线程

假设在12306上买票，假如有4个用户同时在12306上买票，此时就可以看成12306的服务器同时给这四个人服务，这个就是多线程。

多线程简单理解：就是可以同时做多件事情。

----

### 4、简单应用

Java语言学起来非常简单，用起来也挺容易。

---

### 5、开源

假如我现在有一部手机，在手机上下载了QQ，此时我下载的仅仅是QQ的安装包，腾讯公司它是不会把QQ的代码给你的，这就叫做不开源。

而Java就是非常的简单粗暴了，同学们要往电脑中下载Java的开发工具的时候，Oracle公司它会把Java所有的源代码也都给你，这样就会告诉你Java是如何运行、如何工作的，这个就叫做开源。

一旦开源了，世界所有的开发者都可以去维护Java了，所以Java即使有什么缺点，也被广大的程序员给修复了，这就是开源的魅力。

----

### 6、跨平台

跨平台的平台指的是操作系统，例如：Windows、Mac、Linux。

Java程序可以在任意的操作系统上面运行，这个特点就很厉害了，很多其他的语言都干不了这些事情。而且这个特点对于公司来讲是非常有帮助的。

例如现在有家公司，利用了一种不能跨平台的语言开发了一个项目，此时只能在windows上去运行，不能在其他的操作系统上去运行，如果想要在其他的操作系统上运行，还需要重新编写代码。所以会给公司增加额外的成本。

<img src="assets/image-20240327171635220.png" alt="image-20240327171635220" style="zoom:50%;" />

但如果换成Java程序，就非常的粗暴了，一个人写的程序可以在所有的操作系统上运行，而且只要写一次就行了。Java在95年出现的时候，也是凭借这个特性，迅速的占领市场，当时它打出了一句口号：`Write Once Run Anywhere`（一次编译，到处运行）。

<img src="assets/image-20240327171734634.png" alt="image-20240327171734634" style="zoom:50%;" />



---

# 15.Java语言跨平台的原理

## 一、引入

说到跨平台的原理，就需要说到高级语言的编译运行方式。所有的高级语言，比如说：C、Java、Python等等，在运行的时候大体上会分为三步，之前在编写HelloWorld的时候也是

1. 编程：新建文件，编写代码，保存代码。

   java程序员写的.java代码，c程序员写的.c代码，python程序员写的.py代码。

2. 编译：不管是什么高级语言，操作系统本身都是不认识的，因为机器只认识0011的机器语言，所以我还需要把第一步编写好的代码进行翻译，翻译成机器能认识的语言。

3. 运行：让机器执行编译后的指令。

----

## 二、高级语言的三种编译运行方式

- 编译型
- 解释型
- 混合型，半编译，半解释（将上面两种都结合起来）

### 1、编译型

C语言就是标准的编译型语言，它会将C/C++代码根据不同的操作系统整体的翻译成0011这样的二进制，然后再交给机器去运行。但是因为每个系统都是不一样的，手机运行会用到Arm平台，电脑运行就会用到X86平台，由于每个系统所用到的平台可能是不一样的，所以在编译之后所形成的指令也有可能是不一样的。

![image-20240327173455083](assets/image-20240327173455083.png)

它的运行流程是这样的：

编写代码 —> 整体进行编译，跟java一样，它也会多出来一个后缀名为 `.obj` / `o`  等这样的文件，然后再去交给不同的设备去运行，在这里会有一个小细节，因为计算机是不一样的，所以它们就存在硬件也是不一样的，会有兼容性问题，所以针对不同的操作系统它都要重新进行编译。

更夸张的是，如果我编写代码的电脑的硬件跟运行代码的硬件之间差别特别大，就算是同一个操作系统，也有可能是没发成功运行的。所以说C语言不是跨平台的。

![image-20240327173828077](assets/image-20240327173828077.png)

---

### 2、解释型

解释性语言最为代表的就是Python语言，在编写好代码之后，它不会把代码的整体进行翻译，而是读一行解释一行。读到一行代码，再把这行代码解释成0011去运行，然后再去读第二行代码，然后再去解释成0011再去运行。

所以说通过这个我们就知道了，编译型语言它的特点是整体翻译，而解释型语言，它的特点是按行翻译。

![image-20240327174110043](assets/image-20240327174110043.png)

它的运行方式是这样的：编写代码 —> 按行翻译 —> 再交给不同的设备去运行

在这里它也有个小细节，Java / C在编译之后，它都会产生一个新的文件，但是Python不会，它是直接拿着我们自己编译好的代码逐行解释，再去交给设备去运行的。所以说Python程序员是天生开源的，它在编写好代码后，它只能把代码交给别人运行，如果说没有将代码交给别人，别人是没发运行的。

---

## 3、混合型，半编译，半解释（将上面两种都结合起来）

混合型最为典型的就是Java，在网上有很多资料，有的资料说Java是编译型的，有的资料说Java是解释型的，但这些都不对。Java是混合型的。在Java编译运行的过程中，存在编译，也存在解释。

首先将java文件整体编译成class文件（字节码文件） —>  **按行**交给设备去运行，在运行的时候，它也不是直接运行在计算机上的，而是运行在虚拟机里的。

![](./assets/202404121117368.png)

那问题就来了，虚拟机是什么？

如果说我现在要让手机上的游戏在电脑上运行，肯定是不能运行的。此时就可以在电脑中装一个安卓的处理区，相当于就是在操作系统里模拟了一部手机，在这部虚拟的手机中，就可以玩手机游戏了，这部虚拟出来的手机，我们也可以理解成 虚拟机。

<img src="./assets/image-20240412111918159.png" alt="image-20240412111918159" style="zoom:67%;" />

所以说Java语言在运行的时候，跟刚刚是一个道理，操作系统本身其实是不认识Java语言的，Java也并不是直接运行在操作系统里面的，而是运行在虚拟机里面的，虚拟机会把Java语言翻译成操作系统能看得懂的语言。我们只要针对不同的操作系统给出不同的虚拟机就可以了。这个虚拟机不是我们写的，是Java自己提供好的。而我们作为程序员，我们只需要安装一个适合自己操作系统的虚拟机就可以了。

![image-20210923091350952](assets\image-20210923091350952.png)



---

# 16.JRE和JDK

程序员在编写代码的时候其实是需要一些环境，例如我们之前写的HelloWorld。我们需要的东西有JVM、核心类库、开发工具。

1、**JVM（Java Virtual Machine）**：Java虚拟机，真正运行Java程序的地方。没有虚拟机，代码都没地方运行。

2、**核心类库**：例如之前写的HelloWorld代码中，里面的`System`、`out`、`println`，每个单词都有其特定的含义，它们组合在一起就可以把小括号的内容直接展示出来。这些其实都是Java已经写好的东西，我们直接拿过来使用就行了。

3、**开发工具**：例如：javac 编译工具、java 运行工具、jdb 调试工具、jhat内存分析工具 ......

它们三个组成的整体，就叫**JDK**。**JDK（Java Development Kit）称为Java开发工具包，包含了JRE和开发工具**。

所以说简单理解程序员想要编写代码并且能成功运行，我们需要安装一个JDK就可以了。

---

除此之外，还有一种情况需要我们考虑，假设我现在将代码写完了，也编译完了，此时我需要将class文件交给别人运行，此时人家只需要运行class文件就行了，不需要开发了，但此时别人就不需要再安装一个完整的JDK了，因为在JDK里面，有些东西我们是用不到的，如果强行安装，就会占用硬盘空间。

但我又需要运行代码，那应该安装什么呢？虚拟机、核心类库肯定都是需要的，但是在运行的时候有一部分开发工具就不需要了。例如代码已经写好了，已经不需要javac编译工具；并且此时代码别人写好了，也已经没有问题了，此时也不再需要调试了，jdb工具也用不到了。

所以说java会在JVM、核心类库还有在运行的时候所用到的一些工具单独的抽取出来，又组成了一个 JRE。当我们以后只需要运行代码，不需要编写了，安装一个JRE就可以了。JRE比较短小，不会占用过多的硬盘空间。

**JRE（Java Runtime Environment）**，Java运行环境，包含了JVM和Java的核心类库（Java API，即Java已经写好的一些东西，我们直接拿过来用就行了）。

![image-20210923091544110](assets\image-20210923091544110.png)

总结：JDK包含了JRE，JRE包含了JVM。



---

# ---------------------

# day02 - Java基础语法

# 17.注释和关键字

我们之前写的HelloWorld案例写的比较简单，但随着课程渐渐深入，当我们写一些比较难的代码时，在刚开始写完时，你知道这段代码是什么意思，但是等过了几天，再次看这段代码时，可能就会一脸懵逼，完全不知道自己写的代码是什么意思。

<img src="assets/image-20240328100431793.png" alt="image-20240328100431793" style="zoom:50%;" />

为了避免这种情况的发生，都会在代码的上面写一写解释说明性的文字，方便别人 / 以后阅读代码，而这种解释说明性的文字就是注释。

<img src="assets/image-20240328100443784.png" alt="image-20240328100443784" style="zoom:50%;" />



## 一、 注释

注释是在程序指定位置添加的说明性信息，简单理解，就是对代码的一种解释。

Java中的注释分为三种：

1、单行注释：它的格式是：`//` 后面加上注释信息，但是这些注释信息只能写在一行当中。

~~~java
// 这是单行注释文字
~~~

2、多行注释：当解释注释性文字比较多，一行写不下的时候，就需要用到多行注释了

~~~java
/*
这是多行注释文字
这是多行注释文字
这是多行注释文字
*/
注意：多行注释不能嵌套使用。
~~~

3、文档注释（暂时用不到）：

```java
/**
这是多行注释文字
这是多行注释文字
这是多行注释文字
*/
```

文档注释的场景：等我们以后牛逼了，要写一些代码去给别人使用。因为代码比较多，别人是不方便一行一行去阅读代码的，此时我们就可以提供一个说明文档，这个文档可以用Java自带的DOC工具自动生成，它可以根据左边的代码去自动的生成右边的文档。在生成的时候它会把文档注释里的内容都会添加在右边的文档当中。在以后，别人要用你代码的时候，就不需要去看代码了，直接看文档就可以了。

![image-20240328101222145](assets/image-20240328101222145.png)

---

代码示例

~~~java
public class HelloWorld{
	// 叫做main方法，表示程序的主入口。简单理解就是，程序刚开始运行的时候，会自动去找main方法，从main方法第一行代码，从上往下，逐行运行。所以这里的main方法格式是固定的。
	public static void main(String[] args){
		/* 叫做输出语句（打印语句）
		会把小括号里面的内容进行输出打印 */
		//System.out.println("HelloWorld");
	}
} 
~~~

**注意**：

- 注释的内容不会参与编译和运行的，仅仅是对代码的解释说明而已，当使用 `javac` 将java源文件编译成class文件后，在class文件里是不存在注释的。

  所以，不管在注释当中写什么内容，都不会影响代码运行的结果，但一般我们只会写跟代码相关的内容，其他的跟代码无关的，就不要再写了。

- 不管是多行注释还是单行注释，一律都不要嵌套。

  有些同学喜欢一句话打一个 `//`，但是这种写法不好

  ~~~java
  // 叫做main方法 // 表示程序的主入口。
  ~~~

  如果想要将一句话分开，可以打逗号、句号、或者其他的标点符号，这里就没有必要再加上多余的单行注释了。但是这样写语法是不会报错的。但是多行注释不能嵌套写！前面的 `/*` 会找距离它最近的 `*/` 来作为结尾。所以为了避免这样的问题，不管是多行注释还是单行注释，一律都不要嵌套。



---

## 二、关键字

关键字：被Java赋予了特定含义的英文单词。当我们在代码中写了关键字之后，程序在运行的时候，就知道要做什么事情了。

关键字特点：

1. 关键字的字母全部小写。
2. 常用的代码编辑器，针对关键字有特殊的颜色标记，非常直观。

例如我们安装的Notepad++对关键字就会有高亮显示，例如下面的代码中红线划出来的都是关键字。

![image-20240328104257018](assets/image-20240328104257018.png)



在Java中一共有50多个关键字，这些关键字不用刻意去记，因为每个关键字都包含了一个、甚至是多个知识点。

| **abstract**   | **assert**       | **boolean**   | **break**      | **byte**   |
| -------------- | ---------------- | ------------- | -------------- | ---------- |
| **case**       | **catch**        | **char**      | **class**      | **const**  |
| **continue**   | **default**      | **do**        | **double**     | **else**   |
| **enum**       | **extends**      | **final**     | **finally**    | **float**  |
| **for**        | **goto**         | **if**        | **implements** | **import** |
| **instanceof** | **int**          | **interface** | **long**       | **native** |
| **new**        | **package**      | **private**   | **protected**  | **public** |
| **return**     | **strictfp**     | **short**     | **static**     | **super**  |
| **switch**     | **synchronized** | **this**      | **throw**      | **throws** |
| **transient**  | **try**          | **void**      | **volatile**   | **while**  |



### class关键字

概念：表示定义一个类。创建一个类。

- 类：Java项目最基本的组成单元，一个完整的Java项目有可能会有成千上万个类来组成的。

- class后面跟随的就是这个类的名字，简称：类名。类名和文件名一定要保持一致！

  小技巧：如果怕类名写错，可以选中java文件，按F2，然后<kbd>ctrl + c</kbd>复制，粘贴类名即可

  ![image-20240328105843743](assets/image-20240328105843743.png)

- 在类名后面会有一对大括号，表示这个类的范围。

举例：

```java
public class HelloWorld{
    
}
```

解释：class表示定义类。

​	类名：HelloWorld

​	HelloWorld后面的大括号表示这个类的范围。



---

# 18. 字面量

在有些资料，会把字面量说成常量、字面值常量，这种叫法都不是很正确，最正确的叫法还是叫做：字面量。

作用：告诉程序员，数据在程序中的书写格式。

| **字面量类型** | **说明**                                  | **程序中的写法**           |
| -------------- | ----------------------------------------- | -------------------------- |
| 整数           | 不带小数的数字                            | 666，-88                   |
| 小数           | 带小数的数字                              | 13.14，-5.21               |
| 字符串         | 必须使用双引号，内容可有可无              | “HelloWorld”，“黑马程序员” |
| 字符           | 必须使用单引号，有且仅能一个字符          | ‘A’，‘0’，   ‘我’          |
| 布尔值         | 布尔值，表示真假，只有两个值：true，false | true 、false               |
| 空值           | 一个特殊的值，空值                        | 值是：null                 |

## 区分技巧

1. 不带小数点的数字都是整数类型的字面量。
2. 只要带了小数点，那么就是小数类型的字面量。
3. 只要用双引号引起来的，不管里面的内容是什么，不管里面有没有内容，都是字符串类型的字面量。
4. 字符类型的字面量必须用单引号引起来，不管内容是什么，但是个数有且只能有一个。
5. 字符类型的字面量只有两个值，true、false。
6. 空类型的字面量只有一个值，null。

代码示例：

~~~java
public class ValueDemo1{
	public static void main(String[] args){
		//目标：需要大家掌握常见的数据在代码中如何书写的？
		
		//整数
		System.out.println(666);
		System.out.println(-777);
		
		//小数
		System.out.println(1.93);
		System.out.println(-3.71);
		
		//字符串
		System.out.println("黑马程序员");
		System.out.println("尼古拉斯阿玮");
		
		//字符
		System.out.println('男');
		System.out.println('女');
		
		//布尔
		System.out.println(true); // true
		System.out.println(false); // false
		
		//空
		//细节：null不能直接打印的。
		//如果我们要打印null，那么只能用字符串（字面量）的形式进行打印
		System.out.println("null");
		
	}
} 
~~~

---

## 扩展： /t  制表符

很多人对制表符会这么去解释：它就表示缩进、对齐、打空格，但这些解释都是错的。

正确解释应该为：在打印的时候，把前面字符串的长度补齐到8，或者8的整数倍。最少补1个空格，最多补8个空格。

应用场景：对齐



**例如**：在java中 `\t` 可以使用单引号引起来，表示它是一个特殊字符，当然也可以用双引号引起来。

前面的字符串 `name` 长度为4，在打印的时候 `\t`就代表4个空格，然后再去打印 `age`。后面先打印 `tom`，然后制表符补5个空格，再去打印 `23`。中间的 `+` 号表示字符串的拼接。并且制表符在补空格的时候，只会跟前面的字符串有关系，跟后面的字符串是没有关系的。

所谓制表符就可以类似于我们打印表格数据的时候让数据去对齐，所以说在以后，看见了这些专业名词，它的名字都是有一些特殊含义的。

~~~java
public class ValueDemo2{
	public static void main(String[] args){
		//目标：熟悉制表符的基本用法
	
		System.out.println("name" + '\t' + "age");
		System.out.println("tom" + '\t' + "23");
		
	}
} 
~~~

<img src="assets/image-20240328111227356.png" alt="image-20240328111227356" style="zoom:50%;" />



---

# 19. 变量

**变量**：程序中临时存储数据的容器，在程序执行过程中，其值有可能发生改变的量（数据）。但是这个容器中只能存一个值。

**应用场景**：在我们登录页面的时候，里面要输入用户名、密码，如果我们想要登录，在程序中就需要将 用户输入的用户名和密码 跟 正确的用户名和密码进行比较，但是此时会有一个问题：用户输入的用户名和密码是一个变化的值，此时就可以定义两个变量，而变量就可以理解为是在程序当中存储数据的小箱子/小空间，第一个小空间里存储的就是用户输入的用户名，第二个小空间里存储的就是用户输入的密码，例如用户输入的 `itheima` 和 `123456` 就可以存进去，又或者说用户输了 `itcast` ，密码是 `112233` 同样也可以存进去，不管用户输入什么内容，直接存入对应的变量当中就可以了，我们就可以拿着变量去跟正确的用户名和密码进行比较了。

当某个数据经常发生改变时，我们就可以用变量存储。当数据变化时，只要修改变量里面记录的值即可。这个场景就体现了变量的 `变` 字。



## 变量的定义格式

~~~java
// 分号表示语句的结束
数据类型 变量名 = 数据值；
~~~

其中变量名就是给空间起的名字，简单理解就是小箱子的名字，给它起名是为了方便以后得使用，变量名不能重复。

数据值就是存在变量空间里的数据。

数据类型：限定了变量能存储数据的类型。

等号：赋值。把右边的数据赋值给左边的变量。

分号：表示语句的结束，就跟以前写作文时候的句号是一样的。

<img src="assets/image-20240328134045087.png" alt="image-20240328134045087" style="zoom:50%;" />

代码示例，下述代码打印出的结果就是 `10`

<img src="assets/image-20240328134857170.png" alt="image-20240328134857170" style="zoom:50%;" />



---

# 20.变量的使用方式和注意事项

## 变量的用法

![image-20240328135222309](assets/image-20240328135222309.png)

代码示例

~~~java
public static void main(String[] args) {
    //1.基本用法
    // 定义变量，再进行输出
    int a = 10;
    System.out.println(a);// 10
    System.out.println(a);// 10

    //2.变量参与计算
    int b = 30;
    int c = 20;
    System.out.println(b + c);//50

    //3.修改变量记录的值
    a = 50;
    System.out.println(a);//50
}
~~~



---

## 变量的注意事项

- 只能存一个值
- 变量名不允许重复定义
- 在一条语句中，可以定义多个变量。但是这种方式影响代码的阅读，所以了解一下即可。
- 变量在使用之前一定要进行赋值
- 变量的作用域范围

```java
public static void main(String[] args) {
    //注意事项
    //在一条语句中，可以定义多个变量
    int d = 100, e = 200, f = 300;
    System.out.println(d);
    System.out.println(e);
    System.out.println(a);

    //变量在使用之前必须要赋值
    // int g;
    // g = 500;
    // 建议:以后在定义变量的时候，请直接赋值
    // 不要把赋值分开写。
    int g = 500;
    System.out.println(g);
}
```

---

## 总结

![image-20240328140324905](assets/image-20240328140324905.png)



---

# 21.变量练习 - 计算公交车的人数

需求：说出公交车到终点站之后，车上一共有多少乘客？

​		    一开始没有乘客。

​		   第一站：上去一位乘客，没有下来乘客。

​		   第二站：上去两位乘客，下来一位乘客。

​		   第三站：上去两位乘客，下来一位乘客。

​		   第四站：没有上去乘客，下来一位乘客。

​		   第五站：上去一位乘客，没有下来乘客。

​		   问：到了终点站之后，车上一共多少乘客？

​	代码解析：

```java
public class VariableTest1{
	//主入口
	public static void main(String[] args){
		//一开始没有乘客。
		int count = 0;
		//第一站：上去一位乘客
		//在原有的基础上 + 1
		count = count + 1;
		//System.out.println(count);
		//第二站：上去两位乘客，下来一位乘客
		count = count + 2 - 1; 
		//第三站：上去两位乘客，下来一位乘客
		count = count + 2 - 1;
		//第四站：下来一位乘客
		count = count - 1;
		//第五站：上去一位乘客
		count = count + 1;
		//请问：到了终点站，车上一共几位乘客。
		System.out.println(count);//3
	}
}
```



---

# 22.计算机中的数据存储

在计算机中，只有以下三类数据（文本、图片、声音），而视频是很多图片的组合体。

其中文本又包括了数字、字母、汉字。

<img src="assets/image-20240328145253348.png" alt="image-20240328145253348" style="zoom:50%;" />

**在计算机中，任意数据都是以二进制的形式来存储的。**



## 十进制

在现实生活中使用的是十进制，十进制就是由`0123456789` 这十个数字组成，它的计算规则是：逢十进一，借一当十。<img src="assets/image-20240328151753927.png" alt="image-20240328151753927" style="zoom:50%;" />



例如：

### 1、十进制加法

1 + 1，在小学的时候，一般都是竖过来计算的，由于1 + 1是没有超过十的，直接计算即可。

但当数字变成 9 + 1的时候，此时就需要进一了，一旦进一了，个位就变成0了，而十位上没有任何的数字跟进上去的1相加，所以1直接落下来变成1，个位和十位组合在一起，就是个10。

<img src="assets/image-20240328150021061.png" alt="image-20240328150021061" style="zoom:50%;" />

如果是 `99 + 1` 呢？首先还是从右边的第一位跟下面的1相加，个位变成0，然后逢十进一；然后十位上的 9 跟进上来的 1 相加，结果还是10，然后再往百位进一，十位就变成了0；继续计算百位，百位只有进上来的1，所以百位最终就是1。个位、十位、百位组合在一起，最终的结果就是 `100`。

<img src="assets/image-20240328151155892.png" alt="image-20240328151155892" style="zoom:50%;" />

---

### 2、十进制减法

例如：`15 - 2`，个位的5跟2相减，变成3；十位的1下面没人跟它减，直接落下来，最终的结果就是 `13`。

<img src="assets/image-20240328151348560.png" alt="image-20240328151348560" style="zoom:50%;" />

但如果现在数字变成了  `15 -9` 呢？在一开始，还是个位跟个位减，但是这里 `5 - 9` 不够，不够就往前借，借过来的1当做10来处理，并且在借的时候，要在被借的地方打个点，因为十位上的1被借走了，所以十位上是没有数字能最终落下来的，所以最终的结果就是 `6`。

<img src="assets/image-20240328151646195.png" alt="image-20240328151646195" style="zoom:50%;" />

---

## 什么是二进制？

二进制就是由 0 和 1 这两个数字来组成的，它的计算规则是：逢二进一、借一当二。

<img src="assets/image-20240328151807453.png" alt="image-20240328151807453" style="zoom:50%;" />

### 二进制的运算过程

有个梗：`1 + 1` 在什么样的情况下不等于2？在二进制的时候不等于 `2`，而是等于 `10`，因为逢二进一。

<img src="assets/image-20240328151944107.png" alt="image-20240328151944107" style="zoom:50%;" />

十进制中的3就是在2加一，变成 `11`，十进制中的4，就是 `11 + 1`，在计算的时候也是从右往左计算的，个位1 + 1，逢二进一，一旦进位了，那么原来位置上就变成了0，前面的位置上会有个进一（蓝色的数字）；进一后，跟原来的位置上的数相加加完后，又变成了2，此时继续进1，最终的结果就变成了 `100`。

<img src="assets/image-20240328152113661.png" alt="image-20240328152113661" style="zoom:50%;" />

---

## 常见的进制

除了十进制和二进制外，还有八进制和十六进制。八进制和二进制是类似的，它是由 `0-7` 组成的，缝八进一。十六进制就是缝十六进一，它是由 `0-9` 和 `a - f` 组成。

<img src="assets/image-20240328152806968.png" alt="image-20240328152806968" style="zoom:50%;" />

这么多进制就有可能会出问题，比如说我在代码中书写一个 `1`，那你怎么知道这个1是多少进制呢？因此，Java给这些进制还做了一些规定，这种规定是在JDK7的时候才提出来的。

<img src="assets/image-20240328153031976.png" alt="image-20240328153031976" style="zoom:50%;" />

---

## 计算机为什么要用二进制存储数据？

下图是上个世纪计算机所用到的打孔纸带，这个纸带其实就是我们自己书写的代码，其中打了孔是0，没打孔是1。感兴趣的朋友可以搜索一下 `IBM 29卡打孔机` 相关视频，看完视频会理解更加通透。

<img src="assets/image-20240328153931138.png" alt="image-20240328153931138" style="zoom:50%;" />

如果我现在想让计算机去执行代码，就得把这个纸带去给计算机。

<img src="assets/image-20240328154036248.png" alt="image-20240328154036248" style="zoom:50%;" />

计算机一遍读取程序，一遍在纸带上打孔，然后在计算机上方会打印出程序运行的结果，例如下图就是一台1958年的电脑顺着纸带打印的程序运行的结果。

<img src="assets/image-20240328154217684.png" alt="image-20240328154217684" style="zoom:50%;" />

在以前，想要编程，必须先准备一个很长很长的纸带，然后用打孔器去打孔。但是如果手抖，打错了怎么办？所以在以前，程序员有两个神奇：胶水、改正纸，如果一不小心多大了一个孔，就用胶水和改正纸把孔给补上，但是如果错的太多，就只能重新打孔。这个就是上个世纪60年代的计算机，因为在纸带上面，只有两种状态：有孔和没孔，所以说在当时，计算机就使用二进制的形式来表示的。

那你想，如果当时用十进制去表示，那怎么在纸带上去表示十个完全不一样的状态呢？如果有人说将一个圆只打1 / 2、1 / 4等去表示不同的状态，这肯定不行，因为看左右图纸带上的孔，它只有一丢丢打，在当时计算机也没有那么精密，是区分不了孔的大小的，它只能区分有孔和没孔这两个状态。

![image-20240328155907297](assets/image-20240328155907297.png)

而这个习惯在我们现在计算机中也延续了下来，例如右图的这种电路板，平时在计算机里，用的更多的是那种5V的电路板，所以说就有个规定，会把大于3.3v的定为1，小于3.3V的定为0，这个就是2进制的由来。

![image-20240328160122808](assets/image-20240328160122808.png)

所以说计算机为什么使用二进制去存储数据，就是因为只要两种状态就可以表示二进制，在以前是有孔和没孔，在现在是高压电流和低压电流。那如果在计算机里要用十进制去表示，就需要十个完全不一样的状态，这个就太麻烦了。

---

## 进制之间的转换

进制之间的转换可以分成两种：1、任意进制转十进制；2、十进制转任意进制

### 1、任意进制转十进制

公式：`系数 * 基数的权次幂，然后将每一位相加`

系数：就是每一位上的数

基数：当前进制数，例如：将2进制转为十进制，基数就是2

权：从右往左，依次为 0 1 2 3 4 5 ....依次递增



#### 1）二进制101转十进制

第一步：将每一位都按照系数 * 基数的权次幂算出来，算完后得到三个结果，最终再相加就行。

- 右边的第一个因为右边的数字是1，所以它的系数就是2，又因为当前是二进制，所以基数就是2，权是从右开始，0、1、2...依次递增，所以右边的第一位就是0。

- 同理，再看中间这一位，系数是0，因为当前位置上的数是0，基数是2，因为当前是2进制，权是1，因为它是从右往左是第二位。

- 左边这位，系数是1，基数是2，权是2。

此时我们就可以将上面三个数据分别计算出来，然后相加，得到最后结果5，所以二进制 `101` 转成十进制后就是 `5`。

![image-20240328192951764](assets/image-20240328192951764.png)

但其实，二进制转十进制有一种快速的转换方法，这种方法叫做8421快速转换法。

##### 8421快速转换法

每一个二进制值的1都是代表一个固定数值。把每一位的1代表的十进制数加起来得到的结果就是它所代表的十进制数。

例如：给二进制 `11111111` 制定一张表，在这张表中，它每一位所对应的数字从右往左对应的十进制列出来。如果我现在要将二进制的 `1101` 转为十进制怎么办？解答：拿着 `1101` 到这张表里去查，有1直接对应它的十进制数，如果该位是0就不用管，然后将对应的数字拿出来，然后相加。所以此时我们就可以认定二进制 `1101` 转成十进制后，结果为13

![image-20240328193931555](assets/image-20240328193931555.png)

---

#### 2）八进制101转十进制

同样的也是带入公式即可。系数还是每一位当中的数字，基数就是当前的进制，但是当前是八进制了，所以基数就变成了8。权的规则还是和刚刚一样，从右往左，分别是0、1 、2 、3.....

![image-20240328192930035](assets/image-20240328192930035.png)

---

#### 3、十六进制abc转十进制

- 右边位：因为当前位数字是c，所以系数是12。又因为当前数字是十六进制的，所以基数是16。权从右往左开始，它是0。

- 中间位：当前的数字是b，b所对应的数字是11，所以这里的系数就是11。当前是十六进制的，所以基数是16。权从右往左开始，当前是1。

- 左边位：同理，系数是10，因为a所对应的数字是10。基数是16，权是2。

最终将上面计算出的结果相加，十六进制 `abc` 转十进制得到的结果为 `2748`。

![image-20240328192828584](assets/image-20240328192828584.png)

---

### 2、十进制转其他进制

解决方案：除基取余法。不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。

#### 1）十进制转二进制

例如十进制 `11` 转二进制，直接拿着11不断除以2即可。`7`转二进制也同理。

![image-20240328194853049](assets/image-20240328194853049.png)

在有些资料中在相除的时候不会除到商为0，它偷懒了，商到1就结束了。然后再从商倒着拼接，也是 `1011`，这种计算方式也是可以的，只不过它是偷懒了，并不是正统的解法。正统应该是一直除，除到0结束，然后所有的余数拼接起来，这个才是最正确的解法。

<img src="assets/image-20240328195425992.png" alt="image-20240328195425992" style="zoom:50%;" />

---

#### 2）十进制转八进制

跟二进制同理，在除的时候不要除2，除8就行了。

---

### 总结

![image-20240328195649320](assets/image-20240328195649320.png)

---

此时，你已经对二进制已经了解了，并且对数字的存储，你也已经了解了，简单一句话就是转成二进制，再进行存储。例如 `99` 转成二进制就变成 `0110 0011`，但其实这个东西并不需要你去口算，刚刚说的进制的转换，其实是给大家增加见闻的，真的要算可以使用电脑的计数器。

打开计算器，然后切换到程序员模式，展现的数字从下到上分别为：二进制、八进制、十进制、十六进制，点击需要输入的数字的进制类型，然后输入数字即可。

![image-20240328200304072](assets/image-20240328200304072.png)

例如计算十进制 `99` 的二进制是多少：点击DEC，然后输入99，再点击BIN，在最上方出现的就是十进制 `99` 转二进制后的结果。

<img src="assets/image-20240328200752665.png" alt="image-20240328200752665" style="zoom:50%;" />

---

## 字母在计算机中的存储

字母跟二进制又是个什么关系，怎么就对应起来的呢？说到这里，我们就要说到一张码表，它的全称叫做 `American Standard Code for Information Interchange`（没过信息交换标准码表），但我们在说的时候不会说它的全称，太长了，我们会把每个单词的首字母拿出来，进行一个缩写，就变成了 `ASCII码表`，在 `ASCII码表` 中，每一个字母都跟一个唯一的数字产生对应关系。

![image-20240328201817803](assets/image-20240328201817803.png)

例如字母a，十进制对应的是97。

<img src="assets/image-20240328201846600.png" alt="image-20240328201846600" style="zoom:50%;" />

所以字母在存储的时候，就是通过查询ASCII码表的方式来进行存储的，找到对应的数字之后，再把它变成二进制存储到计算机中。

---

## 汉字在计算机中的存储

由于ASCII码表是外国人创造的，它在创造ASCII码表的时候并没有考虑到中文。就是因为这，中国的汉字差点就灭了，感兴趣的同学可以自行百度，由于涉及到历史和政治的原因，在这里就不说了。我们一直说的 `秀` 就是代表人物之一。

为了解决汉字在计算机中的存储问题，在上个世纪80年代，我们国家自己推出了一张 `GB 2312`。看这个纸它都黄了，我相信比大多数同学的年龄还大。在这张码表当中，它就规定了汉字跟一个唯一的数字会产生一个对应关系，从这个时候开始，汉字才能在计算机中进行存储和运行。

<img src="assets/image-20240328202305879.png" alt="image-20240328202305879" style="zoom:50%;" />

---

## 计算机的存储规则

**1、GB2312编码：1981年5月1日发布的简体中文汉字编码国家标准。收录7445个图形字符，其中包括6763个汉字。**

过了几年，台湾地区也仿照大陆，自己推出了一个`BIG5码表`，在这个码表当中，它收录的都是一些繁体字，要注意的是，在 `GB2312`里只有简体中文，是没有繁体的。所以这就出现了一个国家，有两张码表。

**2、BIG5编码：台湾地区繁体中文标准字符集，共收录13053个中文字，1984年实施。**

但是这可不行，一个国家怎么能有两张码表，都不统一。于是在2000年3月17日推出了一张`GBK码表`，`GBK码表`也是目前windows操作系统默认使用的码表。

**3、GBK编码：2000年3月17日发布，收录21003个汉字，包含国家标准GB13000-1中的全部中日韩汉字，和BIG5编万码中的所有汉字。**

但是还是有点小不足，因为像一些非洲国家，或者是欧洲国家的文字在这张码表里面还是不包含的，因此在后来，有一个国际组织：美国国家标准协会，它提出了一个 `Unicode码表`，这张码表称之为：万国码，号称一万个国家的码表，这里的万只是一个虚词，它就表示在这个码表当中，包含了世界上大多数国家的文字。

**4、Unicode编码:国际标准字符集，它将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换。**

正是因为有了这些包含中文的码表，中文才能够在计算机中起飞，而且以后会飞的越来越好，越来越高。

简单来说，数字就是转成二进制，字母跟汉字都是查询对应的码表，先找到对应的数字，再转成二进制进行存储。

接下来我们再来研究，第二类数据：图片数据。

<img src="assets/image-20240328145253348.png" alt="image-20240328145253348" style="zoom:50%;" />

---

## 图片数据在计算机中的存储

图片数据在计算机中分为三种，从左往右分别是：黑白图、灰度图、彩色图。

![image-20240328203848605](assets/image-20240328203848605.png)

要说到图片数据在计算机中的存储，还得来说一说显示器中的三个知识点：分辨率、像素、三原色。

说到像素，就要说到显示器，在平时电脑显示器当中，见到的最多的就是：2K屏、4K屏，但其实这说的是它们的最大分辨率。

2K屏的最大分辨率有：`1920 × 1080`、`1998 × 1080`、`2048 × 1080`、`2048 × 858`。

而右边的4K屏最大分辨率有：`3840 × 2160`、`3996 × 2160`、`4096 × 2160`、`4096 × 1716`。

其中最为常见的是2K屏中的 `1920 × 1080`、`3840 × 2160`。

![image-20240328204110067](assets/image-20240328204110067.png)

下面以`1920 × 1080 `来讲解一下这些分辨率表示什么意思。

其实就是表示，在显示器中，宽有1920个小格子，高有1080个小格子，整个显示器就是由这么多方形的小格子来组成的，而这里的每一个小方格就称之为一个像素。

<img src="assets/image-20240328204545179.png" alt="image-20240328204545179" style="zoom:50%;" />

我们也可以在屏幕上画一笔，然后再把这一笔放大，此时可以发现这个图片的周围会有锯齿，就是因为显示器是由很多很多方形小格子组成的。

<img src="assets/image-20240328204656410.png" alt="image-20240328204656410" style="zoom:50%;" />

如果说我们以后要写一个软件，我们要设置软件的大小，我们现在会设置软件的宽为514像素，高为595个像素，它差不多占屏幕宽度的1 / 4，高度的1 / 2。如果说我想要这个软件变大一点，就可以将它的宽高调大：宽603个像素，宽可以写680个像素。

<img src="assets/image-20240328204933470.png" alt="image-20240328204933470" style="zoom:50%;" />

在后面，我们会有一个练习，会带着大家去写一个游戏，游戏当中就会用到像素的概念了，所以说当以后，我们开始写游戏的时候，我让你设置宽高为100个像素的时候，我问你这个游戏大概有多大，你不能回答我：大概有这么大，大概有这么宽了。

---

### 1）黑白图

说完像素，就可以来解释黑白图了。在这个黑白图中画了一个笑脸，上面两个黑点表示眼睛，下面一个湾勾，就好比嘴巴。其实在黑白图当中，就是给每个像素点去涂抹了颜色，其中白色就是1，黑色就是0。

<img src="assets/image-20240328205301901.png" alt="image-20240328205301901" style="zoom:50%;" />

---

### 2）灰度图

直到灰度图之前，首先需要直到灰度表。在这张表当中，0是纯黑，255是纯白，中间就是一些不同层次的灰。

在下面这张图中，画了一个8，在没有8的地方就视为0，在画了8的地方就显示不同程度的灰色。例如第一排的8就是64、142 、146 、182......组合在一起，就是左边的8。

<img src="assets/image-20240328205525068.png" alt="image-20240328205525068" style="zoom:50%;" />

---

### 3）彩色图片

彩色图片是我们平时见过最多的，那这个彩色图片又是怎么记录里面的色彩的呢？其实跟刚刚也是类似的，下面就将图片嘴唇的位置进行放大。

<img src="assets/image-20240328205713966.png" alt="image-20240328205713966" style="zoom:50%;" />

在彩色图中，其实就是我们在给一个像素点里记录不同的颜色就可以了，那这个颜色该怎么记录呢？这时就需要先明白三原色（红黄蓝），通过三原色我们就可以搭配出各种各样五彩缤纷的颜色了。这三种颜色我们也称之为美学三原色。

<img src="assets/image-20240328205916524.png" alt="image-20240328205916524" style="zoom:50%;" />

在计算机当中其实也有三原色的存在，它叫做：红绿蓝，这三种颜色称之为光学三原色。

在计算机里面每个像素点的内部，其实就是由红绿蓝来组成的，我们可以讲左边的屏幕放大来看一下。在这里看见的每一个红绿蓝组成的一个整体就是一个像素点，现在就是由很多很多个像素点组成在一起，就组成了一张完整的图片，在计算机中，就是通过三种颜色的搭配，就可以组合出五彩缤纷的颜色了。

![image-20240328210548464](assets/image-20240328210548464.png)

所以在这里我们要知道，计算机中的光学三原色是：红绿蓝！

我们可以去给这三种颜色设置不同的值，值越大表示当前的颜色越浓；值越小，表示当前的颜色越淡。

如果说红色设置为43，绿色设置为123，蓝色设置为194，那我就可以理解：由43份红色的颜料、123份绿色的颜料跟蓝色份194份蓝色的颜料，这么一搅和，就可以搭配出不知道怎么描述，但是还挺好看的蓝色。其他形成的颜色也同理。我们在取值的时候，里面的值是不能乱写的，它是由取值范围的，一定要写在 `0 ~ 255`之间，包含0也包含255。

![image-20240328211229779](assets/image-20240328211229779.png)

如果说，我们在指定颜色的时候，写的是这种：`(255，0，0)`，那就表示不用绿色，不用蓝色，只用红色，最终就是纯红色。其他颜色同理。

![image-20240328211405399](assets/image-20240328211405399.png)

上面是用十进制的颜色去表示的，同样我们也可以用十六进制的颜色去表示，十进制的255刚好对应FF。所以在十六进制下最小还是0，最大就是FF。

---

### 三原色小结

1、在计算机中，颜色是采用光学三原色

2、一个像素点里有红、绿、蓝三种颜色组成，通过这三种颜色的搭配我们就可以组成各种各样的颜色，这个颜色我们取它英文的首字母R（Red）、G（Green）、B（Blue），称这三种颜色叫RGB三原色。

3、可以讲光学三原色写成十进制的表示形式，每一位有范围0 - 255。（255,255,255）

4、当然也可以写成十六进制的表示形式，最小是0，最大是FF。（FFFFFF）

---

### 解释彩色图片

有了像素和三原色的知识点，我们就可以解释彩色图片了，在彩色图片当中，每一个像素点就是搭配了不同的三原色从而组成了各种各样漂亮的图片。所以说，在你手机里存储着各种各样让你舍不得删除的图片，其实就是一组又一组不同数据搭配出来的颜色而已，从计算机的角度来看，左边的美女和右边的美女其实它们两个是一样的。

![image-20240328212423857](assets/image-20240328212423857.png)

---

## 声音在计算机中的存储

声音的存储会涉及到这种声音的波形图，看右边，这个就是声音的波形图。在波形图中，每一个点都会有每一个数字去跟它对应。

![image-20240328212544020](assets/image-20240328212544020.png)

那我们平时在听音乐的时候，如果你氪金了，音质就会非常好，但你的朋友没有氪金，它听的就是全损音乐，那这怎么通过技术来实现呢？其实很简单。

我们在存储声音的时候会对声波进行采样，每个点都会有对应的数字。如果你氪金了，采样的点（比如说下图的黑点）就会比较多，记录的数据也非常的多，在听音乐的时候可以最大程度去还原音乐。

![image-20240328212837404](assets/image-20240328212837404.png)

但如果说你的好朋友没有氪金怎么办，此时采样的点就会变的非常的少，那么他在听音乐的时候就是全损音乐，它在还原的时候就不会还原出最原本的声音了。例如在下面这张图中，红色是最原本的声音，但是因为现在没有氪金，采样点比较少，它的还原的时候就不会按照红色的进行还原，而是以你采样的黑点来进行还原。

它在还原的时候就会有这种情况：一直连接黑点，但是在峰值的地方可能无法还原出来，因为在上面是没有对应的采样点的。

![image-20240328213418856](assets/image-20240328213418856.png)

---

## 计算机的存储规则小结

在计算机中，任意数据都是以二进制的形式来存储的。

在计算机中会有以下的三类数据，分别是：文本、图片、声音。其中文本又包含了数字、字母、汉字。

![image-20240328213604574](assets/image-20240328213604574.png)

数字是直接变成二进制来存储的。

字母跟汉字是查询不同的码表，先变成数字，再变成二进制，再来进行存储的，这个码表是不需要你自己去下的，每一个操作系统里都会内置。

图片是通过每一个像素点里的RGB三原色来进行存储的。

声音是对波形图进行采样，然后再变成二进制进行存储的。

![image-20240328213801661](assets/image-20240328213801661.png)



---

数据类型、标识符、键盘录入这三个都是跟变量相关的。在之前章节，我们学习了变量的定义格式，为： `数据类型 变量名 = 数据值`。一会我们学习的知识点都是跟变量相关的，数据类型 跟 数据类型相关，标识符 跟 变量名相关，键盘录入 跟 数据值相关。

# 23.数据类型

在Java中数据类型分为两种：

- 基本数据类型
- 引用数据类型（面向对象的时候再深入学习）



## 基本数据类型的四类八种

在Java中，基本数据类型是分为四类、八种的。之所以整数、浮点数又细分，最为本质的区别是它们的取值范围是不一样的。

整数最小的是byte类型的，它的取值范围是 `-128 - 127`，所以说如果你把一个两百，赋值给byte类型的变量，这个就是错的！

常用的int取值范围是 `负的2的31次方 ~ 2的31次方-1`，long的取值范围就更大了，它是一个19位的数。取值范围不一样，在内存中所占用的空间也是不一样的。具体的在内存中占用的 1 、2 、4 、8 、4 、8 、2 、1这些东西暂时不要去记忆，因为它们会涉及到计算机底层的存储原理，在后面学习第二阶段的时候，会进行深入讲解，现在先了解一下就可以了。

那我们我们在实际使用的时候，整数类型一般会使用int，小数类型一般会使用double。

|    数据类型    | 关键字  | 内存占用 |                 取值范围                  |
| :------------: | :-----: | :------: | :---------------------------------------: |
|      整数      |  byte   |    1     |    负的2的7次方 ~ 2的7次方-1(-128~127)    |
|                |  short  |    2     | 负的2的15次方 ~ 2的15次方-1(-32768~32767) |
|                |   int   |    4     |        负的2的31次方 ~ 2的31次方-1        |
|                |  long   |    8     |        负的2的63次方 ~ 2的63次方-1        |
| 浮点数（小数） |  float  |    4     |        1.401298e-45 ~ 3.402823e+38        |
|                | double  |    8     |      4.9000000e-324 ~ 1.797693e+308       |
|      字符      |  char   |    2     |                  0-65535                  |
|      布尔      | boolean |    1     |                true，false                |

**说明**：

​	e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。

​	在java中整数默认是int类型，浮点数默认是double类型。

---

### 定义8种基本数据类型变量

```java
public class VariableDemo3{
    public static void main(String[] args){
        //1.定义byte类型的变量
        //数据类型 变量名 = 数据值;
        byte b = 10;
        System.out.println(b);

        //2.定义short类型的变量
        short s = 20;
        System.out.println(s);

        //3.定义int类型的变量
        int i = 30;
        System.out.println(i);

        //4.定义long类型的变量
        // long l = 9999999999; => 此时会报错：整数太大
        // 如果要定义long 类型的变量，在数据值的后面需要加一个L作为后缀
        // L可以是大写也可以是小写，但是个人建议使用大写，因为小写 l 和数字 1 长得很像
        long l = 123456789123456789L;
        System.out.println(l);

        //5.定义float类型的变量
        // 定义float类型变量的时候，数据值也需要加一个 F 作为后缀，同样大小写都可以，但是为了保持跟上面一致，
        float f = 10.1F;
        System.out.println(f);

        //6.定义double类型的变量
        // double类型的变量就不需要加上后缀了，跟之前的定义方式是一样的。
        double d = 20.3;
        System.out.println(d);

        //7.定义char类型的变量
        char c = '中';
        System.out.println(c); // 中

        //8.定义boolean类型的变量
        boolean b = true;
        System.out.println(b);
    }
}
```

---

## 需要记忆以下几点

byte类型的取值范围：-128 ~ 127

int类型的大概取值范围：-21亿多  ~ 21亿多

整数类型和小数类型的取值范围大小关系：double > float > long > int > short > byte

最为常用的数据类型选择：

- 在定义变量的时候，要根据实际的情况来选择不同类型的变量。

  比如：人的年龄，可以选择byte类型。

  比如：地球的年龄，可以选择long类型。

- 如果整数类型中，不太确定范围，那么默认使用int类型。

- 如果小数类型中，不太确定范围，那么默认使用double类型。

- 如果要定义字符类型的变量，那么使用char

- 如果要定义布尔类型的变量，那么使用boolean

## 注意点

- 如果要定义 一个整数类型的变量，不知道选择哪种数据类型了，默认使用int。
- 如果要定义 一个小数类型的变量，不知道选择哪种数据类型了，默认使用double。
- 如果要定义一个long类型的变量，那么在数据值的后面需要加上L后缀。（大小写都可以，建议大写。）
- 如果要定义一个float类型的变量，那么在数据值的后面需要加上F后缀。（大小写都可以，建议跟上面的L做一个统一，也是大写F。）



---

# 24.定义变量的三个练习

## 练习1：定义5个变量记录老师的信息并打印

<img src="assets/image-20240329153600046.png" alt="image-20240329153600046" style="zoom:50%;" />

代码示例：

```java
public class VariableTest1{
	public static void main(String[] args){
		//1.定义字符串类型的变量记录老师的姓名
		String name = "黑马谢广坤";
		//2.定义整数类型的变量记录老师的年龄
		int age = 18;
		//3.定义字符类型的变量记录老师的性别
		char gender = '男';
		//4.定义小数类型的变量记录老师的身高
		double height = 180.1;
		//5.定义布尔类型的变量记录老师的婚姻状况
		boolean flag = true;
		
		//输出5个变量的值
		System.out.println(name);
		System.out.println(age);
		System.out.println(gender);
		System.out.println(height);
		System.out.println(flag);
		
	}
}
```

---

## 练习2：输出电影信息

需求：将（电影名称，主演，年份，评分）四个信息选择不同类型的变量，随后打印出来。

 代码示例，小数都默认使用double：

```java
public class VariableTest2{
	public static void main(String[] args){
		//1.定义字符串变量记录电影的名称
		String movie = "送初恋回家";
		//2.定义三个变量记录主演的名字
		String name1 = "刘鑫";
		String name2 = "张雨提";
		String name3 = "高媛";
		//3. 定义整数类型的变量记录年龄的年份
		int year = 2020;
		//4.定义小数类型的变量记录电影的评分
		double score = 9.0;
		
		//打印变量的信息
		System.out.println(movie);
		System.out.println(name1);
		System.out.println(name2);
		System.out.println(name3);
		System.out.println(year);
		System.out.println(score);
		
	}
}
```

---

## 练习3：输出商品信息

需求：选择其中一部手机，将（手机价格，手机品牌）两个信息选择不同类型的变量，随后打印出来。 

 代码示例：

```java
public class VariableTest3{
	public static void main(String[] args){
		//1.定义小数类型的变量记录手机的价格
		double price = 5299.0;
		
		//2.定义字符串类型的变量记录手机的品牌
		String brand = "华为";
		
		//输出变量记录的值
		System.out.println(price);
		System.out.println(brand);
	}
}
```



---

# 25.标识符

在以前我们起变量名的时候，用的都是a、b、c、d这样的字母。这样起名非常不规范，起的名字没有任何意义，并且时间长了，也就忘了a、b、c、d表示什么含义了。接下来我们就学一个知识点：标识符，让我们在以后能取一个符合规则的名字。

那么，什么是标识符，它跟变量名又有什么关系呢？

**标识符**：就是给类，方法，变量等起的名字。所以说标识符它是一个统称，凡是在代码当中我们自己起的名字（类名，方法名，变量名）都可以叫做标识符。

起名字到底有什么规矩呢？在现实生活中，其实我们也会起各种各样的名字，这些名字也会有明明规则：都是汉字、名字的个数有一定的限制、包含特殊的寓意。因此我们在Java中起名字也要遵守一定的规则，这些规则我们可以遵守业内大多数程序员都在遵守的阿里巴巴命名规则。打开 `阿里巴巴Java开发手册终极版`，在这个里面就规定了我们在写代码时候的命名规范

---

## 1、硬性要求：必须要这么做，否则代码会报错。

- 必须由数字、字母、下划线_、美元符号$组成。

- 数字不能开头

- 不能是关键字，因为关键字Java已经给它赋予了特殊的含义，我们自己就不能再用它了。

  例如我们之前学习的 `class` 关键字，那么在以后，我们取名就不可以使用class关键字了。

- 区分大小写的。

  关键字在Java中全都是小写的，而在java中又是区分大小写的，所以我们是可以使用 `Class` 的。 



## 2、软件建议：如果不这么做，代码不会报错，但阅读性非常差，显得非常不专业，是会让代码显得比较low。

下面是代码中关于起名字的软性建议。

### 1）小驼峰命名法

适用于变量名和方法名

* 如果是一个单词，那么全部小写，比如：name

* 如果是多个单词，第一个单词首字母小写，从第二个单词开始，首字母大写，比如：firstName、maxAge



### 2）大驼峰命名法

适用于类名

* 如果是一个单词，那么首字母大写。比如：Demo、Test。

* 如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld

不管起什么名字，都要做到见名知意。

---

## 阿里巴巴命名规范细节

1. 尽量不要用拼音。但是一些国际通用的拼音可视为英文单词。

   正确：alibaba、hangzhou、nanjing

   错误：jiage、dazhe

2. 平时在给变量名、方法名、类名起名字的时候，不要使用下划线或美元符号。

   错误：_name

   正确：name



---

# 26. 键盘录入

每次学习键盘录入的时候，都会有同学有这样的疑问：为什么要有键盘录入？其实就是为了让我们操作的数据更加的灵活。

例如定义了一个变量 `int a = 10` ，这里的变量a记录的10，是我们手动写死的，那为什么让变量a记录的值灵活起来呢？能不能让当我在键盘上输入啥，a就记录啥呢？如果要实现这个，那我们需不需要先写操作系统跟键盘之间的代码，例如：发现键盘、配对键盘、连接键盘等等一系列的步骤。其实并不需要，键盘录入的实际功能Java已经帮我们写好了，不需要我们自己再实现了，都放在了Scanner这个类中，所以，我们只要直接使用Scanner这个类如何使用就可以了。

Scanner是什么？Java已经帮我们写好一个类叫Scanner，这个类就可以接受键盘输入的数字。

---

## Scanner使用步骤

**第一步：导包。其实就是表示先找到Scanner这个类在哪。**

因为Java给我们写好的类有很多很多，我们要用它之前，就需要先找到它。

**第二步：创建对象。其实就表示申明一下，我准备开始用Scanner这个类了。**

**第三步：接收数据。也是真正干活的代码。**

代码示例：建议大家下面这三步当做固定的格式，等我们写熟了之后，再去变化里面变量的名字。

```java
//导包，其实就是先找到Scanner这个类在哪
import java.util.Scanner; // 导包的动作必须出现在类定义的上边。
public class ScannerDemo1{
	public static void main(String[] args){
		//2.创建对象，其实就是申明一下，我准备开始用Scanner这个类了。
         // 下面这个格式里面，只有sc是变量名，可以变，其他的都不允许变
		Scanner sc = new Scanner(System.in);
		//3.接收数据
		//当程序运行之后，我们在键盘输入的数据就会被变量i给接收了
		System.out.println("请输入一个整数");
         // sc.nextInt()是真正接受数据的代码，你在键盘当中输入什么，此时第12行的代码就会接收什么。接收到之后，再去把接受到的结果赋值给左边的变量，那么此时键盘里记录的就是左边键盘里输出的数据。
		int i = sc.nextInt(); // 左边这个格式里面，只有i是变量名，可以变，其他的都不允许变
		System.out.println(i);
	}
}
```

结果：

![image-20240329165043694](assets/image-20240329165043694.png)

注意：键盘录入除了输整数之外，还能接受字符串等等，但是这些知识点会在后面学习。现在我们使用的 `nextInt()`  只能接受整数，如果输小数，或者中文，代码就会报错了。



---

## 练习：键盘输入数字并求和

代码示例：

~~~java
//1.导包
import java.util.Scanner;
public class ScannerTest {
	public static void main(String[] args) {
		//2.创建对象
		Scanner sc=new Scanner(System.in);
		System.out.println("请输入第一个数字");
		//3.接收数据
		int numberl=sc.nextInt();
		System.out.println("请输入第二个数字");
		//再次接收第二个数据
		int number2 =sc.nextInt();
		System.out.println(numberl + number2);
	}
}
~~~

结果展示：

![image-20240329170439132](assets/image-20240329170439132.png)



---

# 27. IDEA的概述和下载安装

在以前，我们用的是windows自带记事本，或者高级记事本Notepad++去编写的代码。虽然说它们也能写，但是不够智能。最起码的就是，有些单词我忘了，它们不能给我提示，我觉得不够温馨，那有没有什么开发工具有这个功能呢？此时IDEA就可以做到。

## 一、IDEA概述

IDEA全称IntelliJ IDEA，是用于Java语言开发的集成环境，它是业界公认的目前用于Java程序开发最好的工具。

**集成环境：**把代码编写，编译，执行，调试等多种功能综合到一起的开发工具。

在以前我们代码编写使用的是记事本，编译和运行是在cmd窗口中用的 `javac` 和 `java`。

<img src="assets/image-20240329170519941.png" alt="image-20240329170519941" style="zoom:50%;" />

现在有了IDEA，它可以把它们全都集中在一起，所有的操作都在IDEA中进行。而且IDEA还有很多温馨的功能，例如：自动保存（省得我们自己ctrl + s保存代码了）、自动编译（当我们写完代码之后，IDEA会帮我们自动编译，我们只要直接运行，就能看见程序的结果了。因此到时候我们在IDEA中，我们只需要关注两方面：写代码 和 运行结果就行了，其他的操作IDEA都会帮我们自动完成。

![image-20240329170502611](assets/image-20240329170502611.png)

最后再来看一下IDEA的市场占有率，在这里是从2017年开始统计的，在下图中，IDEA以 `42%` 占据第一。

下面的红色 `Eclipse` 以 28% 占据第2。Eclipse也是非常厉害的，在IDEA还没出来的时候，JAVA程序员开发用的基本上都是Eclipse。

当然还有排行第三的 `Android Studio`，它是一个安卓的开发工具。

到了2018年的时候，IDEA就增长到了 `56%`，其他的开发工具市场占有率就越来越少了。到了2019年的时候，IDEA增长到了 `64%`。到了2020年的时候，IDEA增长到了 `71%`，到了2021年的时候增长到了 `74%`。

那么有的同学会发现，红色的Eclipse感觉好顽强，市场份额还有 `11%`，感觉没少太多。其实就是因为在IDEA没有出来的时候，Java程序员用的都是Eclipse。所以到目前而言，有很多古老的项目都是用Eclipse开发的。

---

## 二、IDEA的下载和安装

### 下载

可以到官方网站自行下载，网址为：https://www.jetbrains.com/idea

点击下载

![image-20240329205022930](assets/image-20240329205022930.png)

进来后，会有两个版本提供我们下载。上面蓝色的是终极版，它是收费的，但是会有30天免费试用时间。

下面灰色的是社区版，是完全免费的。

这两个版本也是有区别的，终极版几班上包含了所有的功能，而社区版的功能只有一部分。所以在下载的时候，还是建议下载上面的终极版本。

<img src="assets/image-20240329205107904.png" alt="image-20240329205107904" style="zoom: 33%;" />

在下载的时候一定要根据自己的操作系统来下载。然后点击旁边向下的剪头，可以发现有两个：一个是exe安装包，另一个是zip压缩包。上面的它只有一个安装包，下面的它会把安装包和一些其他的说明性文件打包在一起给你加载。而我们现在只需要一个安装包就可以了，所以点击上面的exe就可以下载了。

<img src="assets/image-20240329205649044.png" alt="image-20240329205649044" style="zoom:50%;" />

---

### 安装

双击安装包。

点击next，准备安装

![计算机发展](assets/idea安装1.png)

点击Browse修改安装路径。可以选择默认，也可以自己手动设置。在之前我们曾经说过，最好要把跟开发相关所有的软件都放在同一个文件夹里方便管理，所以我们在这一步要来修改一下：`E:\develop\idea`。

![计算机发展](assets/idea安装2.png)

勾选64-bit launcher。表示在桌面新建一个64位的快捷方式。其他的不要勾选。然后点击next。

![计算机发展](assets/idea安装4.png)

点击Install，准备安装。

![计算机发展](assets/idea安装5.png)

等进度条读取完毕之后，会有最终界面提示。点击finish即可。

![计算机发展](assets/idea安装6.png)

第一次启动会询问，是否导入一些设置。选择第二个不导入，保持默认设置，再点击OK。

![计算机发展](assets/idea安装7.png)

选择背景主题。左边是黑色背景。右边是白色背景。这个可以根据自己的喜好来选择。选择完毕点击右下角的next

![计算机发展](assets/idea安装8.png)

在本界面让我们购买idea。因为我们是学习阶段，所以可以使用免费使用30天。点击第一排第二个。Evaluate for free

![计算机发展](assets/idea安装9.png)

点击蓝色的Evaluate，就可以开始免费试用30天了。

![计算机发展](assets/idea安装10.png)

当看到这个界面，就表示idea已经成功安装完毕。可以点击右上角关闭。

![计算机发展](assets/idea安装11.png)



---

# 28.IDEA中的第一个代码

## 一、IDEA项目结构的介绍

第一次使用IDEA的时候还是比较麻烦的，因为IDEA有一些项目结构需要我们知道。如果我们对项目结构不清楚的话，是用不了IDEA的。

在IDEA中，项目结构一共分为以下的四个，分别为：

- project（项目、工程）
- module（模块）
- package（包）
- class（类）

![image-20240329211146109](assets/image-20240329211146109.png)

我们以微信为例，来说一下这四个结构在项目当中是如何体现的。

首先，整个微信就可以看做是一个项目，所以说项目是最大的。

<img src="assets/image-20240329212014647.png" alt="image-20240329212014647" style="zoom: 67%;" />

然后在微信的下面有四大功能键，分别是：消息、通讯录、发现、我。这四个在微信当中是互相独立的，就可以看做是四个模块。所以由此可见，一个完整的项目是包含一个或多个模块的。

<img src="assets/image-20240329212036905.png" alt="image-20240329212036905" style="zoom:67%;" />

那么我们以第一个消息为例，来讲解一下包。包其实就是文件夹，在消息模块中，我们会写很多文字、图片、动画。而这些文字、图片、动画都是要用代码去编写的，所以我们会在里面再去新建很多的包，然后会把相同功能的代码放在同一个包当中，方便管理。

例如第一个包我们就可以放跟文字相关的代码，第二个包就可以放跟图片相关的代码，第三个包就可以放所有跟动画相关的代码，最后一个包就可以放其他剩余的代码。

<img src="assets/image-20240329212052463.png" alt="image-20240329212052463" style="zoom: 67%;" />

所以大家在学习IDEA的时候一定要牢记下面的项目结构：`project - module - package - class`。这些结构的划分，是为了方便管理类文件。

最大的是项目，然后是模块，在模块里面是包（文件夹），在包里面才是编写代码的类。所以如果我们想在IDEA中去编写代码，必须要新建这四层结构。

<img src="assets/image-20240329212245411.png" alt="image-20240329212245411" style="zoom:50%;" />

---

## 二、IDEA中的第一个代码

步骤：

1、创建项目

2、创建模块

3、新建包

4、新建代码

---

### 1、创建项目

双击启动图标

![计算机发展](assets/idea使用1.png)

首先要新建一个项目，点击creat new project

<img src="assets/image-20240329212755800.png" alt="image-20240329212755800" style="zoom:50%;" />

我们要从0开始写代码，所以新建一个空的什么都没有的项目。点击左上方的Empty Project。

然后输入项目的名称 `basic-code`（基础代码），输入项目的存放路径，然后点击右下方的 `Create`。

这里注意，项目创建的位置不需要在位置后面补上项目的文件名，直接选中需要创建到的位置就行了！！！

<img src="assets/image-20240329214334039.png" alt="image-20240329214334039" style="zoom:50%;" />

---

### 2、新建模块

这里约定一下，第一阶段的代码会看成一个完整的项目，每一天的代码会把它看做是一个单独的模块。因为今天是第二天，所以我们要新建day02的模块。点击Module，准备新建一个模块，点击左上角的 `File`，然后再点击 `Project Structure`（项目重构）

![image-20240329213722482](assets/image-20240329213722482.png)

然后点击 `Modules`，这个就是模块的意思。

<img src="assets/idea5.png" alt="计算机发展" style="zoom: 67%;" />

点击+，再点击New Module。`New Module` 表示新建一个模块，`Import Module` 表示导入一个已有的模块。

![计算机发展](assets/idea6.png)

我们要编写Java代码，所以要新建一个Java模块。点击Java，输入模块的名称，`模块需要创建到的位置` 这里可以不用去动它。再点击右下角的Create。

![image-20240329214906460](assets/image-20240329214906460.png)

成功新建一个模块之后，中间就会出现刚刚新建的模块，点击右下角的OK。

![image-20240329215013856](assets/image-20240329215013856.png)

此时我们需要耐心等待一下，等右下角的进度条充满了，第二个模块就会帮我们新建完毕。因为我们新建模块它会帮我们做一些设置。

![image-20240329214932948](assets/image-20240329214932948.png)

回到主界面，在左上角查看我们新建好的模块

![image-20240329215416511](assets/image-20240329215416511.png)

---

### 3、新建包

右键点击src，选择New，选择Package，这个就是包，其实就是文件夹

![image-20240329215529712](assets/image-20240329215529712.png)

文件夹在起名字的时候不要乱写，我们习惯性会用公司域名的反写，再加包的作用。例如我们现在是在黑马学习，黑马的官方网站是 `www.itheima.com`，现在我们就可以把这个网址反过来：com.itheima，www就不要加上了。最后再加上包的作用，这里是用来做演示的，所以取名为：demo1。连起来就是：`com.itheima.demo1`，最后回车就行了。

![image-20240329215656125](assets/image-20240329215656125.png)

此时在src下面就会有这样的一个包。

![image-20240329215912161](assets/image-20240329215912161.png)

这个包是什么样的一个情况呢，我们可以右键点击这个包，然后选择 `Open In`，再选择 `Explore`，此时就相当于在本地打开了这个文件夹。

<img src="assets/image-20240329220029643.png" alt="image-20240329220029643" style="zoom:50%;" />

可以发现我们刚刚新建的这种方式，其实是一个多级包。相当于在com里面新建了一个itheima，在itheima里面又新建了一个demo1。多级包之间我们是用点分开的。

---

### 4、新建代码

代码是在包里面的，所以我们要右键点击谁，然后新建类，这个类就会建在那个文件夹下面。我们右键点击包，然后选择new，再选择 `Java Class`，表示新建一个Java类。

![image-20240329230416568](assets/image-20240329230416568.png)



![计算机发展](assets/idea11.png)

然后就可以开始编写代码了。在IDEA里写代码就非常爽了，不需要我们一个单词一个单词的写了，因为每一个单词都会有代码提示。写main方法有快捷方式，输入 `psvm`就可以快速生成main方法。sout可以快速生成输出语句。

![计算机发展](assets/idea14.png)

代码写完不需要保存，不需要编译，因为IDEA是帮我们自动保存，自动编译的。我们只需要直接运行代码，右键空白处，点击Run

或者我们也可以点击旁边的绿色小三角，但是最为保险的方式还是推荐右击空白处，然后点击Run就可以了。

<img src="assets/image-20240329231148717.png" alt="image-20240329231148717" style="zoom:50%;" />

<img src="assets/idea15.png" alt="计算机发展" style="zoom: 67%;" />

运行完后，我们稍微等一下，最下面会弹出一个窗口，这个窗口就叫做控制台。所有输出语句中的内容，都会在控制台上展示。

![计算机发展](assets/idea16.png)



---

# 29.扩展设置和项目、模块的操作

在刚刚我们已经使用IDEA编写了第一个代码：HelloWorld，但是在写完之后我发现，我用起来感觉有点不太爽，例如：字体太小了，看的有点难受。再比如说背景设置。

## 一、IDEA扩展设置

### 1、修改主题

Settings —> Appearance & Behavior —> 选择对应的Theme（主题）

![image-20240329232222781](assets/image-20240329232222781.png)

---

### 2、设置字体

由于字体比较小，所以，我们要设置一下字体。点击File，选择Setting。

<img src="assets/idea12.png" alt="计算机发展" style="zoom:50%;" />

搜索一下font，在右边可以输入Size的数值来调节代码字体 和 字体的大小。

字体一般设置为 `Consolas`，这个字体是给程序员专门设计的字体，很多程序员都比较喜欢它。Size就是设置字体的大小。`Line height` 是行间距，行间距这里默认即可。设置完毕后点击右下角的OK。

![image-20240329232524802](assets/image-20240329232524802.png)

---

### 3、开启<kbd>ctrl + 滚轮</kbd>调节字体大小

Settings —> Editor —> General —> 按图勾选 —> 点击ok

![image-20240329233124834](assets/image-20240329233124834.png)

---

### 4、设置注释颜色

默认注释是灰色的，而且是斜体，看着很难受。

Settings —> Editor —> Color Scheme —> Language Defaults —> Comments（注释） —> 取消勾选斜体，然后修改颜色

在设置颜色的时候，建议不要使用红色，因为在IDEA中，只有代码出现错误了，才是红色的。

修改颜色：先拖动上面的小圆圈，然后将下面的颜色拖到绿色的地方，这里将单行注释变成跟字符串类似的绿色。最后将小圆圈拖到我们想要的地方即可，这里就选择深绿色，选择完后回车即可。

![image-20240329234023493](assets/image-20240329234023493.png)

接下来设置多行注释的颜色，同样去掉斜体，但这次设置颜色不需要再次去拖拽了，而是直接选择历史颜色即可。

![image-20240329234214268](assets/image-20240329234214268.png)

---

### 5、实现自动导包

例如我们之前使用的Scanner，就是需要导包的。IDEA具有自动导包功能，但需要进行配置。

Settings —> Editor —> General —> Auto Import —> 勾选上图中红框框起来的两个选项即可

![image-20240329234524716](assets/image-20240329234524716.png)

设置完成之后，输入Scanner，然后回车，此时可以发现已经实现了自动导包功能！

<img src="assets/image-20240329234718297.png" alt="image-20240329234718297" style="zoom:50%;" />

---

### 7、自动提示忽略大小写

IDEA在写代码是有默认提示的，但是默认提示在默认的情况下，它是区分大小写的。

例如写string的时候，将String的s写成了小写，IDEA并不会给你提示，而是会认为你写错了。那能不能在自动提示的时候忽略大小写呢？其实是可以的。

Settings —> Editor —> General —> 取消勾选 Match case —> 点击ok

![image-20240329235001697](assets/image-20240329235001697.png)

设置完成后，再次输入string，可以发现String提示也出来了。

<img src="assets/image-20240329235153639.png" alt="image-20240329235153639" style="zoom:67%;" />

---

### 8、设置背景图片

Appearance —> Background Image

![image-20240329235333931](assets/image-20240329235333931.png)

点击右边的三个点选择图片。Opacity可以选择透明度，数值越大越清晰，数值越小越透明。然后点击ok即可。

<img src="assets/image-20240329235428550.png" alt="image-20240329235428550" style="zoom:50%;" />

---

## 二、IDEA中类的相关操作

在IDEA关于类的相关操作我们只需要学会以下三个就行了

- 新建类文件
- 删除类文件
- 修改类文件

### 1、新建类文件

所有的Java代码都会写在src文件夹当中。想要将类新建在哪个包中，就右击这个包，点击新建即可。

所以，右键点击src，选择new，点击Java Class

![计算机发展](assets/新建类1.png)

输入类名，点击下面的Class双击一下，或者直接回车

![计算机发展](assets/新建类2.png)

新建完毕

![计算机发展](assets/新建类3.png)

---

### 2、删除类文件

想要删除哪个文件，就右键点击该文件，选择Delete即可

<img src="assets/删除类文件1.png" alt="计算机发展" style="zoom:50%;" />

在弹出的界面中点击OK，确定删除

<img src="assets/删除类文件2.png" alt="计算机发展" style="zoom:67%;" />

PS：此时删除是不走回收站的，直接从硬盘中删掉了。

---

### 3、修改类名

如果要修改类名，是不能直接在代码中修改的，因为文件名跟类名需要保持一致，所以正确的修改方式应该是下面这样做。

右键点击想要修改的文件，点击Refactor，再点击Rename（改名）。或者快捷键<kbd>shift + F6</kbd>

<img src="assets/修改类名1.png" alt="计算机发展" style="zoom:67%;" />

输入想要修改的名字，输入完毕点击下面的Refactor

![计算机发展](assets/修改类名2.png)

文件名和类名均已修改成功

![计算机发展](assets/修改类名3.png)

---

## 三、IDEA中模块的相关操作

模块有以下四种操作，但针对于我们现在刚开始学习，我们只需要学会如何新建一个模块就行了。

- 新建模块
- 删除模块
- 修改模块
- 导入模块

### 新建模块

点击File，选择Project Structure

![计算机发展](assets/新建模块1.png)

选择Module

![计算机发展](assets/新建模块2.png)

点击+，选择New Module

![计算机发展](assets/新建模块3.png)

我们要编写Java代码，所以要新建一个Java模块。点击Java，输入模块的名称，`模块需要创建到的位置` 这里可以不用去动它。再点击右下角的Create。

<img src="assets/image-20240330000637721.png" alt="image-20240330000637721" style="zoom: 33%;" />

成功新建完毕之后，在中间空白区域就出现了刚刚新建的模块，点击右下角的OK

![计算机发展](assets/新建模块6.png)

在主界面中，也会出现刚刚新建的模块

![计算机发展](assets/新建模块7.png)

### 删除模块

- 右键点击模块

  选择Remove Module

![计算机发展](assets/删除模块1.png)

- 选择Remove，表示确定删除

![计算机发展](assets/删除模块2.png)

- 此时发现，在IDEA列表页面，删除的模块已经不在了。

![计算机发展](assets/删除模块3.png)

> 小贴士：
>
> 此时删除仅仅是从IDEA列表中的删除，在本地硬盘中还是存在的。

#### 8.6.4 修改模块

- 右键点击模块名

  选择Refactor

  再选择Rename

![计算机发展](assets/修改模块名1.png)

- 选择第三个修改模块名和本地文件夹名

  点击OK

![计算机发展](assets/修改模块名3.png)

- 输入要修改的新的模块名

  输入完毕点击Refactor

![计算机发展](assets/修改模块名4.png)

- 回到主界面，就发现模块名和文件夹名都已经修改完毕

![计算机发展](assets/修改模块名5.png)



#### 8.6.5 导入模块

- 点击File，选择Project Structure

![计算机发展](assets/导入模块1.png)

- 选择Module

  点击+

  选择Import Module

![计算机发展](assets/导入模块2.png)

- 从本地硬盘中选择要导入的模块

  再点击OK

![计算机发展](assets/导入模块3.png)

- 不断点击Next

![计算机发展](assets/导入模块4.png)

- 如果中间出现提示框，则点击Overwrite

  然后继续点击右下角的Next

![计算机发展](assets/导入模块5.png)

- 一直点到finish为止

![计算机发展](assets/导入模块6.png)

- 成功导入后，在中间位置就会出现导入的模块信息

![计算机发展](assets/导入模块7.png)

- 在主界面中也会出现导入的模块信息

![计算机发展](assets/导入模块8.png)



- 展开模块点击模块中的Java文件，会发现代码报错。

  是因为导入模块跟JDK没有关联导致。

![计算机发展](assets/导入模块9.png)



- 可以点击右上角的Setup SDK

  再选择已经安装的JDK版本即可

![计算机发展](assets/导入模块10.png)

- 导入完毕之后，代码就恢复正常不会报错了

![计算机发展](assets/导入模块11.png)

---

## 四、IDEA中项目的相关操作

在今天，我们只需要学会如何关闭项目和如何新建项目即可。

- 关闭项目
- 打开项目
- 修改项目
- 新建项目

### 1、关闭项目

当我们打开IDEA的时候，它会默认打开上一次你操作的项目。那如果我现在要将这个项目给关闭。

点击File，选择Close Project即可

![计算机发展](assets/关闭项目1.png)

刚刚操作的项目就已经关闭了。左侧是项目列表，如果要再次打开该项目，直接点击即可。

右侧上方有create new project，可以再建一个新的项目。右边是项目列表，点击对应的项目名称，就可以重新进入到项目。

![image-20240330001000995](assets/image-20240330001000995.png)

鼠标右击项目，点击`Remove from Recent Projects...`。如果点击了，会在IDEA的列表中删除。不会删除本地硬盘上的项目。

![image-20240330001038988](assets/image-20240330001038988.png)

---

### 2、新建项目

点击File，选择New，点击Project

![计算机发展](assets/新建项目1.png)

同样还是创建一个什么都没有的空项目，输入项目的名称，点击下面的Create即可

![image-20240330001348535](assets/image-20240330001348535.png)

询问是在本窗口打开还是在一个新的窗口打开。可以点击New Window，在一个新的窗口打开。

![计算机发展](assets/新建项目5.png)

此时就出现了两个窗口，在一个新的窗口打开了新的项目

![计算机发展](assets/新建项目6.png)

---

### 打开项目

- 在本界面还可以打开本地已经存在的项目

  点击Open or Import

![计算机发展](assets/打开项目1.png)

- 选择要打开的项目

  点击OK

![计算机发展](assets/打开项目2.png)

- 项目就被打开了。

![计算机发展](assets/打开项目3.png)

### 修改项目

- 点击File，选择Project Structure

![计算机发展](assets/修改项目1.png)

- 在这个界面，默认是Module

  所以，要先点击Project

  在右侧页面中，输入新的项目名称

  修改JDK版本和编译版本都变成JDK14

  再点击OK

![计算机发展](assets/修改项目2.png)

- 此时发现，项目名称已经修改完毕

![计算机发展](assets/修改项目3.png)

- 但是本地文件夹的名字还没有修改

![计算机发展](assets/修改项目4.png)

- 需要先关闭当前项目

![计算机发展](assets/关闭项目1.png)

- 点击项目后面的叉，从列表中移除项目

![计算机发展](assets/关闭项目3.png)

- 到本地硬盘中手动修改文件夹的名称

 ![计算机发展](F:/JavaSE%E6%9C%80%E6%96%B0%E7%89%88/day02-Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E7%AC%94%E8%AE%B0/img/%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE5.png)

- 点击Open or Import重新打开项目

![计算机发展](assets/打开项目1.png)

- 选择修改之后的项目

  点击OK

![计算机发展](assets/修改项目6.png)

- 此时会发现，项目名称和本地硬盘文件夹的名称都已经修改完毕了

![计算机发展](assets/修改项目7.png)



---------------------------------------------------

# -----------------------------------

# day03

# 30.运算符、表达式和算术运算符

## 一、运算符和表达式

**运算符**：就是对常量或者变量进行操作的符号。比如： +  -  *  / 

**表达式**：用运算符把常量或者变量连接起来的，符合Java语法的式子就是表达式。比如：a + b 这个整体就是表达式。而其中+是算术运算符的一种，所以这个表达式也称之为算术表达式。

例如下图，就是将 a + b的结果赋值给左边的变量c

<img src="assets/image-20240330112415146.png" alt="image-20240330112415146" style="zoom:50%;" />

---



## 二、算术运算符

### +、 -、 *

分类：

```java
+ - * / %
```

`%` 取模（取余）运算符，计算方法也是两个数相除，但是获取的是它们的余数

<img src="assets/image-20240330112652306.png" alt="image-20240330112652306" style="zoom:50%;" />

运算特点：

```java
+ - * :跟小学数学中一模一样没有任何区别.
```

代码示例

> 在运算符的前后一般都会加一个空格，这样阅读起来美观一些

~~~java
package com.itheima.arithmeticoperator;

public class ArithmeticoperatorDemo1 {
    public static void main(String[] args) {
        //+
        System.out.println(3 + 2);//5
        //-
        System.out.println(5 - 1);//4
        //* (小学中乘是×，但是在代码中是*，使用shift + 数字8可以敲出来)
        System.out.println(7 * 9);//63

        //如果在计算的时候有小数参与
        //结论：
        //在代码中，如果有小数参与计算，结果有可能不精确的，例如1.1 + 1.1就是精确的，但如果是1.1 + 1.01就不精确了。
        //为什么呢？
        //暂时只要知道这个结论就可以了。具体的原因，涉及到了小数在计算机里的存储模式，我们到了JavaSE进阶的时候，会再详细的讲解。
        System.out.println(1.1 + 1.1);//2.2
        System.out.println(1.1 + 1.01);//2.1100000000000003
        System.out.println(1.1 - 1.01);//0.09000000000000008
        System.out.println(1.1 * 1.01);//1.1110000000000002
    }
}
~~~

---

### /、%

代码示例

~~~java
package com.itheima.arithmeticoperator;

public class ArithmeticoperatorDemo2 {
    //主入口
    //结论：
    //1.整数参与计算，结果只能得到整数
    //2.小数参与计算，结果有可能是不精确的，如果我们需要精确计算，那么需要用到后面的知识点。
    public static void main(String[] args) {
        //除法
        System.out.println(10 / 2);//5
        System.out.println(10 / 3);//3
        // 整数操作只能得到整数，想要得到小数，必须有浮点数参与运算
        System.out.println(10.0 / 3);//3.3333333333333335

        //取模，也叫取余。实际上也是做除法运算，只不过得到的是余数而已。
        System.out.println(10 % 2);//0，商5余0
        System.out.println(10 % 3);//1，商3余1

        //应用场景：
        //1. 可以用取模来判断，A是否可以被B整除
        //A % B，例如10 % 3，就可以判断10是否可以被3整除
        
        //2. 可以判断A是否为偶数
        //A % 2 如果结果为0.那么证明A是一个偶数。如果结果为1，那么证明A是一个奇数
        
        //3. 在以后，斗地主发牌
        //三个玩家
        //把每一张牌都定义一个序号
        //拿着序号 % 3 如果结果为1，就发给第一个玩家。
        //如果结果为2，那么就发给第二个玩家
        //如果结果为0，那么就发给第三个玩家
    }
}
~~~

---

## 三、练习：数值拆分

需求：键盘录入一个三位数，将其拆分为个位、十位、百位后，打印在控制台

代码示例：

```java
package com.itheima.test;

import java.util.Scanner;

public class Test1 {
    public static void main(String[] args) {
        //键盘录入一个三位数，获取其中的个位，十位，百位

        //1.键盘录入
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个三位数");
        int number = sc.nextInt();

        //2.获取个位，十位，百位
        //公式：
        //个位：  数字 % 10
        //十位：  数字 / 10 % 10
        //百位：  数字 / 10 / 10 % 10
        //...
        int ge = number % 10;
        int shi = number / 10 % 10;
        int bai = number / 100 % 10;
        System.out.println(ge);
        System.out.println(shi);
        System.out.println(bai);
    }
}
```



---

# 31.隐式转换 和 强制转换

## 一、引入

关于算术运算符的基本用法我们已经学习完了，现在来学习关于运算符的高级用法。

下面以加法为例，它一共会有三种情况：数字相加、字符串相加、字符相加。

**案例一**：下面 `int类型` 的 `a` 和 `double类型` 的 `b` 相加结果赋值给变量`c`，`变量c`是什么类型？

以前我们在计算的时候都是同一种数据类型进行计算的，而在现在的代码中，相加的数据类型不一样了。

你现在肯定是这么想的：`10 + 12.3 = 22.3`，而22.3是一个小数，小数默认类型是double，所以你会猜c的类型一定是double。这个答案是正确的。

~~~java
public class Test {
    public static void main(String[] args) {
        int a = 10;
        double b = 12.3;
        c = a + b;
    }
}
~~~

**案例二**：下面` int类型` 的 `a` 和 `double类型` 的 `b` 相加，此时相加的结果的类型应该为int还是double呢？

~~~java
public class Test {
    public static void main(String[] args) {
        int a = 10;
        double b = 20.0;
        c = a + b;
    }
}
~~~

![image-20240330135238692](assets/image-20240330135238692.png)



**在相加的过程中，首先我们要知道一个规则：数字进行运算的时候，数据类型不一样不能直接参与运算，需要转成一样的，才能运算。**

转换方式一：隐式转换 —— 将取值范围小的，变成取值范围大的

转换方式二：强制转换 —— 将取值范围大的，转换为取值范围小的

![image-20240330135304870](assets/image-20240330135304870.png)

---

## 二、隐式转换

隐式转换也叫 `自动类型提升`。就是把一个取值范围小的数据或者变量，赋值给另一个取值范围大的变量。此时不需要我们额外写代码单独实现，是程序自动帮我们完成的。

最重要的是，隐式转换是不需要我们单独写代码的，是程序自动帮我们完成的。

比如说：在以前，下面代码 `double b = a;` 写的肯定是有问题的，因为类型不一样，是不能赋值的。但是我们现在学习了隐式转换，此时第二行代码就可以解释的通了。

~~~java
int a = 10;
double b = a;
~~~

先来看看取值范围：在这个取值范围中，最小的是byte，最大的是double。所以变量a赋值给变量b的时候，就是取值范围小的，赋值给取值范围大的。此时变量a记录的10，会自动提升为10.0，注意：是变量里面记录的值会提升为10.0，这个提升是不需要我们自己额外写代码实现的，是程序自动帮我们完成的。此时变量b记录的值就是10.0，小的自动的变成了大的。那它的底层原理是什么呢？这个在第二阶段会讲解，但是因为我们现在是刚开始入门，我们暂时只需要知道这个结果就可以了。

![image-20240330135811768](assets/image-20240330135811768.png)

正是因为有了隐式转换，不同的数据类型才能够在一起进行计算。不同的数据类型在计算的时候会有两种提升规则。

- 取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算
- byte、short、char这三种类型的数据在运算的时候，都会直接先提升为int，然后再进行运算

**例一**：在下面代码当中，a是int类型（整数），b是double类型（小数）。由于这两种类型的不一样，就不能直接运算，需要转成一样的才能运算。根据取值范围的大小关系：`double > int`，所以是变量a里面的数据会自动变成double里面的，然后再进行运算。所以 `a + b` 在进行运算的时候实际上是两个double在进行运算，所以的最后结果c，也就是double类型的。

~~~java
public class Test {
    public static void main(String[] args) {
        int a = 10;
        double b = 20.0;
        c = a + b; // 结果是？
    }
}
~~~

**例二**：a 和 b都是byte类型的，问 `a + b` 得到的结果c，是什么类型的？

根据第二个提升规则，byte类型的数据在运算的时候，都会先提升为int类型，然后再进行运算。

下面代码中，等号两边在相加的时候都会先自动提升为int类型，在提升之后，实际上就是两个int相加，因此，最终的c都是int类型的了。

~~~java
public class Test {
    public static void main(String[] args) {
        byte a = 10;
        byte b = 20;
        c = a + b; // 结果是？
    }
}
~~~

---

### 总结

- 取值范围：byte < short < int < long < float < double

- 什么时候进行转换？

  数据类型不一样，不能进行计算，需要转成一样的才可以进行计算。

- 转换规则1：

  取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算

- 转换规则2：

  byte、short、char这三种类型的数据在参与计算的时候，都会直接先提升为int，然后再进行运算



---

## 三、隐式转换练习：请问最终的运算结果是什么类型的？

**例一**：加法运算时从左到右依次计算。所以它是先计算 `i + n`，i + n是int 加上long，两个类型不一样，很明显要转换，由于long 大于 int，所以i里面的值会自动提神为long类型。前面两个数在参与计算的时候就相当是两个long进行计算。

然后就是一个long类型加上一个double类型，两个类型又不一样，所以还要再转换，由于double 大于 long，所以long类型的数据会自动提升为double类型，所以最终结果就是double类型。

~~~java
int i = 10;
long n = 100L;
double d = 20.0;
数据类型 result = i + n + d;
~~~

**例二**：首先是 `b + s`，由于b是byte类型的，s是short类型的，根据刚刚讲的第二个规则，byte、short在参与计算的时候，统一先提升为int，然后再参与运算，所以 `b + s` 就相当于是两个int相加，最终的结果是int。

然后int 再去和 long类型的 n 相加，int最终提升为long。所以最终的result为long类型。

~~~java
byte b = 10;
short s = 20;
long n = 100L;
数据类型 result = b + s + n;
~~~

---

## 四、强制转换

在代码当中，如果要把一个取值范围大的数值，赋值给取值范围小的变量。是不允许直接赋值的。如果一定要这么做就需要加入强制转换。强制转换是需要我们自己手动编写代码的，它的格式是：`目标数据类型 变量名 = （目标数据类型）被强转的数据` ，简单理解就是，你想要转成什么类型，就在小括号中写什么类型就行了。

例如：将下面变量a里的数据直接赋值给变量b，肯定是不行的，因为等号后面变量a，取值范围是比较大的，而现在是把一个大的，给小的，是不能直接给的。但如果你一定要这么办，就需要先将a转为int类型。

~~~java
double a = 12.3;
int b = (int)a;
~~~

PS：强制转换有可能导致数据发生错误。（数据的精度丢失）

例如：int 类型的 a中存放的数据比较大，超出了byte的范围，此时数据就会发生错误。

~~~java
int a = 300;
byte b = (byte) a;
~~~

---

## 五、强制转换练习

如果将等号左边的result的int类型改为byte类型，那等号右边应该如何变？

~~~java
byte b1 = 10;
byte b2 = 20;
// int result = b1 + b2;
byte result = b1 + b2;
~~~

代码示例

~~~java
package com.itheima.arithmeticoperator;

public class ArithmeticoperatorDemo3 {
    public static void main(String[] args) {
        byte b1 = 10;
        byte b2 = 20;
        //现在我们要强转的是谁？
        //b1 + b2计算之后的结果。
        // (byte)b1 + b2 强转的是b1，并不是最终的结果
        byte result = (byte)(b1 + b2);
        System.out.println(result);//30
    }
}
~~~

但如果转换的数据过大，就会发生错误

~~~java
package com.itheima.arithmeticoperator;

public class ArithmeticoperatorDemo3 {
    public static void main(String[] args) {
        byte b1 = 100;
        byte b2 = 200;
        byte result = (byte)(b1 + b2);
        System.out.println(result);//-56，结果就发生错误了。因为要转换的数据过大
    }
}
~~~



---



# 32.字符串 和 字符的 + 操作

技巧：有字符串，那就是字符串拼接，没有字符串，那就是普通的运算符

* 当+操作中出现字符串时，此时就是字符串的连接符，会将前后的数据进行**拼接**，并产生一个新的字符串。

  例如：`"123" + 123`，结果为 `"123123"`，而不是246。

* 当连续进行+操作时，从左到右逐个执行的。

  例如：`1 + 2 + "abc"`，结果："3abc"

  解释：

  ​	第一步：1 + 2 。在这个过程中，没有字符串参与的，所以做的是加法运算，结果为3。

  ​	第二步：3 + "abc"。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串"3abc"。

---

## 二、字符串相加的练习

字符串只有 + 操作，是没有 -、*、/运算的

这里特别注意的是，变量在进行拼接的时候，会把变量里的值拿出来进行拼接！！！

![image-20240330154715627](assets/image-20240330154715627.png)

```java
1 + 2 + "abc" + 2 + 1
```

结果：“3abc21”

解释：

​	第一步：1 + 2 。在这个过程中，没有字符串参与的，所以做的是加法运算，结果为3。

​	第二步：3 + "abc"。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串"3abc"。

​	第三步："3abc" + 2。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串"3abc2"。

​	第四步："3abc2" + 1。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串“3abc21”

---

## 三、练习：数值拆分

需求：键盘录入一个三位数，将其拆分为个位、十位、百位后，打印在控制台

我们以前在进行计算的时候是通过一系列公式将个位、十位、百位都获取出来，并打印在控制台当中，打印出来的结果就是

![image-20240330155411554](assets/image-20240330155411554.png)

但是这种打印结果看起来非常累，如果我不看题目，我怎么知道这个3是什么，2是什么，1是什么？那能不能在打印的时候前面有一些说明性的提示呢？

~~~java
package com.itheima.test;

import java.util.Scanner;

public class Test1 {
    public static void main(String[] args) {
        //键盘录入一个三位数，获取其中的个位，十位，百位

        //1.键盘录入
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个三位数");
        int number = sc.nextInt();

        //2.获取个位，十位，百位
        //公式：
        //个位：  数字 % 10
        //十位：  数字 / 10 % 10
        //百位：  数字 / 10 / 10 % 10
        //...
        int ge = number % 10;
        int shi = number / 10 % 10;
        int bai = number / 100 % 10;
        System.out.println("个位是：" + ge);
        System.out.println("十位是：" + shi);
        System.out.println("百位是：" + bai);
    }
}
~~~

结果：

<img src="assets/image-20240330155300495.png" alt="image-20240330155300495" style="zoom:50%;" />

---

## 四、字符的+操作

在学习隐式转换的时候，曾经有过这样的提升规则：byte、short、char三种数据在参与运算的时候，都会先提升为int，然后再进行运算。但此时就有一个问题了，byte、short都是一个数字，容易提升，但是char是一个字符，怎么进行提升呢？我们先不着急，先来看一段代码：

~~~java
char c = 'a'; // 首先定义一个字符类型的变量
int result = c + 0; // 用字符c跟数字0进行了相加
System.out.println(result);// 打印结果为：97
~~~

打印结果为什么为97呢，这就要说到字符在进行计算的时候会有以下规则：

**当+操作（作为运算符的时候）中出现了字符，会拿着字符到计算机内置的ASCII码表中去查对应的数字，然后再进行计算。**

ASCII码表（American Standard Code for Information Interchange）美国信息交换标准码表。下面红色框框起来的部分，这张表中，每一个数字都会跟一个唯一的数字产生一个一一对应的关系。这张表是操作系统类似的，每个人的系统中都是存在的，不需要你额外下载。

![image-20240330160306905](assets/image-20240330160306905.png)

ASCII码表中：'a'   -----    97、'A'   -----    65

示例：![image-20240330160340677](assets/image-20240330160340677.png)



---

## 五、算术运算符的总结

分类：

```java
+ - * / %  这些操作跟小学数学几乎是一模一样的。
```

注意点：

* / 和 % 的区别：他们两个都是做除法运算，/取结果的商。% 取结果的余数。
* 整数操作只能得到整数，如果想要得到小数，必须有浮点数参与运算。

算术运算符的高级用法：

是以+为例进行的讲解，其余减法，乘法，除法的运算规则也是一样的。

特例：字符串只有+操作，没有其他操作。

---

# 33.自增自减运算符

## 一、分类

```java
++  自增运算符
--  自减运算符
```

++：就是把变量里面的值+1

--：就是把变量里面的值-1

---

## 二、使用方式

* 放在变量的前面，我们叫做先++。 比如：++a
* 放在变量的后面，我们叫做后++。 比如：a++

**注意点**：不管是先++，还是后++。单独写在一行的时候，运算结果是一模一样的。

---

## 三、代码示例

```java
package com.itheima.arithmeticoperator;

public class ArithmeticoperatorDemo5 {
    public static void main(String[] args) {
        //++ 和 --
        int a = 10;
        //表示把变量a里面的值+1
        a++;
        System.out.println(a);//11
        //表示把变量a里面的值+1
        ++a;
        System.out.println(a);//12
        //表示把变量a里面的值-1
        a--;
        System.out.println(a);//11
        //表示把变量a里面的值-1
        --a;
        System.out.println(a);//10
    }
}
```

---

## 四、自增自减运算符的应用场景

某些情况下，变量需要进行加1或者减1的时候使用。

比如：过生日多一岁，就用到了自增运算符。

<img src="assets/image-20240330161046450.png" alt="image-20240330161046450" style="zoom:50%;" />

比如：购物商场中，选择商品数量，也用到了自增或者自减运算符。

<img src="assets/image-20240330161056063.png" alt="image-20240330161056063" style="zoom:50%;" />

比如：统计很多数据中，有多少个数据满足要求，也用到了自增运算符。

---

## 五、参与计算

之前我们学到过，`++`、`--` 无论是放在变量的前面还是后边，单独写一行结果是一样。但是如果自增自减运算符参与了计算，先++和后++就不一样了。

后++的口诀 — 先加后用：先把变量a里面的值进行自增变成11，自增完了，再赋值给变量b。此时b的结果为10。

先++的口诀 -— 先用后加：先将a里面的变量拿出来用，用完了再进行自增。此时b的结果为11。

<img src="assets/image-20240330161307552.png" alt="image-20240330161307552" style="zoom:50%;" />

---

## 六、练习

x、y、z的值分别为？

~~~java
int x = 10;
int y = x++;
int z = ++x;
System.out.println("x:" + x);
System.out.println("y:" + y);
System.out.println("z:" + z);
~~~



~~~java
package com.itheima.arithmeticoperator;

public class ArithmeticoperatorDemo6 {
    public static void main(String[] args) {
        int x = 10;
        //后++：先用后加
        //先把x变量中的值拿出来用，赋值给y，然后再进行自增。
        //赋值给y的值是自增前的。
        int y = x++;// 这一行执行后：x = 11  y = 10
        //先++：先加后用
        //先把x进行自增，然后把自增后的结果赋值给左边的变量
        //先把x自增，变成12，然后再把自增之后的12赋值给z
        int z = ++x;// 这一行执行后：x = 12 z = 12
        System.out.println("x:" + x);//12
        System.out.println("y:" + y);//10
        System.out.println("z:" + z);//12
    }
}
~~~



---

# 34.赋值运算符 和 关系运算符

## 赋值运算符

最为常用的：	=

扩展赋值运算符：+=、-=、*=、/=、%=，注意两个符号之间是没有间隔的，是挨在一块的。

运算过程：就是把等号右边的结果赋值给左边的变量

---

### 二、扩展赋值运算符

**分类**：+=、-=、*=、/=、%=

**运算规则**：就是把左边跟右边进行运算，把最终的结果赋值给左边，对右边没有任何影响。

**注意点**：扩展的赋值运算符中隐层还包含了一个强制转换。

**案例**：以 `+=` 为例

```java
package com.itheima.assigningoperator;

public class AssigningoperatorDemo1 {
    public static void main(String[] args) {
        //+=
        //规则：将左边和右边进行相加，然后再把结果赋值给左边
        int a = 10;
        int b = 20;
        //把a+b，再把结果赋值给左边的变量a
        a += b;
        //等同于 a = (int)(a + b);
        System.out.println(a);//30
        System.out.println(b);//20


        //细节：
        //+=，-=，*=，/=，%= 底层都隐藏了一个强制类型转换，强转的类型是 左边变量的类型 所决定的
        short s = 1;
        //把左边和右边进行相加，得到结果2，再赋值给左边的变量
        s += 1;
        //等同于：s = s + 1;但是short类型在参与计算的时候，会先提升为int类型参与计算， s + 1 最终的结果应该是int类型的。但是如果不进行强制转换，那就是：将一个int类型的数赋值给short类型的数，就会报错了！
        // 但是为什么这里没有报错呢？这是因为 +=，-=，*=，/=，%= 底层都隐藏了一个强制类型转换，所以它并不是等同于 s = s + 1，而是： s = (short) (s + 1); 强转的类型是 左边变量的类型 所决定的
        System.out.println(s);//2
    }
}

```

---

## 关系运算符

关系运算符又叫比较运算符，其实就是拿着左边跟右边进行了判断而已。

**分类**：

| 符号 | 解释                                                         |
| ---- | ------------------------------------------------------------ |
| ==   | 就是判断左边跟右边是否相等，如果成立就是true，如果不成立就是false |
| !=   | 就是判断左边跟右边是否不相等，如果成立就是true，如果不成立就是false |
| >    | 就是判断左边是否大于右边，如果成立就是true，如果不成立就是false |
| >=   | 就是判断左边是否大于等于右边，如果成立就是true，如果不成立就是false |
| <    | 就是判断左边是否小于右边，如果成立就是true，如果不成立就是false |
| <=   | 就是判断左边是否小于等于右边，如果成立就是true，如果不成立就是false |

**注意点**：

* 关系运算符最终的结果一定是布尔类型的。要么是true，要么是false
* 在写 == 的时候，千万不要写成=
* 两个符号之间是没有空格的，例如 `==`、`!=`

**代码示例**

~~~java
package com.itheima.compareoperator;

public class CompareoperatorDemo1 {
    public static void main(String[] args) {
        //1.== 判断左右两边是否相等
        int a = 10;
        int b = 10;
        int c = 20;
        System.out.println(a == b);//true
        System.out.println(a == c);//false

        //!= 判断左右两边是否不相等
    }
}
~~~

---

## 练习：约会

这个练习是美国斯坦福大学Java的一个入门练习。

需求：
        您和您的约会对象在餐厅里面正在约会。
        键盘录入两个整数，表示你和你约会对象衣服的时髦度。（手动录入0~10之间的整数，不能录其他）
        如果你的时髦程度大于你对象的时髦程度，相亲就成功，输出true。
        否则输出false。

~~~java
package com.itheima.test;

import java.util.Scanner;

public class Test2 {
    public static void main(String[] args) {
        //1.键盘录入两个整数表示衣服的时髦度
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入我们自己的衣服时髦度");
        int myFashion = sc.nextInt();
        System.out.println("请输入相亲对象衣服的时髦度");
        int girlFashion = sc.nextInt();

        //2.把我衣服的时髦度跟女孩的时髦度进行对比就可以了
        boolean result = myFashion > girlFashion;

        //3.打印结果
        System.out.println(result);
    }
}
~~~



---

# 35.逻辑运算符

## 一、什么是逻辑运算符？

- 在数学中，一个x，大于5，小于15，我们可以这样来进行表示： `5 < x < 15`。

- 在Java中，需要把上面的式子先进行拆解，再进行合并表达。

  拆解为：x>5 和 x<15这两个式子，然后再使用逻辑运算符将它们两个合在一起：x>5 & x<15，表示x同时要满足x>5 和 x<15两个条件。

逻辑运算符一共有四个分类：

![image-20240330164206070](assets/image-20240330164206070.png)

---

## 二、& 和 | 的使用：

&：逻辑与（个人习惯读作：且，因为它就表示并且、而且）

​	两边都为真，结果才是真，只要有一个为假，那么结果就是假。

|：逻辑或（或者）

​	两边都为假，结果才是假，只要有一个为真，那么结果就是真。

代码示例：

```java
package com.itheima.logicoperator;

public class LogicoperatorDemo1 {
    public static void main(String[] args) {
        //1.& 并且
        //两边都为真，结果才是真
        System.out.println(true & true);//true
        System.out.println(false & false);//false
        System.out.println(true & false);//false
        System.out.println(false & true);//false


        //2. | 或者
        //两边都为假，结果才是假，只要有一个为真，结果就为真
        System.out.println(true | true);//true
        System.out.println(false | false);//false
        System.out.println(true | false);//true
        System.out.println(false | true);//true
    }
}
```

---

### 三：使用场景

根据固定的场景，来选择使用&还是使用|

**场景一：用户登录。**

用户名输入正确  & 密码输入正确

因为只有用户名和密码同时都正确了，那么才能成功登录，只要有一个失败了都不行。

使用技巧：当我们需要同时满足左边和右边两种情况时，可以使用且

<img src="assets/image-20240330164621176.png" alt="image-20240330164621176" style="zoom:50%;" />



**场景二：丈母娘选女婿**

丈母娘：女婿啊，你要么买个房子，要么买辆车。就可以把我的小棉袄穿走了。

买个房子 | 买辆车

两个条件中，只要满足其中一个，就可以穿走小棉袄了。

使用技巧：

​	当两种条件只要满足其中一个的时候，可以使用或

---

## 三、^（异或）的使用

在以后用的不多，了解一下即可。

计算规则：如果两边相同，结果为false，如果两边不同，结果为true

这里有一个小故事：有一个机构叫民政局，是用来结婚登记的，两男和两女，同性是不能登记的。但是一男一女，就可以登记，所以不同为true，相同为false。

代码示例：

```java
package com.itheima.logicoperator;

public class LogicoperatorDemo2 {
    public static void main(String[] args) {
        // ^ 逻辑异或
        //相同为false，不同为true
        //了解一下即可
        System.out.println(true ^ true);//false
        System.out.println(false ^ false);//false
        System.out.println(true ^ false);//true
        System.out.println(false ^ true);//true
    }
}
```

**!（取反）的使用**：是取反，也叫做非。

计算规则：false取反就是true，true取反就是false

温馨提示：**取反最多只用一个。**

代码示例：

```java
//! 逻辑非 取反
//提示：
//取反的感叹号不要写多次，要么不写，要么只写一次
System.out.println(!false);//true
System.out.println(!true);//false
```



---

# 36.短路逻辑运算符

## 一、为什么有短路逻辑运算符

上一节讲了四种逻辑运算符，但是使用逻辑运算符编写代码的时候是可以进一步优化，提高代码的效率的。此时就需要用到短路逻辑运算符。

**例一**：用户登录，当用户输入用户名和密码，点击登录之后，程序就去判断用户名和密码是否正确。那么在判断的时候需要判断两次，首先判断用户名是否正确，然后还要判断密码是否正确。但是如果判断用户名的时候，用户名就已经出错了，此时就不需要再判断密码了，因为此时不管密码是真还是假，整个表达式的结果都是false，用户都会登录失败。

此时如果我们在中间只用一个 &，也就是我们之前学到的逻辑运算符，不管用户名是真还是假，都需要判断密码。因此为了提高程序运行的效率，我们就需要来学习短路逻辑运算符了。

短路逻辑运算符分为两种：&&（而且）、||（或者）。我们要使用的是&&。

此时用户名如果正确，它就会去判断密码；但是如果用户名错误的话，就不会再去判断密码了，直接得到整个表达式的结果为false，表示用户登录失败，这样就能提升程序的运行效率。

<img src="assets/image-20240330165522066.png" alt="image-20240330165522066" style="zoom:50%;" />



**例二**：丈母娘选女婿，有房 |  有车，首先先看看有没有房，发现有，然后再去看看有没有车。

这样写代码是没有问题的，但是效率比较低，因为丈母娘看完房子之后，就会有两种情况：有房和没房。

如果没有房子，就必须去看看车子；但是如果房子已经有了，就没必要去看车子了。此时就可以用到短路逻辑运算符中的 ||，如果左边为true，就不会执行右边；如果左边会false，才会去执行右边。

<img src="assets/image-20240330170052397.png" alt="image-20240330170052397" style="zoom:50%;" />

---

## 二、分类

分类：  &&   ||

**&&**：运算结果跟`&`是一模一样的，只不过具有短路效果，并且效率会比较高。左边为false，右边不管是真是假，整个表达式的结果一定是false。

**||**：运算结果跟`|`是一模一样的。只不过具有短路效果，并且效率会比较高。左边为true，右边不管是真是假，整个表达式的结果一定是true。

**逻辑核心**：当左边不能确定整个表达式的结果，右边才会执行。当左边能确定整个表达式的结果，那么右边就不会执行了。从而提高了代码的运行效率。

& | ：无论左边 true false，右边都要执行。

&& ||：如果左边能确定整个表达式的结果，右边不执行。

**建议**：最为常用的逻辑运算符： &&   ||   ！

![image-20240330170601675](assets/image-20240330170601675.png)

---

## 三、代码示例

~~~java
package com.itheima.logicoperator;

public class LogicoperatorDemo3 {
    public static void main(String[] args) {
        //1.&&
        //运行结果跟单个&是一样的
        //表示两边都为真，结果才是真
        System.out.println(true && true);//true
        System.out.println(false && false);//false
        System.out.println(false && true);//false
        System.out.println(true && false);//false


        //2.||
        //运行结果跟单个|是一样的
        //表示两边都为假，结果才是假。只要有一个为真，结果就为真
        System.out.println(true || true);//true
        System.out.println(false || false);//false
        System.out.println(false || true);//true
        System.out.println(true || false);//true


        //3.短路逻辑运算符具有短路效果
        //简单理解：当左边的表达式能确定最终的结果，那么右边就不会参与运行了
        int a = 10;
        int b = 10;
        boolean result1 = ++a < 5 & ++b < 5;
        System.out.println(result);//false
        System.out.println(a);//11
        System.out.println(b);//10，因为左边已经是false了，变量b自增并不会执行了
        
        boolean result2 = ++a < 5 & ++b < 5;
        System.out.println(result);//false
        System.out.println(a);//11
        System.out.println(b);//11，如果是单个的，左边不管真假，右边都会执行
    }
}
~~~

---

## 四、练习：数字6

这个练习也是美国斯坦福大学，java入门的一个练习。

数字6是一个真正伟大的数字，键盘录入两个整数。如果其中一个为 6，最终结果输出true。如果它们的和为 6的倍数。最终结果输出true。其他情况都是false。

代码示例：为true的情况有三种情况

~~~java
package com.itheima.test;

import java.util.Scanner;

public class Test3 {
    public static void main(String[] args) {
        //分析：
        //1.键盘录入两个整数
        // 变量a   变量b

        //2.a == 6 || b == 6 || (a + b) % 6 == 0
        //如果满足其中一个，那么就可以输出true

        //键盘录入两个整数
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个整数");
        int number1 = sc.nextInt();
        System.out.println("请输入第二个整数");
        int number2 = sc.nextInt();

        //可以短路逻辑运算符去连接三个判断
        boolean result = number1 == 6 || number2 == 6 || (number1 + number2) % 6 == 0;

        System.out.println(result);
    }
}
~~~



---

# 37.三元运算符

## 一、引入

又叫做：三元表达式或者问号冒号表达式。作用：可以进行判断，根据判断的结果得到不同的内容。

**格式**：`关系表达式 ？ 表达式1 ：表达式2 ；`

其中的 关系表达式 就是一个判断

**计算规则**：

* 计算关系表达式的值。
* 如果关系表达式的值为真，那么执行表达式1。
* 如果关系表达式的值为假，那么执行表达式2。

**注意点**：三元运算符的最终结果一定要被使用，要么赋值给一个变量，要么直接打印出来，如果单独在代码中写一个三元表达式，是会报错的。

---

## 二、代码示例

需求：使用三元运算符，获取两个数的较大值

```java
package com.itheima.ternaryoperator;

public class TernaryoperatorDemo1 {
    public static void main(String[] args) {
        //分析：
        //1.定义两个变量记录两个整数
        int number1 = 10;
        int number2 = 20;

        //2.使用三元运算符获取两个整数的较大值
        //格式：  关系表达式 ? 表达式1 : 表达式2;
        //整个三元运算符的结果必须要被使用
        int max = number1 > number2 ? number1 : number2; // 赋值给一个变量
        System.out.println(max);

        System.out.println(number1 > number2 ? number1 : number2); // 直接打印出来，此时在式子的最后就不需要加分号了
    }
}

```

---

## 三、练习1-两只老虎

需求：

​	动物园里有两只老虎，两只老虎的体重分别为通过键盘录入获得，

​	请用程序实现判断两只老虎的体重是否相同。

代码示例：

```java
package com.itheima.test;

import java.util.Scanner;

public class Test4 {
    public static void main(String[] args) {
        //分析：
        //1.键盘录入两只老虎的体重
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入第一只老虎的体重");
        int weight1 = sc.nextInt();
        System.out.println("请输入第二只老虎的体重");
        int weight2 = sc.nextInt();
        //2.比较
        //System.out.println(weight1 == weight2); 这种写法打印出来的要么是true，要么是false。但是现在我们想打印出相同 / 不同

        String result = weight1 == weight2 ? "相同" : "不同";
        System.out.println(result);
    }
}

```

---

## 四、练习2-求三个数的最大值

需求：

​	一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm。

​	请用程序实现获取这三个和尚的最高身高。

代码示例：

```java
package com.itheima.test;

public class Test5 {
    public static void main(String[] args) {
        //1.定义三个变量记录三个和尚的身高
        int height1 = 150;
        int height2 = 210;
        int height3 = 165;
        //2.拿着第一个和尚和第二个和尚进行比较
        //再拿着结果跟第三个和尚进行比较即可
        int temp = height1 > height2 ? height1 : height2;
        int max = temp > height3 ? temp : height3;
        //快捷键：ctrl + alt + L 自动的格式化代码
        System.out.println(max);
    }
}
```



---

## 五、运算符的优先级

在Java中涉及了很多的运算符，每一种运算符都有各自的优先级。但是这些优先级不需要记忆。

咱们只要知道其中一点：小括号优先于所有。

![image-20240330173054838](assets/image-20240330173054838.png)

---

# 38.原码反码补码

## 一、概念

原码：十进制数据的二进制表示形式，最左边是符号位，0为正，1为负。

反码：正数的补码反码是其本身，负数的反码是符号位保持不变，其余位取反。

补码：整数的补码是其本身，负数的补码是在其反码的基础上加1。

----

## 二、原码

原码：十进制数据的二进制表示形式，最左边是符号位，0为正，1为负。

例如：56，下图转为二进制就是它的原码

![image-20240330174321153](assets/image-20240330174321153.png)

其中左边的第一位是它的符号位，0为正，1为负，后面才是具体的数值，称为数值位。

![image-20240330174250270](assets/image-20240330174250270.png)

在计算机中，一个0或者一个1，我们称之为一个bit，中文名字叫比特位。比特币和比特位它们两个之间没有任何关系，就是名字比较像而已。

但是一个bit能表示的数据太少了，所以我们会把8个bit分为一组，叫为一个字节，而一个字节是我们计算机中最小的存储单元。

那么一个字节最大值能取到多少？第一个符号位一定是0，后面的7位肯定是1。因为二进制最多只能到1，不能到2，因为到2就会逢二进一。所以一个字节的最大值是0后面跟着7个1。把它转为十进制，那就是正的127

![image-20240330174711815](assets/image-20240330174711815.png)

那么一个字节最小值能取到多少？第一个符号位肯定是1，表示负数，后面的数字是不能为0的，如果为0，这个就是-0了，-0也是0。我们应该将后面的值都变成1才行。后面的7个1转为十进制，就是127，组合在一起就是-127。

![image-20240330174939275](assets/image-20240330174939275.png)

在原码当中，如果是正数计算，结果不会有任何的问题。例如在0的基础上加1，直接将右边的0变成1就行了。

![image-20240330175233480](assets/image-20240330175233480.png)

---

### 原码的弊端

左边的第一位为1，表示负数，后面7个都是0，转成十进制后，就是-0，-0其实也是0。现在我在它的基础上加个1。

现在，我要在这个基础上加1，正常来说是1，但是下面这个二进制转成十进制后，结果是-1 。

<img src="assets/image-20240330175544781.png" alt="image-20240330175544781" style="zoom:50%;" />

现在以-1为基础，再加1。正确应该为0，但是通过这个二进制转换后的结果，实际确实-2。

<img src="assets/image-20240330175657821.png" alt="image-20240330175657821" style="zoom:50%;" />

现在我在-2的基础上继续加1，正确来讲结果应该为-1，但是现在通过这个二进制转换后的十进制，实际为-3。

<img src="assets/image-20240330175741107.png" alt="image-20240330175741107" style="zoom:50%;" />

为什么会这样呢？我们讲数字归零，要说明这个，只需要结合数轴去理解。现在数据是0。

![image-20240330175925426](assets/image-20240330175925426.png)

现在是0要加1，我的想法是，应该向数轴的正方向去走一步。但是在这个前面，它有一个1，1表示符号。

![image-20240330180126001](assets/image-20240330180126001.png)

所以实际情况，它是反过来，往负的方向走了一步。

![image-20240330180258041](assets/image-20240330180258041.png)

总结：如果是负数计算，结果就会出错，实际运算的结果，跟我们预期的结果是相反的。所以在当时，有人就想了，如果将数轴反过来不就可以了吗？所以说就出现了反码。

![image-20240331215255407](assets/image-20240331215255407.png)

----

## 三、反码

反码：是为了解决原码不能计算负数的问题而出现的。

计算规则：正数的反码不变。负数的反码在原码的基础上，符号位不变，数值取反，0变1，1变0.

正数反码不变的原因是，在原码的计算中，正数的计算本身是没有问题的，既然都没有问题了，那还改它干嘛？只有负数的计算是跟原来的方向是反过来的，所以只需要将负数进行取反就可以了。

例如：我们以 `-56` 为例。首先要计算56的原码。

![image-20240331215708588](assets/image-20240331215708588.png)

56的原码是后面这段

![image-20240331215824855](assets/image-20240331215824855.png)

那现在是负数怎么办，那就将前面的符号位变成1就行了，组合在一起，那这个就是-56的原码。

那-56的反码是多少？负数的反码是符号位不变，数值位取反。0变1，1变0。

![image-20240331220046035](assets/image-20240331220046035.png)

那么反码可以解决负数相加的问题吗？我们来看一个例子，现在用 `-56 + 1`，正确来讲，它应该等于 `-55`，那我就想了，用反码计算，能得到 `-55` 吗？不知道的话就直接来计算一下：从最右边开始算，`-56` 的反码加1后，就需要往前进一。

![image-20240401191700149](assets/image-20240401191700149.png)

一共进位三次，最终就会变成下面这个数字。

![image-20240401191826433](assets/image-20240401191826433.png)

通过查询计算器，可知55的原码为：

![image-20240401192030345](assets/image-20240401192030345.png)

那如果现在想要得到 `-55` ，符号位取反即可

![image-20240401192111259](assets/image-20240401192111259.png)

`-55` 的反码为：符号位不变，后面的数值按位取反，0变1，1变0。一旦变化之后，可以发现之前 `-56 + 1` 得到的反码和 `-55` 的反码 一模一样，因此利用反码，就可以完美解决负数计算的问题了。

![image-20240401192219681](assets/image-20240401192219681.png)

---

### 反码弊端

但这并没有结束，下面是 `-1 到 -7 的反码`，以-4为例，如果用原码去计算都是不正确的，所以就出现了右边的反码。

反码计算负数都是没有问题的，但是一直加到0的时候，0这时再 + 1，反码就会一直进位，超出范围就不管了，因为我们现在计算的是一个字节，所以最终得到的结果是 8 个 0 。

![image-20240401192902324](assets/image-20240401192902324.png)

其中8个0当中，左边的第一位是0，这时候它是正数，原码不变，还是8个0，所对应的十进制还是0。

因此，利用反码来计算，最终的结果跨0了，就会有1个误差。这是因为在反码中，0有两种表现形式，有一个是8个0的，还有一个是8个1的，跨0的时候在0这个地方蹦了两次。

![image-20240401193121872](assets/image-20240401193121872.png)

---

## 四、补码

补码就是将反码错开了一位，它把8个1规定为是-1的补码，而下面的7个1再加一个0，把它规定为是-2的补码，等等.....以此类推

这样做就可以把0的两种表现形式给屏蔽掉了，在补码当中，0只有一种表现形式，那就是8个0。所以这也就是我们在计算补码的时候，需要使用反码 + 1的原因。

整数的原反补相同。

![image-20240401194043689](assets/image-20240401194043689.png)

例如下图 `-4 + 5`，利用补码计算，结果就是1！

![image-20240401194527934](assets/image-20240401194527934.png)

因此，补码完美解决了计算机当中正数和负数的计算问题。也正是因为这个原因，在计算机当中数字的存储还有运算，它都是以补码的形式来运行的。

补码还有一个小细节：因为补码是在反码的基础上 + 1计算得到的，所以 -127的补码如下图。

![image-20240401194742629](assets/image-20240401194742629.png)

这样来讲就会空出一个数：一个1后面有7个0。

![image-20240401194930261](assets/image-20240401194930261.png)

其实这个也很好理解，因为0原来在反码当中有两种表现形式，现在挨个错了1位，所以0这里就需要节省1个二进制表现形式的数，节省出来的就跑到了最前面。因此计算机就将 `1 + 7个0` 规定成特殊数字： -128。在一个字节中，-128是没有原码也没有反码的，只有补码的表现形式。当然这是不碍事的，因为计算机中数字的存储和计算都是以补码的形式来操作的，所以我们说，一个字节的取值范围是 `-128 - 127`。

---

## 五、总结

原码：十进制数据的二进制表现形式，最左边是符号位，0为正，1为负。

原码的弊端：利用原码进行计算的时候，如果是正数完全没有问题。但是如果是负数计算，结果就会出错，实际运算的方向跟正确的运算方向是相反的，这个时候就出现了反码。



反码出现的目的：为了解决原码不能计算负数的问题而出现的。

反码的计算规则：正数的反码不变，负数的反码在原码的基础上，符号位不变。数值取反，0变1，1变0。

反码的弊端：负数运算的时候，如果不跨0，是没有任何问题的，但是如果结果跨0，跟实际结果会有1的偏差。这个时候就出现了最终的补码。



补码出现的目的：为了解决负数计算时跨0的问题而出现的。

补码的计算规则：正数的补码不变，负数的补码是在反码的基础上 + 1。另外补码还能多记录一个特殊的值 -128，该数据在1个字节下，没有原码和反码。

补码的注意点：计算机中的存储和计算都是以补码的形式进行的。

---

## 六、多学N招

在学完原反补后，就可以解释很多很多东西了，最后我们来多学N招。

### 1）不同类型的10有什么区别

在之前我们曾经说过，整数它有四种类型：byte、short、int、long。例如10，在不同类型下，它到底有什么区别呢？

byte在计算机中占1个字节，一共是8个比特位，8个0。short在计算机中是占用两个字节的，一共是16个比特位。int在内存中是占用4个字节，32个比特位。long在计算机中占8个比特位，一种64个比特位。对应的类型的10如下图：

![image-20240401201715354](assets/image-20240401201715354.png)

---

### 2）隐式转换

在之前，我们学习过类型转换。类型转换分为两种，其中一种就是隐式转换，那隐式转换的原理是什么样的呢？例如下段代码

~~~java
public class Test {
    public static void main(String[] args) {
        byte a = 10; // 000 1010
        // 将取值范围小的赋值给取值范围大的，此时会触发隐式转换
        int b = a; // byte转为int类型时，直接在前面补0。0000 0000 0000 0000 0000 0000 0000 1010
        System.out.println(b);
    }
}
~~~

---

### 3）强制转换

情况一

~~~java
public class Test {
    public static void main(String[] args) {
        int a = 300; // 正数原反补相同，都为：0000 0000 0000 0000 0000 0001 0010 1100
        // 将 a 强制转为byte类型
        // 由于byte的取值范围是 -128 到 127，已经超出了取值范围。直接去掉前面多余的位，只剩下最后的8个比特位
        byte b = (byte)a; // 0010 1100，转为十进制为44
        System.out.println(b);
    }
}
~~~

情况二

~~~java
public class Test {
    public static void main(String[] args) {
        int a = 200; // 正数原反补相同，都为：0000 0000 0000 0000 0000 0000 1100 1000
        byte b = (byte)a; // 去掉前面多余的位，留下8位为：1100 1000，此时要注意了，第一位变成了1，它是符号位，所以真正的数值变成了后面7位。并且在计算机中，数字的计算都是以补码的形式进行的，所以 1100 1000 还是补码形式。转为十进制，可以使用计算器计算
        System.out.println(b); // -56
    }
}
~~~

---

### 程序员计算机使用技巧

使用计算机中 `QWORD` 可以调节想要的字节数

<img src="assets/image-20240401203139206.png" alt="image-20240401203139206" style="zoom:50%;" />

选中第二个，然后不断切换 `QWORD` ，可以查看变化的字节数

![image-20240401203331709](assets/image-20240401203331709.png)

然后直接用鼠标点击0，它就会直接切换成1，切换后，这个就是对应的补码的形式。往上看，在十进制中，是-56。

<img src="assets/image-20240401203539555.png" alt="image-20240401203539555" style="zoom:50%;" />

Java最终运行的结果，它还是会转为十进制的形式展示出来，所以上面强制转换中情况二的的结果是 -56。

----

### 4）其他的运算符

![image-20240401203757270](assets/image-20240401203757270.png)

#### 逻辑与

现在逻辑与的作用并不是 true 和 false 了，而是一些数字。像这种计算方式在以后自己很少会去写，以后在看到一些源码的时候，有可能会看到一些这样的写法。所以在以后我们自己不用这么去写。

~~~java
public class Test {
    public static void main(String[] args) {
        int a = 200;  // 0000 0000 0000 0000 0000 0000 1100 1000
        int b = 10; // 0000 0000 0000 0000 0000 0000 0000 1010
        // 由于在二进制中0为false，1为true。它们在计算的时候，就是每个比特位挨着去计算，如果都是true，结果才是true。
        System.out.println(a & b); // 0000 0000 0000 0000 0000 0000 0000 1000，转换为十进制后结果是8
    }
}
~~~

---

#### 逻辑或

~~~java
public class Test {
    public static void main(String[] args) {
        int a = 200;  // 0000 0000 0000 0000 0000 0000 1100 1000
        int b = 10; // 0000 0000 0000 0000 0000 0000 0000 1010
        // 在计算的时候，只要有true，结果就是true。即只要有1，结果就是1
        System.out.println(a & b); // 0000 0000 0000 0000 0000 0000 1100 1010，转换为十进制后结果为202
    }
}
~~~

PS：这种计算数字的逻辑与和逻辑或是没有短路的。

---

#### 左移

将二进制向左移动，低位补0。

~~~java
public class Test {
    public static void main(String[] args) {
        int a = 200;  // 0000 0000 0000 0000 0000 0000 1100 1000
        // 将 a 左移两次，可以看下图，左移完后，右边空了两位，所以低位补0。
        System.out.println(a << 2); 
    }
}
~~~

![image-20240401210300527](assets/image-20240401210300527.png)

低位补0

![image-20240401210408461](assets/image-20240401210408461.png)

移完后，再转成十进制，就变成了800。移出去的这两位就不要了。

![image-20240401210514891](assets/image-20240401210514891.png)

公式：左移一位，就是乘以2。

---

#### 右移

将二进制向右移动，最左侧叫做高位，高位补0或1。如果原来是正数，就补0；如果原来是负数，就补1。即：补的是符号位。

~~~java
public class Test {
    public static void main(String[] args) {
        int a = 200;  // 0000 0000 0000 0000 0000 0000 1100 1000
        // 将 a 右移两次
        System.out.println(a >> 2); // 50
    }
}
~~~

左边的最高位补符号位

![image-20240401210847136](assets/image-20240401210847136.png)

这里补的是0，移出去的位就不要了

![image-20240401210938864](assets/image-20240401210938864.png)

换算为十进制后得到的结果就为 50

公式：右移一次，相当于除以2

---

#### 无符号右移

它跟右移是一回事，不过它在补符号的时候，不管原来数字是正是负，补的都是0。

---

# -----------------------------------

# Day4 流程控制语句

流程控制语句：通过一些语句，控制程序的执行流程。分为顺序结构、分支结构、循环结构。

# 学习方法转变

在以前，我们学习的更多是Java语法中的概念，例如数据类型，类型提升、强制转换、运算符等等。在前面的知识点中，基本上我们只要能把基础概念和格式能记住就行了。

从这一章节开始，每天要学习的内容会少一些，但是需要思考的东西就变的多了，所以从现在开始不仅要理解概念，更重要的是要分析题目的逻辑，多思考多联系。

# 39.顺序结构

顺序结构语句是Java程序默认的执行流程，按照代码的先后顺序，从上到下依次执行。如下代码就是顺序结构

~~~java
package com.itheima.orderdemo;

public class OrderDemo {
    public static void main(String[] args) {
        System.out.println("努力做主人喜欢的事");
        System.out.println("大小姐驾到！统统闪开！");
        System.out.println("凛冬已至，故乡的梅花开了吗");
        System.out.println("心怀不惧，方能翱翔于天际");
    }
}
~~~

---

# 40.分支结构

分支结构包含了两种语句：if语句、switch语句

## 一、if语句

为什么要有if语句呢？

需求：键盘录入女婿酒量，如果大于 2 斤，老丈人给出回应，反之不回应

if语句在程序中就是用来进行判断的。

---

## 二、if语句的第一种格式

~~~java
if (关系表达式) {
    语句体;
}
~~~

![image-20240401214545309](assets/image-20240401214545309.png)

执行流程

![image-20240401214653864](assets/image-20240401214653864.png)

**代码示例**

需求：键盘录入女婿酒量，如果大于 2 斤，老丈人给出回应，反之不回应

~~~java
package com.itheima.ifdemo;

import java.util.Scanner;

public class IfDemo1 {
    public static void main(String[] args) {
        //if格式
        //if(关系表达式){
            //语句体；
        // }

        //分析：
        //1.键盘录入女婿的酒量
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入女婿的酒量");
        int wine = sc.nextInt();
        //2.对酒量进行判断
        if(wine > 2){
            System.out.println("小伙子，不错哟！！");
        }
    }
}
~~~

---

## 三、if 的注意点

1. 大括号的开头可以另起一行书写，但是建议写在第一行的末尾，因为Java的发明者就是这样写的。

2. 在语句体中，如果只有一句代码，大括号可以省略不写。个人建议，大括号还是不要省略。

   下述代码这样写就会报错，因为 `int a = 100;` 至少包含了两句代码。1、定义变量a；2、给变量a赋值给100

   ~~~java
   if (number >= 10) 
       int a = 100;
   ~~~

3. 如果对一个布尔类型的变量进行判断，不要用 `==` 号，直接把变量写在小括号即可。防止 `==` 跟 `=` 搞混

   ~~~java
   boolean flag = true;
   // if (flag == true){
   if (flag){
      System.out.println("flag的值为true");
   }
   ~~~


---

## 四、练习：考试奖励

小红对小明说：如果你这次考试全班第一，我就做你女朋友。

<img src="assets/image-20240402103703003.png" alt="image-20240402103703003" style="zoom:50%;" />

班上其他同学非常感动，所以其他同学决定一起交白卷。

<img src="./assets/image-20240402103825997.png" alt="image-20240402103825997" style="zoom:50%;" />

最后小红非常开心

<img src="./assets/image-20240402103842530.png" alt="image-20240402103842530" style="zoom:50%;" />

需求：把小红的心理活动做一个代码实现。

**代码示例**

~~~java
package com.itheima.test;

public class Test1 {
    public static void main(String[] args) {
        //小红：如果你这次考试全班第一，我就做你女朋友。

        //分析：
        //1.定义变量记录小明的名次
        int ranking = 2;
        //2.对小明的名次进行判断。
        if(ranking == 1){
            System.out.println("小红成为了小明的女朋友");
        }
    }
}
~~~

---

## 五、练习：自动驾驶

当无人驾驶汽车行驶到十字路口遇到了红绿灯，如果红灯是亮的，它就会停止，如果绿灯是亮的，它就会继续前进。所以此时我们也可以使用 if语句 来进行模拟。

~~~java
package com.itheima.test;

public class Test2 {
    public static void main(String[] args) {
        //汽车无人驾驶会涉及到大量的判断
        //当汽车行驶的时候遇到了红绿灯，就会进行判断
        //如果红灯亮，就停止
        //如果黄灯亮，就减速
        //如果绿灯亮，就行驶


        //1.定义三个变量表示灯的状态
        //true表示灯亮  false表示灯灭
        boolean isLightGreen = false;
        boolean isLightYellow = false;
        boolean isLightRed = true;

        //2.判断
        //红灯亮，就停止
        //黄灯亮，就减速
        //绿灯亮，就行驶
        if(isLightGreen){
            System.out.println("GoGoGo!!!");
        }

        if(isLightYellow){
            System.out.println("slow!!!");
        }

        if(isLightRed){
            System.out.println("stop!!!");
        }
    }
}
~~~

----

# 41.if语句的第二种格式

## 一、语法

~~~java
if (关系表达式) {
    语句体1;
} else {
    语句体2;
}
~~~

PS：如果代码执行了语句体1，它就不会再执行else里的语句体2了。当语句体1执行完后，整个if就会结束。

<img src="./assets/image-20240402104811887.png" alt="image-20240402104811887" style="zoom:67%;" />

---

## 二、练习1：吃饭

需求：键盘录入一个整数，表示身上的钱。如果大于等于100块，就是网红餐厅。否则，就吃经济实惠的沙县小吃。

<img src="./assets/image-20240402104921252.png" alt="image-20240402104921252" style="zoom:50%;" />

~~~java
package com.itheima.test;

import java.util.Scanner;

public class Test3 {
    public static void main(String[] args) {
        //分析：
        //1.键盘录入一个整数，表示身上的钱。
        Scanner sc = new Scanner(System.in);
        System.out.println("请录入身上的钱");
        int money = sc.nextInt();
        //2.对钱进行判断（二选一）
        if(money >= 100){
            System.out.println("吃网红餐厅");
        } else{
            System.out.println("吃经济实惠的沙县小吃");
        }
    }
}
~~~

---

## 三、练习2：商品付款

这道练习是美国斯坦福大学的一道Java入门练习。

在实际开发中，如果要根据两种不同的情况来执行不同的代码，就需要用到if的第二种格式。
需求：
        假设，用户在超市实际购买，商品总价为：600元。
        键盘录入一个整数表示用户实际支付的钱。
        如果付款大于等于600，表示付款成功。否则付款失败。

~~~java
package com.itheima.test;

import java.util.Scanner;

public class Test4 {
    public static void main(String[] args) {
        //分析：
        //1.键盘录入一个整数表示用户实际支付的钱。
        Scanner sc = new Scanner(System.in);
        System.out.println("录入一个整数表示实际支付的钱");
        int money = sc.nextInt();
        //2.判断
        if(money >= 600){
            System.out.println("付款成功");
        }else{
            System.out.println("付款失败");
        }
    }
}
~~~

----

## 四、练习4：影院选座

这道练习是美国斯坦福大学的一道Java入门练习。

在实际开发中，电影院选座也会使用到if判断。
        假设某影院售卖了100张票，票的序号为1~100。
        其中奇数票号坐左侧，偶数票号坐右侧。
        键盘录入一个整数表示电影票的票号。
        根据不同情况，给出不同的提示：
        如果票号为奇数，那么打印坐左边
        如果票号为偶数，那么打印坐右边。

~~~java
package com.itheima.test;


import java.util.Scanner;

public class Test5 {
    public static void main(String[] args) {
        //分析：
        //1.键盘录入一个整数表示电影票的票号。
        Scanner sc = new Scanner(System.in);
        System.out.println("请录入一个票号");
        int ticket = sc.nextInt();
        //只有当ticket在0 ~ 100之间，才是真实有效的票
        //if的嵌套
        if(ticket >= 0 && ticket <= 100){
            //2.判断票号是奇数还是偶数
            if(ticket % 2 == 1){
                System.out.println("坐左边");
            }else{
                System.out.println("坐右边");
            }
        }
    }
}
~~~



---

# 42.if语句的第三种格式

## 一、语法

~~~java
if (关系表达式) {
    语句体1;
} else if (关系表达式2) {
    语句体2;
}
...
else {
    语句体2;
}
~~~

![image-20240402105903658](./assets/image-20240402105903658.png)

---

## 二、练习1：小明的礼物

需求：根据不同的分数送不同的礼物。
        如果是95~100分，送自行车一辆
        如果是90~94分，游乐场玩一天
        如果是80~89分，送变形金刚一个。
        如果是80分，揍一顿。

~~~java
package com.itheima.test;


import java.util.Scanner;

public class Test6 {
    public static void main(String[] args) {
        //分析：
        //1.键盘录入小明的考试成绩
        Scanner sc = new Scanner(System.in);
        System.out.println("请录入一个整数表示小明的成绩");
        int score = sc.nextInt();

        //对异常数据进行判断校验
        //0~100合理数据
        if(score >0 && score <= 100){
            //2.根据不同的考试成绩,给出不同的奖励
            if(score >= 95 && score <= 100){
                System.out.println("送自行车一辆");
            }else if(score >= 90 && score <= 94){
                System.out.println("游乐场玩一天");
            }else if(score >= 80 && score <= 89){
                System.out.println("送变形金刚一个");
            }else{
                System.out.println("揍一顿");
            }
        }else{
            System.out.println("当前录入的成绩不合法");
        }
    }
}
~~~

---

## 三、练习2：商品的价格

在实际开发中，多种情况判断时，会用到if的第三种格式：
需求：
            商场都会有VIP的会员制，根据不同的会员会有不同的折扣。
            假设商品总价为1000。
            键盘录入会员级别，并计算出实际支付的钱。
            会员1级：打9折。
            会员2级：打8折。
            会员3级：打7折。
            非会员：不打折，要打也是打骨折。

~~~java
package com.itheima.test;

import java.util.Scanner;

public class Test7 {
    public static void main(String[] args) {
        //分析：
        //1.定义变量记录总价
        int price = 1000;
        //2.键盘录入会员的级别
        Scanner sc = new Scanner(System.in);
        System.out.println("请录入会员的级别");
        int vip = sc.nextInt();
        //3.根据级别来计算实际要支付的钱
        if(vip == 1){
            System.out.println("实际支付的钱为" + (price * 0.9));
        }else if(vip == 2){
            System.out.println("实际支付的钱为" + (price * 0.8));
        }else if(vip == 3){
            System.out.println("实际支付的钱为" + (price * 0.7));
        }else{
            System.out.println("实际支付的钱为" + price);
        }
    }
}
~~~

----

## 四、练习3：自动驾驶

之前都是使用三个 if 来对三个变量进行判断，但是如果是这种写法，三个if是三个互相独立的代码块，每一次我们都需要从上往下把三个代码块全都执行一遍，效率相对来讲有点低。

<img src="./assets/image-20240402110454406.png" alt="image-20240402110454406" style="zoom:50%;" />

此时我们就可以用if的第三种格式来进行优化，由于我现在只有三种情况，所以最下面的else可以省略不写。

~~~java
package com.itheima.test;

public class Test8 {
    public static void main(String[] args) {
        //汽车无人驾驶会涉及到大量的判断
        //当汽车行驶的时候遇到了红绿灯，就会进行判断
        //如果红灯亮，就停止
        //如果黄灯亮，就减速
        //如果绿灯亮，就行驶

        //1.定义三个变量表示灯的状态
        //true 亮  false 灭
        boolean isLightGreen = true;
        boolean isLightYellow = false;
        boolean isLightRed = false;

        //2.判断
        //红灯亮，就停止
        //黄灯亮，就减速
        //绿灯亮，就行驶
        if(isLightGreen){ // 当isLightGreen为真时，直接打印 `GoGoGo!!!`，下面的代码块就不会再执行了，提高了程序的运行状态。
            System.out.println("GoGoGo!!!");
        }else  if(isLightYellow){
            System.out.println("slow!!!");
        }else if(isLightRed){
            System.out.println("stop!!!");
        }
    }
}
~~~

----

## 总结

第一种格式：单条件判断

第二种格式：双条件判断

第三种格式：多条件判断

----

# 43.switch语句和联系

## 一、引入

如果需要在多种条件中选择一个，就可以使用switch。

![image-20240402111129641](./assets/image-20240402111129641.png)

---

## 二、语法

case和值之间要用空格隔开，值的后面要加冒号。

这个表达式就不是判断了，而是会得到一个具体的结果。然后将表达式计算出的结果，一次跟case后面的每个值进行比较。

![image-20240402111843691](./assets/image-20240402111843691.png)

格式说明，注意表达式里面不能是double也不能是long。

case后面的值只能是字面量，不能是变量！

并且值的类型必须要与表达式的结果的类型保持一致，否则会报错！

![image-20240402112119948](./assets/image-20240402112119948.png)

流程图

![image-20240402112228373](./assets/image-20240402112228373.png)

---

## 三、练习1：吃面条

~~~java
package com.itheima.switchdemo;

public class SwitchDemo1 {
    public static void main(String[] args) {
        //兰州拉面、武汉热干面、北京炸酱面、陕西油泼面

        //1.定义变量记录我心里想吃的面
        String noodles = "海鲜龙虾面";

        //2.拿着这个面利用switch跟四种面条匹配
        switch (noodles){
            case "兰州拉面":
                System.out.println("吃兰州拉面");
                break;
            case "武汉热干面":
                System.out.println("吃武汉热干面");
                break;
            case "北京炸酱面":
                System.out.println("吃北京炸酱面");
                break;
            case "陕西油泼面":
                System.out.println("吃陕西油泼面");
                break;
            default:
                System.out.println("吃方便面");
                break;
        }
    }
}
~~~

---

## 四、练习2：运动计划

需求：键盘录入星期数，显示今天的减肥活动。
        周一：跑步
        周二：游泳
        周三：慢走
        周四：动感单车
        周五：拳击
        周六：爬山
        周日：好好吃一顿

~~~java
package com.itheima.test;

import java.util.Scanner;

public class Test9 {
    public static void main(String[] args) {
        //分析：
        //1.键盘录入星期数
        Scanner sc = new Scanner(System.in);
        System.out.println("请录入星期");
        int week = sc.nextInt();
        //2.利用switch对星期进行匹配
        switch (week){
            case 1:
                System.out.println("跑步");
                break;
            case 2:
                System.out.println("游泳");
                break;
            case 3:
                System.out.println("慢走");
                break;
            case 4:
                System.out.println("动感单车");
                break;
            case 5:
                System.out.println("拳击");
                break;
            case 6:
                System.out.println("爬山");
                break;
            case 7:
                System.out.println("好好吃一顿");
                break;
            default:
                System.out.println("没有这个星期");
                break;
        }
    }
}
~~~



----

# 44.switch的扩展点和练习

## 一、default的位置和省略

1. 位置 ：defaule不一定是写在最下面的，我们可以写在任意位置。只不过习惯会写在最下面。

2. 省略 : defaule可以省略，语法不会有问题，但是不建议省略。

   因为如果省略的话，上面的代码如果都不匹配，那就没有可以执行的代码了。

~~~java
package com.itheima.switchdemo;

/*
    default的位置和省略
*/
public class SwitchDemo2 {
    public static void main(String[] args) {
        int number = 100;
        switch (number){
            case 1:
                System.out.println("number的值为1");
                break;
            case 10:
                System.out.println("number的值为10");
                break;
            case 20:
                System.out.println("number的值为20");
                break;
            default:
                System.out.println("number的值不是1,10或者20");
                break;
        }
    }
}
~~~

---

## 二、case穿透

case穿透：就是语句体中没有写break导致的。
执行流程：首先还是会拿着小括号中表达式的值跟下面每一个case进行匹配。
        	如果匹配上了，就会执行对应的语句体，如果此时发现了break，那么结束整个switch语句。
        	如果没有发现break，那么程序会继续执行下一个case的语句体，一直遇到break或者右大括号为止。
使用场景：如果多个case的语句体重复了，那么我们考虑利用case穿透去简化代码。

~~~java
package com.itheima.switchdemo;

/*
    case穿透
*/
public class SwitchDemo3 {
    public static void main(String[] args) {
        int number = 10;
        switch (number){
            case 1:
                System.out.println("number的值为1");
                break;
            case 10:
                System.out.println("number的值为10"); // 会打印
                // break;
            case 20:
                System.out.println("number的值为20"); // 穿透，也会打印，遇到break停止
                break;
            default:
                System.out.println("number的值不是1,10或者20");
                // break;
        }
    }
}
~~~

----

## 三、switch新特性

这个新特性是JDK12开始才有的。

~~~java
package com.itheima.switchdemo;

/*
    switch新特性
        JDK12
*/

public class SwitchDemo4 {
    public static void main(String[] args) {
        //需求：
        // 1 2 3  一 二  三
        /*int number = 1;
        switch (number){
            case 1:
                System.out.println("一");
                break;
            case 2:
                System.out.println("二");
                break;
            case 3:
                System.out.println("三");
                break;
            default:
                System.out.println("没有这种选项");
                break;
        }*/

        // 由于上面那种写法看上去有点乱，因为打印语句和break都比较多。所以在JDK12的时候，优化了语句体和break。
        int number = 10;
        switch (number) {
            // 语法：省略冒号，直接写一个箭头，在箭头的后面写一对大括号，可以将要执行的语句体都写在大括号当中。用这种方式来写可以省略break，也不会出发case穿透现象。相当于利用了一个大括号，将break给优化了。就算大括号中加上 break 对程序也没有影响。
            // 但是如果语句体有多行的话，大括号是不能省略的。
            case 0 -> {

            };
            // 但如果要跳出其他循环，就可以在里面加上 break语句，此时它执行的是我们自己写的break语句，而不是大括号自带的break语句。
            case 1 -> {
                System.out.println("一");
                break loop; // 表示我要跳出 loop 这个循环
            }
            // 如果大括号里只有一行代码，大括号是可以省略的。
            case 2 -> System.out.println("二");
            case 3 -> System.out.println("三");
            default -> System.out.println("没有这种选项");
        }
    }
}
~~~

如果switch中得到一个结果，可以使用变量去接收这个结果。

~~~java
String str = switch (number) {
    case '0' -> ""; // 如果number传递过来的是字符'0'，就将 "" 赋值给str
    case '1' -> "Ⅰ"; // 如果number传递过来的是字符'1'，就将 "Ⅰ" 赋值给str
    case '2' -> "Ⅱ";
    case '3' -> "Ⅲ";
    case '4' -> "Ⅳ";
    case '5' -> "Ⅴ";
    case '6' -> "Ⅵ";
    case '7' -> "Ⅶ";
    case '8' -> "Ⅷ";
    case '9' -> "Ⅸ";
    default -> str = "";
}; // 这种写法需要在最后加一个分号
~~~

---

## 四、switch和if第三种格式各自的使用场景

`if` 的第三种格式：一般用于对范围的判断
`switch`：把有限个数据一一列举出来，让我们任选其一

~~~java
package com.itheima.switchdemo;

/*
    switch和if第三种格式各自的使用场景
*/
public class SwitchDemo5 {
    public static void main(String[] args) {
        int score = 100;
        if(score >= 90 && score <= 100){
            System.out.println("送自行车");
        }
    }
}
~~~

----

## 五、练习1：休息日和工作日

需求：键盘录入星期数，输出工作日、休息日。(1-5) 工作日，(6-7)休息日。

~~~java
package com.itheima.test;

import java.util.Scanner;

public class Test10 {
    public static void main(String[] args) {
        //分析：
        //1.键盘录入星期数
        Scanner sc = new Scanner(System.in);
        System.out.println("请录入一个整数表示星期");
        int week = sc.nextInt();
        //2.利用switch语句来进行选择
        /* switch (week) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                System.out.println("工作日");
                break;
            case 6:
            case 7:
                System.out.println("休息日");
                break;
            default:
                System.out.println("没有这个星期");
                break;
        } */
        // 简化
        /* switch (week) {
            case 1, 2, 3, 4, 5:
                System.out.println("工作日");
                break;
            case 6, 7:
                System.out.println("休息日");
                break;
            default:
                System.out.println("没有这个星期");
                break;
        }*/ 
        switch (week){
            case 1,2,3,4,5 ->  System.out.println("工作日");
            case 6,7 ->  System.out.println("休息日");
            default -> System.out.println("没有这个星期");
        }
    }
}
~~~

---

## 六、练习2：用户选择

~~~java
package com.itheima.test;

import java.util.Scanner;

public class Test11 {
    public static void main(String[] args) {
       /* 在实际开发中，如果我们需要在多种情况下选择其中一个，就可以使用switch语句。
        当我们拨打了某些服务电话时，一般都会有按键选择。
        假设现在我们拨打了一个机票预定电话。
        电话中语音提示：
        1机票查询
        2机票预订
        3机票改签
        4退出服务
        其他按键也是退出服务。请使用swtich模拟该业务逻辑。*/


        //分析：
        //1.键盘录入一个整数表示我们的选择
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入您的选择");
        int choose = sc.nextInt();
        //2.根据选择执行不同的代码
        switch (choose) {
            case 1 -> System.out.println("机票查询");
            case 2 -> System.out.println("机票预订");
            case 3 -> System.out.println("机票改签");
            // 由于case4 和default功能是一样的，直接不写 case 4 即可
            //case 4 -> System.out.println("退出服务");
            default -> System.out.println("退出服务");
        }
    }
}
~~~

---

# 45.for循环格式和练习

## 一、什么是循环？

- 重复的做某件事情
- 具有明确的开始和停止标记

例如下图电风扇，`open` 按钮就是开始标记，`stop` 按钮就是停止标记。

<img src="assets/image-20240402130642190.png" alt="image-20240402130642190" style="zoom:50%;" />

---

## 二、循环的分类

在Java中，循环一共分为三类：for、while、do...while

---

## 三、for循环

格式

~~~java
for (初始化语句; 条件判断语句; 条件控制) {
    循环体语句;
}
~~~

代码示例

~~~java
for (int i = 1; i <= 10; i++) { // 每次循环变量i都会自增一次，所以这里一共是循环十次。
    // 每次循环都会执行大括号中的循环体
    System.out.println("HelloWorld");
}
~~~

初始化语句只执行一次，判断语句为true，循环继续。判断语句为false，循环结束。

![image-20240402131653410](./assets/image-20240402131653410.png)

---

## 四、练习：打印 5 次HelloWorld

~~~java
package com.itheima.loopdemo;

public class ForDemo1 {
    public static void main(String[] args) {
        //1.需求：打印5次HelloWorld

        //分析：
        //i  1 ~ 5
        /*for(初始化语句;条件判断语句;条件控制语句){
            循环体；
        }*/

        for (int i = 1; i <= 5 ; i++){
            System.out.println("HelloWorld");
        }
    }
}
~~~

---

## 五、练习：输出数字

需求1：打印1-5

~~~java
package com.itheima.test;

public class Test12 {
    public static void main(String[] args) {
        //需求1：打印1-5

        //分析：
        //开始条件：1
        //结束条件：5
        for (int i = 1 ; i <= 5; i++){
            //第一次循环：i = 1
            //第二次循环：i = 2
            //i : 1 2 3 4 5
            System.out.println(i);
        }
    }
}
~~~

需求2：打印5-1

~~~java
package com.itheima.test;

public class Test12 {
    public static void main(String[] args) {
        //需求2：打印5-1
        //分析：
        //开始条件: 5
        //结束条件：1
        for(int i = 5 ; i >= 1 ; i--){
            System.out.println(i);
        } 
    }
}
~~~

---

## 六、练习：断线重连

在实际开发中，需要重复执行的代码，会选择循环实现。
        比如：如图所示。玩游戏的时候，如果网不好那么会经常断线重连。
        那么断线重连这个业务逻辑就需要重复执行。
        假设现在公司要求，断线重连的业务逻辑最多只写5次。
        请用代码实现。
        备注：断线重连的业务逻辑可以用输出语句替代。

<img src="./assets/image-20240402132725384.png" alt="image-20240402132725384" style="zoom:50%;" />

~~~java
package com.itheima.test;

public class Test13 {
    public static void main(String[] args) {
        //分析：
        //1，因为我们需要重复执行某段代码，所以需要用循环解决
        //循环的次数 5 次
        //开始条件：1
        //结束条件：5

        for(int i = 1; i <= 5;i++){
            System.out.println("第" + i + "次执行断线重连的业逻务辑");
        }
    }
}
~~~



----

# 46.for循环练习 — 累加思想和统计思想

## 一、练习1：求和

需求：在实际开发中，如果要获取一个范围中的每一个数据时，也会用到循环。
        比如：求1-5之间的和

~~~java
package com.itheima.test;

public class Test14 {
    public static void main(String[] args) {
        //分析：
        //1.循环1~5得到里面的每一个数字
        //开始条件：1
        //结束条件：5

        //用来进行累加的
        int sum = 0;
        for(int i = 1; i <= 5 ; i++){
            
            //int sum = 0;
            //System.out.println(i);
            //可以把得到的每一个数字累加到变量sum当中
            sum = sum + i;// sum += i;
            //System.out.println(sum);
        }

        //当循环结束之后，表示已经把1~5累加到变量sum当中了
        System.out.println(sum);
    }
}
~~~

扩展小点：

1. 求和的变量不能定义在循环的里面，因为变量只在所属的大括号中有效
2. 如果我们把变量定义在循环的里面，那么当前变量只能在本次循环中有效。
   当本次循环结束之后，变量就会从内存中消失。第二次循环开始的时候，又会重新定义一个新的变量。
   结论：如果以后我们要写累加求和的变量。可以把变量定义在循环的外面。

~~~java
for(int i = 1; i <= 5 ; i++){
    // 当本次循环结束之后，变量就会从内存中消失。第二次循环开始的时候，又会重新定义一个新的变量。
    int sum = 0;
    //可以把得到的每一个数字累加到变量sum当中
    sum = sum + i;
    System.out.println(sum);
}
~~~

---

## 二、练习2：求 1 - 100 之间的偶数求和

求：在实际开发中，如果要获取一个范围中的每一个数据时，会用到循环。
        但是此时，大多情况下，不会获取所有的数据，而是获取其中符合要求的数据。
        此时就需要循环和其他语句结合使用了。
        比如：求1-100之间的偶数和

~~~java
package com.itheima.test;

public class Test15 {
    public static void main(String[] args) {
        //分析：
        //1.获取1 ~100之间的每个数
        int sum = 0;
        // IDEA快捷方式：`循环次数.fori` 可以直接打印出for循环
        for (int i = 1; i <= 100; i++) {
            //2.累加求和（先判断，再求和）
            if(i % 2 == 0){
                sum = sum + i;
            }
        }
        //打印sum
        System.out.println(sum);
    }
}
~~~

----

## 二、练习3：统计满足条件的数字

需求：键盘录入两个数字，表示一个范围。统计这个范围中。既能被3整除，又能被5整除数字有多少个？

~~~java
package com.itheima.test;

import java.util.Scanner;

public class Test16 {
    public static void main(String[] args) {
        //分析：
        //1.键盘录入两个数字
        Scanner sc = new Scanner(System.in);
        System.out.println("请录入一个数字表示范围的开始");
        int start = sc.nextInt();
        System.out.println("请录入一个数字表示范围的结束");
        int end = sc.nextInt();

        //统计变量
        //简单理解：统计符合要求的数字的个数
        int count = 0;

        //2.利用循环获取这个范围中的每一个数字
        //开始条件：start
        //结束条件：end
        for (int i = start; i <= end; i++) {
            //3.对每一个数字进行判断，统计有多少个满足要求的数字
            if (i % 3 == 0 && i % 5 == 0) {
               // System.out.println(i);
                count++;
            }
        }

        System.out.println(count);
    }
}
~~~



----

# 47.while循环语句

## 一、while循环语句和for循环语句格式对比

![image-20240402141811503](./assets/image-20240402141811503.png)

while循环的执行流程

![image-20240402141859416](./assets/image-20240402141859416.png)

---

## 二、练习：利用while循环打印1~100

需求：利用while循环打印1~100

~~~java
package com.itheima.loopdemo;

public class WhileDemo1 {
    public static void main(String[] args) {
        //分析：
        //开始条件：1
        //结束条件：100

        int i = 1;
        while(i <= 100){
            System.out.println(i);
            i++;
        }
    }
}
~~~

---

## 三、for和while的对比

相同点：运行规则是一样的。

for 和 while 的区别：

- for循环中，控制循环的变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了
- while循环中，控制循环的变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用。

这种说法是很多书上的解释，但是这种说法并不是很绝对，因为for循环可以改写，for循环的初始化语句也可以写在for循环外面，小括号里初始化语句可以空着不写，此时两种循环就不会有任何区别了。

![image-20240402142407518](./assets/image-20240402142407518.png)

所以以下会从实际开发的角度说一下这两种到底有什么区别。

能用for循环的地方一定能用while循环进行改写，能用while循环的地方一定也能用while循环进行改写。这两个在语法当中其实是没有任何区别的，它们的区别在于使用习惯上。

- for循环中：知道循环次数或者循环的范围
- while循环：不知道循环的次数和范围， 只知道循环的结束条件

### 练习

需求：世界最高山峰是珠穆朗玛峰(8844.43米=8844430毫米)，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度?

~~~java
package com.itheima.test;

public class Test17 {
    public static void main(String[] args) {
        //分析：折叠纸张：每一次折叠纸张的厚度都是原先的两倍
        // double a = 0.1;
        // a = a * 2;
        // => a *= 2

        //1.定义一个变量用来记录山峰的高度
        double height = 8844430;
        //2.定义一个变量用来记录纸张的初始厚度
        double paper = 0.1;
        //3.定义一个变量用来统计次数
        int count = 0;
        //4.循环折叠纸张，只要纸张的厚度小于山峰的高度，那么循环就继续
        //每折叠一次，统计次数就要++
        //选择while理由：此时我们不知道循环的次数也不知道循环的范围，只知道循环的结束条件，所以用while
        while(paper < height){
            //折叠纸张
            paper = paper * 2;
            //折叠一次，++一次
            count++;
        }
        //当循环结束之后，count记录的值就是折叠的次数
        System.out.println(count);

    }
}
~~~

---

# 48.两道力扣算法题和do...while循环

## 一、练习：回文数

需求：给你一个整数 x 。
        如果 x 是一个回文整数，打印 true ，否则，返回 false 。
        解释：回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
        例如，121 是回文，而 123 不是。

~~~java
package com.itheima.test;

public class Test18 {
    public static void main(String[] args) {
        //分析：
        //1.定义变量记录整数
        int x = 12345;
        //把x做一个临时存储，用来最后进行判断
        int temp = x;
        //2.定义变量记录最终的结果（反过来的数字）
        int result = 0;
        //3.利用循环从右往左获取x中的数字并拼接到result当中
        //while
        while(x != 0){
            //获取到x最右边的数字
            int ge = x % 10;
            //获取一次数字之后，那么就要把当前最右边的数字给去掉
            x = x / 10;
            //拼接到result当中
            result = result * 10 + ge;
        }
        System.out.println(result == temp);



      /*  //1.如何获取到3
        int ge = x % 10;
        result = result + ge;
        System.out.println(result);

        //2.把十位2拼接到result里面
        int shi = x / 10 % 10;
        result = result * 10 + shi;
        System.out.println(result);//32

        //3.把百位拼接到result里面
        int bai = x / 100 % 10;
        result = result * 10 + bai;
        System.out.println(result);//321*/
    }
}
~~~

---

## 二、求商和余数

需求：给定两个整数，被除数和除数（都是正数，且不超过int的范围） 。
        将两数相除，要求不使用乘法、除法和 % 运算符。
        得到商和余数。

~~~java
package com.itheima.test;

public class Test19 {
    public static void main(String[] args) {
        /*
        分析：
            被除数 / 除数 = 商 ... 余数

        int a = 100;
        int b = 10;

        100 - 10 = 90
        90 - 10 = 80
        80 - 10 = 70
        70 - 10 = 60
        ...
        10 - 10 = 0 (余数)

        */


        //1.定义变量记录被除数
        int dividend = 100;
        //2.定义变量记录除数
        int divisor = 37;
        //3.定义一个变量用来统计相减了多少次
        int count = 0;
        //3.循环 while
        //在循环中，不断的用被除数 - 除数
        //只要被除数 是大于等于除数的，那么就一直循环
        while(dividend >= divisor){
            dividend = dividend - divisor;
            //只要减一次，那么统计变量就自增一次
            count++;
        }
       //当循环结束之后dividend变量记录的就是余数
        System.out.println("余数为：" + dividend);
        //当循环结束之后，count记录的值就是商
        System.out.println("商为：" + count);
    }
}
~~~

---

## 三、do....while循环

语法和特点：先执行后判断

![image-20240402172801328](./assets/image-20240402172801328.png)

----

# -------------------------------

# Day5  循环高级和数组

# 49.无限循环和跳转控制语句

## 一、引入

无限循环：循环一直停不下来。

for循环中，初始化语句可以空着不写，表示循环之前不做任何操作。中间的条件控制语句也可以空着不写，默认表示true，循环一直进行。最后的条件控制语句，也可以空着不写，表示每次循环之后不做任何的操作。

while循环中true一定要写，否则会报错，此时就表示判断条件为真，不断打印大括号循环体里的内容。

do...while循环中的true也一定要写，否则也会报错也表示不断打印大括号循环体里的内容。

这三种中无限循环中while循环是最常用的。

![image-20240402173005770](./assets/image-20240402173005770.png)

---

## 二、练习

PS：无限循环的下面不能再写其他代码了，因为循环永远停不下来，那么下面的代码永远执行不到

~~~java
package com.itheima.infiniteloop;

public class InfiniteloopDemo1 {
    public static void main(String[] args) {
        //for格式的无限循环
        for(;;){
            System.out.println("学习");
        }

        //while格式的无限循环
        while(true){
            System.out.println("学习");
        }

        //注意事项
        //无限循环的下面不能再写其他代码了，因为循环永远停不下来，那么下面的代码永远执行不到，并且写了还会报错
        while(true){
            System.out.println("给女神表白");
        }
        //System.out.println("女神答应我了");
    }
}
~~~

无限循环永远都停不下来，如果想要手动将它停下来，可以用鼠标点击左边的红色小方块，这个小方块也叫作：程序运行指示灯，如果这个方块是亮着的，表示程序在运行。如果按一下，给它按灭了，表示程序停止了。

![image-20240402174632499](./assets/image-20240402174632499.png)

---

## 三、跳转控制语句

在实际开发当中，很少让循环一直运行，而是会在合适的时候把循环给结束，那怎么结束呢？接下来就来学习跳转控制语句。

跳转控制语句：在循环的过程中，跳到其他语句上执行。

- continue：跳过本次循环，继续执行下次循环。

- break：结束整个循环。

![image-20240402175258473](./assets/image-20240402175258473.png)

案例一：小老虎吃包子，第三个包子有虫子，跳过

~~~java
package com.itheima.skiploop;

public class SkipLoppDemo1 {
    public static void main(String[] args) {
        //1.跳过某一次循环
        for (int i = 1; i <= 5; i++) {
            if(i == 3){
                //结束本次循环，继续下次循环。
                continue;
            }
            System.out.println("小老虎在吃第" + i + "个包子");
        }

    }
}
~~~

案例二：小老虎吃包子，吃完第三个就饱了。

~~~java
package com.itheima.skiploop;

public class SkipLoppDemo2 {
    public static void main(String[] args) {
        //2.结束整个循环
        for (int i = 1; i <= 5; i++) {
            System.out.println("小老虎在吃第" + i + "个包子");
            if(i == 3){
                //结束整个循环
                break;
            }
        }
    }
}
~~~



---

# 50.练习：逢七过

朋友聚会的时候可能会玩一个游戏：逢7过。
游戏规则：从任意一个数字开始报数，当你要报的数字是包含7或者是7的倍数时都要说过：过
需求：使用程序在控制台打印出1-100之间的满足逢七必过规则的数据

~~~java
package com.itheima.test;

public class LoopTest1 {
    public static void main(String[] args) {
        //分析：
        //个位7  十位7   7倍数
        //1 2 3 4 5 6 过 8 9 10 11 12 13 过 15 16 过 18 19 20 过....
        //69 过 过 过 过 过 过... 80

        //1.得到1~100之间的每一个数字
        //循环开始：1
        //循环结束：100
        for (int i = 1; i <= 100; i++) {
        //2.判断每一个数字，如果符合规则，就打印过，如果不符合规则就打印真实的数字
            if(i % 10 == 7 || i / 10 % 10 == 7  ||  i % 7 == 0){
                System.out.println("过");
                continue;
            }
            System.out.println(i);
        }
    }
}
~~~

---

# 51.练习：求平方根

需求：键盘录入一个大于等于2的整数 x ，计算并返回 x 的 平方根 。
        结果只保留整数部分 ，小数部分将被舍去 。

~~~java
package com.itheima.test;

import java.util.Scanner;

public class LoopTest2 {
    public static void main(String[] args) {
        //分析：
        //平方根   16的平方根4
        //         4的平方根2


        // 10
        // 1 * 1 = 1 < 10
        // 2 * 2 = 4 < 10
        // 3 * 3 = 9 < 10
        // 4 * 4 = 16 > 10
        //推断：10的平方根是在3~4之间。


        // 20
        // 1 * 1 = 1 < 20
        // 2 * 2 = 4 < 20
        // 3 * 3 = 9 < 20
        // 4 * 4 = 16 < 20
        // 5 * 5 = 25 > 20
        //推断：20的平方根是在4~5之间。


        //在代码当中
        //从1开始循环，拿着数字的平方跟原来的数字进行比较
        //如果小于的，那么继续往后判断
        //如果相等，那么当前数字就是平方根
        //如果大于的，那么前一个数字就是平方跟的整数部分


        //1.键盘录入一个整数
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个整数");
        int number = sc.nextInt();
        //2.从1开始循环判断
        //开始：1 结束: number
        for (int i = 1; i <= number; i++) {
            //用i * i 再跟number进行比较
            if(i * i == number){
                System.out.println(i + "就是" + number + "的平方根");
                //一旦找到了，循环就可以停止了，后面的数字就不需要再找了，提高代码的运行效率。
                break;
            }else if(i * i > number){
                System.out.println((i - 1) + "就是" + number + "平方根的整数部分");
                break;
            }
        }
    }
}
~~~

---

# 52.判断是否为质数

需求：键盘录入一个正整数 x ，判断该整数是否为一个质数。

~~~java
package com.itheima.test;

import java.util.Scanner;

public class LoopTest3 {
    public static void main(String[] args) {
       //质数：
        //如果一个整数只能被1和本身整除，那么这个数就是质数。否则这个数叫做合数
        //7 = 1 * 7 质数
        //8 = 1 * 8  2 * 4 合数


        //分析：
        //1.键盘录入一个正整数
        //number
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个正整数");
        int number = sc.nextInt();//9

        //定义一个变量，表示标记
        //标记着number是否为一个质数
        //true： 是一个质数
        //false : 不是一个质数

        //表示最初就认为number是一个质数
        boolean flag = true;


        //2.判断
        //写一个循环，从2开始判断，一直判断到number-1为止
        //看这个范围之内，有没有数字可以被number整除
        for (int i = 2; i < number; i++) {
            //i 依次表示这个范围之内的每一个数字
            //看number是否能被i整除就可以了
            if(number % i == 0){// 9 % 2 = 1
                flag = false;
                //System.out.println(number + "不是一个质数");
                break;
            }/*else{ // 肯定不能在else判断
                System.out.println(number + "是一个质数");
            }*/
        }

        //只有当这个循环结束了，表示这个范围之内所有的数字都判断完毕了
        //此时才能断定number是一个质数
        if(flag){
            System.out.println(number + "是一个质数");
        }else{
            System.out.println(number + "不是一个质数");
        }

    }
}
~~~

上面那种写法，如果数字很大，那么循环的次数就会很多，此时就需要简化

~~~java
package com.itheima.test;

public class LoopTest4 {
    public static void main(String[] args) {
        // 100000
        // 2 ~ 99999
        //循环的次数：将近10万次

        //推荐一个简化的思路
        //81
        //1 * 81
        //3 * 27
        //9 * 9


        //以81的平方根9，为中心
        //而且假设 a * b = 81
        //那么a和b中，其中有一个必定是小于等于9（81的平方根）的。
        //另一个是大于等于9（81的平方根）的。

        //假设，都是大于9 --- 9.1 * 9.1 > 81
        //假设，都是小于9 --- 8.9 * 8.9 < 81
        //其中一个数字一定是小于等于平方根
        //另外一个数字一定是大于等于平方根

        int number = 100;
        //如果这个范围之内，所有的数字都不能被number整除
        //那么number就一定是一个质数。
        for (int i = 2; i <= number的平方根; i++) {

        }
    }
}
~~~



---

# 53.猜数字小游戏

## 一、获取随机数

Java帮我们写好一个类叫Random，这个类可以生成一个随机数。这个类的学习可以参考以前Scanner学习步骤。

![image-20240402192517756](./assets/image-20240402192517756.png)

案例1：获取范围：0~10的随机数

~~~java
package com.itheima.test;

//1.导包，IDEA会帮我们自动生成
import java.util.Random;

public class LoopTest5 {
    public static void main(String[] args) {
        //先获取一个随机数。范围：0~10

        //2.创建对象
        Random r = new Random();

        //3.生成随机数
        //判断技巧：
        //在小括号中，书写的是生成随机数的范围
        //这个范围一定是从0开始的。
        //到这个数-1结束
        //口诀：包头不包尾，包左不包右
        for (int i = 0; i < 100; i++) {
            int number = r.nextInt(10);// 表示0 ~ 9之间
            System.out.println(number);
        }
    }
}
~~~

案例2：生成随机数范围：1~100的数字

~~~java
package com.itheima.test;

import java.util.Random;

public class LoopTest6 {
    public static void main(String[] args) {
        //需求：
        //随机数范围：1~100

        //创建对象
        Random r = new Random();
        //生成随机数
        int number = r.nextInt(100) + 1;//1  ~ 100
        System.out.println(number);


        //秘诀
        //用来生成任意数到任意数之间的随机数 7 ~15
        //1.让这个范围头尾都减去一个值，让这个范围从0开始  -7   0~8
        //2.尾巴+1       8 + 1 = 9
        //3.最终的结果，再加上第一步减去的值。

        Random r = new Random();
        int number = r.nextInt(9) + 7;// 7 ~ 15
                //   0 ~ 8  + 7 => 7 ~ 15
        System.out.println(number);

    }
}
~~~

---

## 猜数字小游戏

需求：程序自动生成一个1-100之间的随机数字，使用程序实现猜出这个数字是多少？

~~~java
package com.itheima.test;

import java.util.Random;
import java.util.Scanner;

public class LoopTest7 {
    public static void main(String[] args) {

        //注意点：
        //1.生成随机数的代码int number = r.nextInt(100) + 1;不能写在循环的里面的，否则每一次都会产生一个新的随机数

        //2.抽奖机制
        //用点券去抽水晶
        //保底 360次，如果360次没中，就会送你个水晶

        //扩展小需求：加一个保底机制，3次猜不中，直接提示猜中了。

        //计数器
        //用来统计当前已经猜了多少次。
        int count = 0;
        //分析
        // 1. 生成一个1-100之间的随机数字
        Random r = new Random();
        int number = r.nextInt(100) + 1;
        System.out.println(number);
        // 2. 猜这个数字是多少
        Scanner sc = new Scanner(System.in);
        while(true){
            System.out.println("请输入你要猜的数字");
            int guessNumber = sc.nextInt();

            //3 . 判断两个数字给出不同的提示
            //猜的数字大了，提示 大了
            //猜的数字小了，提示 小了
            //猜的数字一样，提示猜中了
            count++;
            if(count == 3){
                System.out.println("猜中了");
                break;
            }
            if(guessNumber > number){
                System.out.println("大了");
            }else if(guessNumber < number){
                System.out.println("小了");
            }else{
                System.out.println("猜中了");
                break;
            }
        }


    }
}
~~~



---

# 54.数组的概述和静态初始化

## 一、什么是数组？

数组指的是一种容器，可以用来存储**同种数据类型**的多个值。

同种数据类型我们不能理解的太死，例如现在定义了一个数组，限定以后能存double类型的小数。但现在有这样一堆数：有小数有整数，是否能存进去？

![image-20240403091645894](./assets/image-20240403091645894.png)

答案是可以的，之前学习过隐式转换，整数存进去后会自动转换成小数。

---

## 二、总结

- 数组容器在存储数据的时候，需要结合隐式转换考虑。
- 建议：容器的类型，和存储的数据类型保持一致

----

## 三、数组的定义

数组的定义和之前学习变量的定义非常类似。例如 `int a = 0`，但这句话其实是做了两件事情：等号左边叫定义，等号右边叫赋值

![image-20240403092120299](./assets/image-20240403092120299.png)

而我们学习数组的定义是等号左边那部分。数组的定义一共有两种格式，比定义变量多了一个中括号。

- 数据类型限定了数组以后能存什么类型的数据。
- `[ ]` 表示我们现在定义的是一个数组，如果没写 `[ ]` 就表示你现在定义的是一个变量。
- 数组名：就是一个名字，方便以后我们使用。
- `[ ]` 跟 `数组名` 是没有先后顺序的。个人习惯是第一种格式。

![image-20240403092213552](./assets/image-20240403092213552.png)

----

## 四、数组的初始化

初始化：就是在内存中，为数组容器开辟空间，并将数据存入容器中的过程。

数组初始化的两种方式：1、静态初始化；2、动态初始化

### 1）静态初始化

**完整格式**。在大括号中写上要存入数组中的多个元素就可以了，每个元素之间用逗号隔开。

~~~java
数据类型[] 数组名 = new 数据类型[] {元素1, 元素2, 元素3...};
~~~

示例：

~~~java
int[] arry = new int[] {11, 22, 33};
double[] arry = new double[] {11.1, 22.2, 33.3};
~~~

由于完整格式书写起来不太方便，因为它比较长。所以以后实际开发的时候，一般不会用它的完整格式，而是使用它的简写格式。

它的**简写格式**就是将 `new 数据类型[]` 直接省略，等号的右边直接写大括号。

~~~java
数据类型[] 数组名 = {元素1, 元素2, 元素3...};
~~~

示例：

~~~java
int[] arry = {11, 22, 33};
double[] arry = {11.1, 22.2, 33.3};
~~~

当数组初始化执行完毕后，在内存中就会开辟一块大空间，例如我现在要在数组中存三个元素，所以就会把大空间里分成三个小格子，每一个格子里装一个元素。

数组一旦创建完毕，长度就不能发生变化。

![image-20240403095510250](./assets/image-20240403095510250.png)

---

### 代码示例

~~~java
package com.itheima.arraydemo;

public class ArrayDemo1 {
    public static void main(String[] args) {
        //格式：
        //静态初始化
        //完整格式：
        //数据类型 [] 数组名 = new 数据类型[]{元素1，元素2....};
        //简化格式：
        //数据类型 [] 数组名 = {元素1，元素2....};


        //需求1：定义数组存储5个学生的年龄
        int[] arr1 = new int[]{11, 12, 13, 14, 15};
        int[] arr2 = {11, 12, 13, 14, 15};

        //需求2：定义数组存储3个学生的姓名
        String[] arr3 = new String[]{"zhangsan", "lisi", "wangwu"};
        String[] arr4 = {"zhangsan", "lisi", "wangwu"};

        //需求3：定义数组存储4个学生的身高 1.93
        double[] arr5 = new double[]{1.93, 1.75, 1.73, 1.81};
        double[] arr6 = {1.93,1.75,1.73,1.81};
    }
}
~~~



---

# 55.数组的地址值和元素访问

## 一、引入

直接将刚刚写的数组打印出来，发现打印出来的东西我们并不认识

~~~java
int[] arr1 = new int[]{11, 12, 13, 14, 15};
System.out.println(arr1); // [I@776ec8df
~~~

其实 `[I@776ec8df` 是数组容器在内存中的地址值，而并不是数组本身元素。

----

## 二、数组的地址值

定义了一个数组，其实就是在内存中开辟一段空间。在空间中再存入 `1、2、3、4、5`。

数组的地址值表示数组在内存中的位置。

![image-20240403100514762](./assets/image-20240403100514762.png)

----

## 三、`[D@776ec8df` 详解

~~~java
int[] arr1 = new int[]{11, 12, 13, 14, 15};
System.out.println(arr1);//[I@776ec8df
double[] arr6 = {1.93,1.75,1.73,1.81};
System.out.println(arr6);//[D@776ec8df  地址值
//扩展：
//解释一下地址值的格式含义  [D@776ec8df
//[ ：表示当前是一个数组
//D：表示当前数组里面的元素都是double类型的，I表示数组里面的元素都是int类型的。
//@：表示一个间隔符号。（固定格式）
//776ec8df：才是数组真正的地址值，它是一个十六进制的表现形式。
//但是平时我们习惯性的会把这个整体叫做数组的地址值。但其实只有后半部分才是真正的地址值776ec8df
~~~

---

## 四、元素访问

由于直接打印数组名是不会直接打印数组里的元素的，出现的是地址值。这个时候我们就需要来学习元素访问了。

格式：

~~~java
数组名[索引];
~~~

---

## 五、索引

假设现在有一个长度为5的数组，里面存了 `a 、b 、c 、d 、e` 这样的五个字母，按照正常人的理解，如果现在要获取第一个字母，直接说我们要拿第一个就行了。

![image-20240403101415576](./assets/image-20240403101415576.png)

计算机也是一样的，只不过计算机在数第几个的时候不会从1开始，而是从0开始。下面的 `0, 1, 2, 3, 4` 就是数组的索引。

![image-20240403101839717](./assets/image-20240403101839717.png)

索引：也叫作下标，角标。表示数组容器里每个小格子的编号。

索引的特点：从0开始，逐个 + 1增长，连续不间断。

我们可以通过索引把数组里的元素给获取出来，也可以通过索引把数据存储到数组当中。

----

### 代码示例

利用索引对数组中的元素进行访问 & 把数据存储到数组当中

~~~java
package com.itheima.arraydemo;

public class ArrayDemo2 {
    public static void main(String[] args) {
        //1.获取数组里面的元素
        //  格式： 数组名[索引]


        int[] arr = {1,2,3,4,5};
        //获取数组中的第一个元素
        //其实就是0索引上对应的元素
        // 获取完元素后不能单独放在这里，需要使用，可以赋值给一个变量也可以打印
        int number = arr[0];
        System.out.println(number);//1
        
        //获取数组中1索引上对应的数据，并直接打印出来
        System.out.println(arr[1]);//2


        //2.把数据存储到数组当中
        //格式：  数组名[索引] = 具体数据/变量；
        //细节：一旦覆盖之后，原来的数据就不存在了。
        arr[0] = 100;

        System.out.println(arr[0]);//100
    }
}
~~~



----

# 56.数组的遍历和三道综合练习

## 一、引入

数组遍历：将数组中所有的内容取出来，取出来之后可以（打印，求和，判断...）

注意：遍历指的是取出数据的过程，不要局限的理解为：遍历就是打印！

----

## 二、代码示例

~~~java
package com.itheima.arraydemo;

public class ArrayDemo3 {
    public static void main(String[] args) {
        //1.定义数组
        int[] arr = {1,2,3,4,5};
        //2.获取数组里面所有的元素
        //格式： 数组名[索引]
        System.out.println(arr[0]);
        System.out.println(arr[1]);
        System.out.println(arr[2]);
        System.out.println(arr[3]);
        System.out.println(arr[4]);

        //利用循环改进代码
        //开始条件：0
        //结束条件：数组的长度 - 1（最大索引）
        for (int i = 0; i < 5; i++) {
            //i: 0 1 2 3 4
            System.out.println(arr[i]);
        }

        //在Java当中，关于数组的一个长度属性，length
        //调用方式：数组名.length
        //System.out.println(arr.length);
        for (int i = 0; i < arr.length; i++) { // 这个才是通用的代码
            //i: 0 1 2 3 4
            System.out.println(arr[i]);
        }

        //扩展：
        //自动的快速生成数组的遍历方式
        //idea提供的：数组名.fori
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}
~~~

----

## 三、练习1：求和

定义一个数组，存储1,2,3,4,5，遍历数组得到每一个元素，求数组里面所有的数据和

~~~java
package com.itheima.test;

public class ArrTest1 {
    public static void main(String[] args) {
        //分析：
        //1.定义一个数组，并添加数据1,2,3,4,5
        int[] arr = {1,2,3,4,5};

        //求和变量
        int sum = 0;
        //2.遍历数组得到每一个数据，累加求和
        for (int i = 0; i < arr.length; i++) {
            //i 依次表示数组里面的每一个索引
            //arr[i] 依次表示数组里面的每一个元素
            sum = sum + arr[i];
        }

        //当循环结束之后，sum的值就是累加之后的结果
        System.out.println(sum);
    }
}
~~~

----

## 四、练习2：统计个数

定义一个数组，存储1,2,3,4,5,6,7,8,9,10。遍历数组得到每一个元素，统计数组里面一共有多少个能被3整除的数字

~~~java
package com.itheima.test;

public class ArrTest2 {
    public static void main(String[] args) {
        //分析：
        //1.定义一个数组 存储1,2,3,4,5,6,7,8,9,10
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        //定义一个变量，用来统计次数
        int count = 0;
        //2.遍历数组得到每一个元素
        for (int i = 0; i < arr.length; i++) {
            //i 表示数组里面的每一个索引
            //arr[i] 表示数组里面的每一个元素
            //3.判断当前的元素是否为3的倍数，如果是那么统计变量就需要自增一次。
            if(arr[i] % 3 == 0){
               // System.out.println(arr[i]);
                count++;
            }
        }
        //当循环结束之后，就表示数组里面所有的数字都判断完毕了，直接打印count即可
        System.out.println("数组中能被3整除的数字有" + count + "个");
    }
}
~~~

----

## 五、练习3：变化数据

定义一个数组，存储1,2,3,4,5,6,7,8,9,10
遍历数组得到每一个元素。
要求：
1：如果是奇数，则将当前数字扩大两倍
2：如果是偶数，则将当前数字变成二分之一

~~~java
package com.itheima.test;

public class ArrTest3 {
    public static void main(String[] args) {
        //分析：
        //1.定义一个数组，存1,2,3,4,5,6,7,8,9,10
        int[] arr = {1,2,3,4,5,6,7,8,9,10};
        //2.遍历数组得到每一个元素
        for (int i = 0; i < arr.length; i++) {
            //i 依次表示数组里面的每一个索引
            //arr[i] 依次表示数组里面的每一个元素
            //3.对每一个元素进行判断
            if(arr[i] % 2 == 0){
                //偶数 变成二分之一
               arr[i] = arr[i] / 2;
            }else{
                //奇数 扩大两倍
                arr[i] = arr[i] * 2;
            }
        }

        //遍历数组
        //注意：一个循环尽量只做一件事情。如果循环里做的事情多了，会混淆
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}
~~~



----

# 57.数组的动态初始化和常见问题

## 一、为什么有数组动态初始化呢？

如果一开始就知道数组里的数据，就可以使用静态初始化去完成。但是如果一开始就不知道要添加什么数据，那此时大括号中写什么呢？

~~~java
int[] arr = {1, 2, 3, 4, 5};
int[] arr = {????}
~~~

是不是感觉写什么都不太合适。所以动态初始化和静态初始化的应用场景是不一样的。

----

## 二、动态初始化

动态初始化：初始化时只指定数组长度，由系统为数组分配初始值。

格式

~~~java
数据类型[] 数组名 = new 数据类型[数组长度];
~~~

示例：下述代码表示arr数组里只能存3个int类型的整数。

~~~java
int[] arr = new int[3];
~~~

----

## 三、代码示例

需求：定义一个数组，用来存班级中50个学生的姓名。姓名未知，等学生报道之后，再进行添加。

~~~java
package com.itheima.arraydemo;

public class ArrayDemo4 {
    public static void main(String[] args) {
        //格式：
        //数据类型[] 数组名 = new 数据类型[数组的长度];
        //在创建的时候，由我们自己指定数组的长度，由虚拟机给出默认的初始化值

        String[] arr = new String[50];
        //添加学生
        arr[0] = "zhangsan";
        arr[1] = "lisi";
        //获取
        System.out.println(arr[0]);//zhangsan
        System.out.println(arr[1]);//lisi
        System.out.println(arr[2]);//打印出来的是默认初始化值null
    }
}
~~~

---

## 四、数组默认初始化值的规律

整数类型：默认初始化值0
小数类型：默认初始化值0.0
字符类型：默认初始化值'\u0000' 空格
布尔类型：默认初始化值 false
引用数据类型：默认初始化值 null，String就是一个引用数据类型

~~~java
int[] arr2 = new int[3];
System.out.println(arr2[0]);//0
System.out.println(arr2[1]);//0
System.out.println(arr2[2]);//0
~~~

---

## 五、数组动态初始化和静态初始化的区别

1、动态初始化：手动指定数组长度，由系统给出默认初始化值。

- 只明确元素个数，不明确具体数值，推荐使用动态初始化

- 例如：使用数组容器来存储键盘录入的5个整数。

  ~~~java
  int[] arr = {????}; // 不明确数组中应该存储哪些
  int[] arr = new int[5]; // 就使用动态初始化
  ~~~



2、静态初始化：手动指定数组元素，系统会根据元素个数，计算出数组的长度。

- 需求中已经明确了要操作的具体数据，直接静态初始化即可。

- 例如：将全班的学生成绩存入数组中：11，22 ，33

  ~~~java
  int[] arr = {11, 22, 33};
  ~~~

----

## 六、数组常见问题：越界

当访问了数组中不存在的索引，就会引发索引越界异常

~~~java
package com.itheima.arraydemo;

public class ArrayDemo5 {
    public static void main(String[] args) {
        //1.定义一个数组
        int[] arr = {1,2,3,4,5};
        //长度：5
        //最小索引：0
        //最大索引：4（数组的长度 - 1）
        //如果访问的数字不在这个范围（0 ~ 4）就会报索引越界异常
        System.out.println(arr[2]);


        //小结：
        //索引越界异常
        //原因：访问了不存在的索引
        //避免：只要知道索引的范围就行了
        //最小索引：0
        //最大索引：（数组的长度 - 1）
    }
}
~~~

下图的红色就表示代码出现了问题，通常我们也会说代码报错了。

阅读报错的信息：Exception：异常，异常在main里。`java.lang.ArrayIndexOutOfBoundsException` 是异常的名字，叫做：索引越界异常。后面就会紧接着异常出现的解释：`Index 10 out of bounds for length 5`，索引10已经超过了长度为5的数组。

at：表示 `在`。`com.itheima.arraydemo` 是包名，`ArrayDemo5` 是类名。`main` 是方法名。`ArrayDemo5.java:10` 表示异常出现的位置，这里就表示在第10行出现了问题。![image-20240403110539506](./assets/image-20240403110539506.png)

点一下，它就会自动跳转到第10行。

![image-20240403111005902](./assets/image-20240403111005902.png)



-----

# 58.数组练习1：求最值

~~~java
package com.itheima.test;

public class ArrTest4 {
    public static void main(String[] args) {
        //定义数组求最大值：33,5,22,44,55
        
        //1.定义数组用来存储5个值
        int[] arr = {33,5,22,44,55};
        //2.定义一个变量max用来存储最大值
        //临时认为0索引的数据是最大的
        int max = arr[0];
        //3.循环获取数组中的每一个元素
        //拿着每一个元素跟max进行比较
        for (int i = 0; i < arr.length; i++) {
            //i 索引  arr[i] 元素
            if(arr[i] > max){
                max = arr[i];
            }
        }
        //4.当循环结束之后，max记录的就是数组中的最大值
        System.out.println(max);//55
    }
}
~~~

**扩展问题**

~~~java
//1.根据求最大值的思路，自己改写一下求最小值
//2.为什么max要记录为arr[0],默认值不能为0吗？
//答案：不能写0。例如：如果数组里的值都是负数呢，那最大值就是0了，但数组里并没有0。
//max的初始化值一定要是数组中的值。
//3.循环中开始条件一定是0吗？
//循环的开始条件如果为0，那么第一次循环的时候是自己跟自己比了一下，对结果没有任何影响，但是效率偏低
//为了提高效率，减少一次循环的次数，循环开始条件可以写1.
for (int i = 1; i < arr.length; i++) {
    //i 索引  arr[i] 元素
    if(arr[i] > max){
        max = arr[i];
    }
}
~~~



----

# 59.数组练习2：求和并统计个数

需求：生成10个1~100之间的随机数存入数组。
        1）求出所有数据的和
        2）求所有数据的平均数
        3）统计有多少个数据比平均值小

~~~java
package com.itheima.test;

import java.util.Random;

public class ArrTest5 {
    public static void main(String[] args) {
        //分析：
        //1.定义数组，这里应该使用动态初始化，因为我们现在还不知道数组里面的值
        int[] arr = new int[10];
        //2.把随机数存入到数组当中
        Random r = new Random();

        for (int i = 0; i < arr.length; i++) {
            //每循环一次，就会生成一个新的随机数
            int number = r.nextInt(100) + 1;
            //把生成的随机数添加的数组当中
            //数组名[索引] = 数据;
            arr[i] = number;
        }


        // 1）求出所有数据的和
        //定义求和变量
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            //循环得到每一个元素
            //并把元素累加到sum当中
            sum = sum + arr[i];
        }
        System.out.println("数组中所有数据的和为：" + sum);


        //2）求所有数据的平均数
        int avg = sum / arr.length;
        System.out.println("数组中平均数为：" + avg);



        //3）统计有多少个数据比平均值小
        int count = 0;
        for (int i = 0; i < arr.length; i++) {
            if(arr[i] < avg){
                count++;
            }
        }

        //当循环结束之后，就表示我已经找到了所有的比平均数小的数据
        System.out.println("在数组中，一共有" + count + "个数据，比平均数小");



        //遍历数组，验证答案
        for (int i = 0; i < arr.length; i++) {
            // println中删掉 ln ，表示在打印的时候就不会换行了
            System.out.print(arr[i] + " ");
        }
    }
}
~~~



-----

# 60.数组练习3：交换数据

需求：定义两个变量，交换两个变量记录的值

~~~java
package com.itheima.test;

public class ArrTest6 {
    public static void main(String[] args) {
        int a = 10;
        int b = 20;

        // 错误解法：
        //把变量b的值。赋值给了变量a。那么变量a原来的值就被覆盖了
        a = b;//a = 20 b = 20

        //把变量a的值，赋值给了变量b。
        b = a;//a = 20 b = 20

        System.out.println(a);//20
        System.out.println(b);//20 // 这样做显然是不行的

        // 正确做法：
        //定义一个临时的第三方变量
        //把变量a的值，赋值给了temp
        int temp = a;
        //把变量b的值，赋值给了a。那么变量a原来记录的值就被覆盖了
        a = b;
        //就是把变量a原来的值，赋值给了变量b
        b = temp;
        System.out.println(a);//20
        System.out.println(b);//10
    }
}
~~~

需求：定义一个数组，将数组中0索引和最大索引出的值进行交换

```java
package com.itheima.test;

public class ArrTest7 {
    public static void main(String[] args) {
        //1.定义一个数组
        int[] arr = {1,2,3,4,5};
        //2.将数组中0索引和最大索引出的值进行交换
        //也是可以利用第三方变量进行交换
        int temp = arr[0];
        arr[0] = arr[4];
        arr[4] = temp;

        //3.遍历数组
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }
}
```

需求：定义一个数组，存入1,2,3,4,5。交换首尾索引对应的元素。
交换前：1,2,3,4,5
交换后：5,2,3,4,1

~~~java
package com.itheima.test;

public class ArrTest8 {
    public static void main(String[] args) {
        //1.定义数组存储数据
        int[] arr = {1,2,3,4,5};
        //2.利用循环去交换数据
        for(int i = 0,j = arr.length - 1; i < j; i++,j--){
            //交换变量i和变量j指向的元素
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        //当循环结束之后，那么数组中的数据就实现了头尾交换
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }
}
~~~



---

# 61.数组练习4：打乱数据



~~~java
package com.itheima.test;

import java.util.Random;

public class ArrTest9 {
    public static void main(String[] args) {
        //需求：定义一个数组，存入1~5。要求打乱数组中所有数据的顺序。
        //难点：
        //如何获取数组中的随机索引
       /* int[] arr = {1,2,3,4,5};
        //索引范围：0 1 2 3 4
        Random r = new Random();
        int randomIndex = r.nextInt(arr.length);
        System.out.println(randomIndex);*/


        //1.定义数组存储1~5
        int[] arr = {1, 2, 3, 4, 5};
        //2.循环遍历数组，从0索引开始打乱数据的顺序
        Random r = new Random();
        for (int i = 0; i < arr.length; i++) {
            //生成一个随机索引
            int randomIndex = r.nextInt(arr.length);
            //拿着随机索引指向的元素 跟 i 指向的元素进行交换
            int temp = arr[i];
            arr[i] = arr[randomIndex];
            arr[randomIndex] = temp;
        }
        //当循环结束之后，那么数组中所有的数据已经打乱顺序了
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }
}
~~~



----

# 62.数组的内存图

## 一、Java的内存分配

每款软件在运行的时候，都是需要占用一块内存区域的。Java也不例外，在运行的时候，虚拟机也会占用一块内存空间。

![image-20240403170220115](./assets/image-20240403170220115.png)

只不过为了更好的利用这块空间，虚拟机把它分成了五个部分，每个部分都有其各自的作用。

<img src="./assets/image-20240403171143942.png" alt="image-20240403171143942" style="zoom:50%;" />

其中有一块空间需要单独说，那就是方法区。

在JDK7以前，方法区跟堆空间它们两个是连在一起的，在真实的物理内存当中也是一块连续的空间，但是这种设计方式并不是很好。

<img src="./assets/image-20240403170838621.png" alt="image-20240403170838621" style="zoom:50%;" />

到了JDK8的时候，就改进了这种设计，取消了方法区，新增了一块元空间的区域，把它跟堆空间分开了，把原来方法区要做的很多的事情都进行拆分，有的功能放到了堆当中，有的功能放到了堆中，有的功能放到了元空间中，而现在加载字节码文件的功能在JDK8以后就归属于元空间了。

<img src="./assets/image-20240403170257736.png" alt="image-20240403170257736" style="zoom: 50%;" />

但是它具体叫什么名字不重要，重要的是它加载完后，代码该如何运行。为了方便大家理解，我们暂时将这块区域仍叫做方法区。

我们要知道程序在内存当中怎么运行的，首先我们就需要知道这五块内存空间它各自的作用。

- 栈：方法运行时使用的内存，比如main方法运行，进入方法栈中执行

- 堆：存储对象或者数组，new来创建的，都存储在堆内存。

  new出来的东西都是在堆当中，由于数组也是new出来的，所以数组就是存储在堆当中的。

- 方法区：存储可以运行的class文件

  当我们一个类，要开始运行的时候，它都会会把这个类的字节码文件（也就是那个class文件）加载到方法区中，临时存储。

- 本地方法栈：JVM在使用操作系统功能的时候使用，和我们开发无关

- 寄存器：给CPU使用，和我们开发无关

---

## 二、栈

栈：方法运行时使用的内存，其中程序的主入口main方法在开始执行的时候就会进到栈里，当main方法中的代码执行完毕后，main方法就会从栈中出去。

---

## 三、堆

堆内存只要记住一句话就行了：只要看见 `new` 关键字，就是在堆里开辟了一个空间。

在堆中开辟空间它会有地址值，它表示在内存当中的位置。

<img src="./assets/image-20240403173142262.png" alt="image-20240403173142262" style="zoom: 67%;" />

而每一块小空间它的位置都是不一样的。

<img src="./assets/image-20240403173212986.png" alt="image-20240403173212986" style="zoom:67%;" />

---

## 四、最简单的代码内存

先来看一个最简单的代码，我们现在只需要关注栈和堆，但由于这块代码没有用到new关键字，所以只需要关注栈空间即可。

程序在最开始运行的时候，程序的主入口main方法就会进入到栈里。

<img src="./assets/image-20240403173550688.png" alt="image-20240403173550688" style="zoom:50%;" />

然后从第一行开始逐行往下来执行里面的代码。

<img src="./assets/image-20240403174515715.png" alt="image-20240403174515715" style="zoom:50%;" />

首先执行到 `int a = 10;`，此时在这里定义了一个变量，它的名字就叫 `a` ，然后给这个变量做了一个类型的限定，这块空间以后只能存int类型的整数。

<img src="./assets/image-20240403174529138.png" alt="image-20240403174529138" style="zoom:50%;" />

然后再把10放到这块小空间里。

<img src="./assets/image-20240403174620639.png" alt="image-20240403174620639" style="zoom:50%;" />

此时需要定义第二个变量 `b`，其实就是将刚刚的动作重复了一下。再来开辟一个空间，给它起个名字叫做 `b`。给它做一个类型的限定：int。

<img src="./assets/image-20240403174655083.png" alt="image-20240403174655083" style="zoom:50%;" />

然后再把10放入到这块空间里

<img src="./assets/image-20240403174708796.png" alt="image-20240403174708796" style="zoom:50%;" />

再往下，执行到第三行代码，第三行是一个变量c，也做一个类型的限定：int。

但是它里面的值是 `a + b`，所以它会先把变量 a 和 变量 b 里的值拿出来进行相加，得到一个 `20`，然后再把20赋值给变量 `c`。

最后就是打印变量 `c` 中的值。它就是先找到变量c中记录的值，然后再把20打印在控制台当中。

<img src="./assets/image-20240403174739299.png" alt="image-20240403174739299" style="zoom:50%;" />



----

## 五、数组中的内存

![image-20240403211104723](./assets/image-20240403211104723.png)

由于这次有new关键字，所以我们即需要考虑栈，还需要考虑堆。

![image-20240403205757176](./assets/image-20240403205757176.png)

首先程序开始运行，main方法需要加载到栈中。

![image-20240403205816394](./assets/image-20240403205816394.png)

然后开始执行第一行代码：定义一个数组。但这行代码其实是由左右这两部分来组成的。

![image-20240403205841810](./assets/image-20240403205841810.png)

所以我们先来看等号左边。等号的左边就是在栈中定义了这样的一个变量，变量的名字叫做arr，类型限定 `int[]`。那就表示，当前的arr可以记录int类型数组的地址值。

![image-20240403205922804](./assets/image-20240403205922804.png)

然后再次执行到等号的右边。

![image-20240403205937107](./assets/image-20240403205937107.png)

等号的右边因为有new关键字，所以它会在堆中开辟一块小空间。因为长度为2，所以它会有0和1两个索引。位置上所对应的元素就是0，因为数组是int类型的，它里面的默认初始化值就是0。

![image-20240403210009516](./assets/image-20240403210009516.png)

由于数组中存储的数据有很多很多，没办法将所有数据都存在arr变量中，所以Java在设计的时候就会把所有的数据放在另外一块空间里，而arr记录的就是另外一块空间的地址值。

在堆里面的空间它是有地址值的，它会通过中间的等号运算符，将这个小空间的地址赋值给左边的变量arr。

![image-20240403210031907](./assets/image-20240403210031907.png)

arr通过地址值也可以找到右边堆里的小空间。

![image-20240403210046526](./assets/image-20240403210046526.png)

所以说代码往下，打印arr的时候，它打印的其实就是变量所记录的地址值。

![image-20240403210113505](./assets/image-20240403210113505.png)

但是这个地址值对我们来讲没有什么用，我们要用到的是数组里的数据。

所以再往下，第三行代码：通过数组名 + 索引的方式进行获取。内存中它是通过arr找到了右边堆中的空间，然后再通过0索引找到了第一个数据。

![image-20240403210301546](./assets/image-20240403210301546.png)

所以在控制台中打印的就是0。

![image-20240403210324730](./assets/image-20240403210324730.png)

同理，打印索引1也是一样的，先通过arr找到右边这个空间。

![image-20240403210343661](./assets/image-20240403210343661.png)

通过1索引找到里面所对应的数据。在控制台中打印的就是数据0。

![image-20240403210401203](./assets/image-20240403210401203.png)

----

## 六、在内存中如何给数组赋值？

其实跟刚刚是一样的。看下面的代码，`arr[0] = 11` ，其实是就是将 11 赋值给 arr 的0索引。

在此之前，它也要通过arr找到右边的这块小空间。

![image-20240403210719204](./assets/image-20240403210719204.png)

然后再把11赋值给0索引，此时0索引原来的元素就可以被覆盖了。

![image-20240403210650414](./assets/image-20240403210650414.png)

同样的道理，将22赋值给1索引也是把原来的元素给覆盖了。此时数组里面存储的就是新的元素。

![image-20240403210743014](./assets/image-20240403210743014.png)

再往下，如果现在再来获取数组里的元素。

![image-20240403210803023](./assets/image-20240403210803023.png)

由于数组中的0索引和1索引都被修改了，所以现在获取的就是修改之后的元素，通过0元素找到的元素是11，控制台打印的就是11。

![image-20240403210821813](./assets/image-20240403210821813.png)

通过1索引找到的就是22，所以控制台打印的就是22。

![image-20240403210839037](./assets/image-20240403210839037.png)

---

## 七、两个数组的内存图

第二个数组会对第一个数组产生影响吗。

在代码中，又创建了第二个数组，虽然第二个数组里面没有new关键字，但是我们要知道，这个是简化的书写格式，它的完整书写格式里面还是有new关键字的。

![image-20240403210852756](./assets/image-20240403210852756.png)

因此它同样也会在堆中开辟一个空间。

![image-20240403210904035](./assets/image-20240403210904035.png)

而左边的arr2记录的就是第二个空间的地址值。此时在堆里就有两块空间了。这两块空间是互相独立的，两者之间是没有任何影响的。

所以在打印arr2的时候，打印的就是arr2里记录的地址值。

![image-20240403210927689](./assets/image-20240403210927689.png)

再往下，我们在打印arr2的0索引，此时就是通过arr2来找到了右边的第2个空间。

![image-20240403210940062](./assets/image-20240403210940062.png)

再去打印里面的0索引，此时在控制台里面打印的就是33

![image-20240403210953882](./assets/image-20240403210953882.png)

同理，我们要打印1索引，同样通过arr2找到右边第2块空间，然后再找到1索引对应的44，此时在控制台打印的就是44。

最后一个打印2索引，同样也是过arr2找到右边第2块空间，然后再找到2索引对应的55。

![image-20240403211032444](./assets/image-20240403211032444.png)

---

## 八、总结

1. 只要是new出来的一定是在堆里面开辟了一个小空间。并且堆里开辟的空间是有地址值的。
2. 如果new了多次，那么在堆里面有多个小空间，每个小空间中都有各自的数据。

---

## 九、两个数组指向同一个空间的内存图

在代码中定义了一个数组，在第二行代码中，并没有创建，而是把arr1赋值给了arr2，然后再在下面一顿操作。

首先main方法需要先进栈。

![image-20240403213221291](./assets/image-20240403213221291.png)

然后再来往下执行第一行代码

![image-20240403213233963](./assets/image-20240403213233963.png)

第一行代码就是定义一个数组，所以在栈里面就会有一个arr1。

![image-20240403213243930](./assets/image-20240403213243930.png)

由于等号右边的完整格式中有new关键字，所以就在堆里面开辟了一段空间，里面要存储11 和 22。

![image-20240403213301479](./assets/image-20240403213301479.png)

然后再把这块空间的地址值 `0x0011`  赋值给arr1，此时arr1就可以通过这个地址找到右边的空间。

![image-20240403213321697](./assets/image-20240403213321697.png)

再来看这里面的第2行代码，等号的左边还是在栈里定义了一个arr2。但是你要注意，在等号的右边它是没有new关键字的，在等号的右边是arr1。它表示将arr1所记录的内容赋值给了arr2。

![image-20240403213355101](./assets/image-20240403213355101.png)

来看中间这块内存，现在arr1里记录的是0x0011地址值，所以它就会把这个地址值赋值给arr2。

现在就形成了arr1和arr2都指向了同一块空间。

![image-20240403213418211](./assets/image-20240403213418211.png)

接下来打印arr1[0]，首先通过arr1找到 `0x0011`，然后找到里面的0索引，然后找到元素11。所以在控制台中打印的就是11。

![image-20240403213432335](./assets/image-20240403213432335.png)

然后再来执行下面的代码 `sout(arr2[0])` ，要注意，现在arr2记录的也是 `0x0011`，所以找的同样的也是右边的空间。找到0索引同样也是11。

![image-20240403213448765](./assets/image-20240403213448765.png)

所以在控制台中这两个语句在控制台中打印的都是11。

![image-20240403213501200](./assets/image-20240403213501200.png)

再往下，`arr[0] = 33`，相当于把33赋值给了arr2的0索引，arr2现在记录的是 `0x0011`，所以它找的就是右边这块空间的0索引里面的元素变成了33。

![image-20240403213515729](./assets/image-20240403213515729.png)

再往下，修改完后，再通过 `arr1` 和 `arr2` 再去访问0索引，此时打印的值应该打印的是一样的。都是33。

![image-20240403213540874](./assets/image-20240403213540874.png)

结论：当两个数组指向同一个小空间时，其中一个数组对小空间中的值发生了改变，那么其他数组再次访问的时候都是修改之后的结果了。



---

# -----------------------------

# Day6 方法

# 63.方法

## 一、什么是方法？

**方法（method）是程序中最小的执行单元。**

之前在写HelloWorld案例的时候，框起来的叫main方法，也叫作主方法，main方法中两条输出语句肯定是不可以只输出一个的。

main方法中的两条代码是一起执行的，它并不能拆开，所以说方法是程序中最小的执行单元。

![image-20240403213759389](./assets/image-20240403213759389.png)

当然在代码当中，我们也可以自己定义一些其他的方法，同样的，方法里的代码要么全都一起执行，要么全都不执行。

----

## 二、方法的作用

如果有重复的代码，我们可以将代码进行打包，将打包起来的整体起个名字，例如叫做PlayGame，如果我想打一局游戏，就不需要将这些代码再写一遍了，直接调用打包好的整体就行了。如果要打两次游戏，只需要调用两次即可。这样就可以解决代码重复问题。而这个打大包起来的整体就是我们要学习的方法。

![image-20240403214916726](./assets/image-20240403214916726.png)

----

## 三、实际开发中方法的应用场景

例如植物大战僵尸，在这个游戏中，很多植物都是可以发子弹的。假设有个程序员在编写代码，第一个豌豆植物，发射子弹的代码写了20行。然后第二个植物寒冰射手，发射子弹的代码也写了20行，此时已经写了40行代码了。现在又出现了第三个植物，大头菜，想让它发射子弹还需要写20行代码。

<img src="./assets/image-20240404091346825.png" alt="image-20240404091346825" style="zoom:50%;" />

注意到，只要发射子弹，就需要写20行代码，这样代码的重复度太高。

一般我们会把相同的代码进行打包，把发射炮弹的二十行代码进行打包。如果当前的植物有发射的功能，此时重复的代码就不需要再写一遍了，直接去调用就可以了。假如此时又来了第四个植物，它也是有发射炮弹功能的，同样的重复代码也不需要再写，直接再次调用就行了。

<img src="./assets/image-20240404091614329.png" alt="image-20240404091614329" style="zoom:50%;" />

并且在以后，就算代码有问题，我们也只需要修改方法里面的代码，调用方法的地方是不需要修改的。

----

## 四、总结

**1、什么是方法？**

方法是程序中最小的执行单元。

**2、实际开发中，什么时候用到方法？**

重复的代码、具有独立功能的代码可以抽取到方法中。

**3、方法的好处**

- 提高代码的复用性
- 提高代码的可维护性



----

# 64.最简单的方法定义和调用

## 一、概念

方法就是把一些代码打包在一起，用到的时候就调用。

**方法定义**：把一些代码打包在一起，该过程称为方法定义。

**方法调用**：方法定义后并不是直接运行的，需要手动调用才能执行，该过程称为方法调用。

----

## 二、方法的定义格式

方法的定义是写在main方法外面，类的里面

~~~java
public static 返回值类型 方法名（参数） {
    方法体;
    return 返回值;
}
~~~

方法的定义格式只有一种，但是这种格式相对来讲比较复杂，所以为了让大家更好的吸收，我们会把这种格式拆成三部分，还有各自的调用方式，由浅入深的进行学习。

<img src="./assets/image-20240404092735460.png" alt="image-20240404092735460" style="zoom:50%;" />

----

## 三、最简单的方法定义格式

将打包起来的代码放入一个方法里，打包起来的整体我们称之为方法体。

在起方法名的时候要见名知意，遵循小驼峰命名。

定义格式：

```java
public static void 方法名 (   ) {
	// 方法体;
}
```

范例：

```java
public static void playGame (    ) {
	// 方法体;
}
```

调用格式：

```java
方法名();
```

范例：

```java
playGame();
```

注意：方法必须先定义，后调用，否则程序将报错

<img src="./assets/image-20240404093048196.png" alt="image-20240404093048196" style="zoom:67%;" />

----

## 四、无参数方法的练习

### 1）展示女朋友的信息

需求：定义一个方法，在方法内部打印你女朋友的所有信息。

~~~java
package com.itheima.methoddemo;

public class MethodDemo2 {
    public static void main(String[] args) {
        //目标：利用方法最简单的格式完成当前练习

        //调用方法
        printGFInfo();

    }

    public static void printGFInfo(){
        System.out.println("小惠惠");
        System.out.println("萌妹子");
        System.out.println("18岁");
    }
}
~~~

----

### 2）看代码说结果

目标：能说出方法调用时的执行过程。

程序在刚开始运行的时候肯定是从main方法的第一行代码开始运行的，所以首先打印a。

![image-20240404094646429](./assets/image-20240404094646429.png)

然后 method() 方法开始调用了，此时就需要进入到方法里面

![image-20240404100342363](./assets/image-20240404100342363.png)

执行完方法后，就需要回到调用处，继续往下执行，打印b。

![image-20240404100431455](./assets/image-20240404100431455.png)



----

# 65.带参数方法定义和调用

## 一、引入

当方法要计算的数据不明确的时候，就可以把参数定义在小括号中，在调用方法的时候根据实际情况来传入不同的值。

小括号中有几个，在调用的时候就必须传几个。多一个少一个都是不行的，它的个数和数据类型都要对应起来。

<img src="./assets/image-20240404100959332.png" alt="image-20240404100959332" style="zoom:50%;" />

----

## 二、带参数方法定义和调用

定义格式：

参数：由数据类型和变量名组成 -  数据类型 变量名

参数范例：int a

```java
public static void 方法名 (参数1) {
	方法体;
}

public static void 方法名 (参数1, 参数2, 参数3...) {
	方法体;
}
```

范例：

```java
public static void isEvenNumber(int number){
    ...
}
public static void getMax(int num1, int num2){
    ...
}
```

调用格式：

```java
方法名(参数)；

方法名(参数1,参数2);
```

范例：

```java
isEvenNumber(10);

getMax(10,20);
```

注意：方法调用时，参数的数量与类型必须与方法定义中小括号里面的变量一一对应，否则程序将报错。

----

## 三、代码示例

~~~java
package com.itheima.methoddemo;

public class MethodDemo4 {
    public static void main(String[] args) {
        //目标：掌握带参数方法定义的格式和调用的格式

        getSum(10,20);
    }

    public static void getSum(int num1, int num2){
        int result = num1 + num2;
        System.out.println(result);
    }
}
~~~

----

## 四、形参和实参

刚刚，我们将方法调用时里的值会叫做参数。下面方法定义时，小括号里写的，也会叫做参数。

![image-20240404101857696](./assets/image-20240404101857696.png)	![image-20240404101908152](./assets/image-20240404101908152.png)

这两个重复了，肯定不行，所以我们需要将它们俩分开，一个叫形参，另一个叫实参。

**形参**：方法定义中的参数。等同于变量定义格式，例如：int number

**实参**：方法调用中的参数。等同于使用变量或常量，例如： 10  number

例如我们刚刚的注意就可以简化了：方法调用时，形参和实参必须一一对应，否则程序将报错。

----

## 五、带参数方法练习

需求：定义一个方法，求长方形的周长，将结果在方法中进行打印。

```java
package com.itheima.test;

public class Test1 {
    public static void main(String[] args) {
        //目标：根据不同的需求，选择定义无参的方法，还是带参数的方法
        getLength(5.2,1.3);

    }

    //1.我要干嘛？求长方形的周长
    //2.我干这件事情，需要什么才能完成？长 宽
    public static void getLength(double len, double width){
        double result = (len + width) * 2;
        System.out.println(result);
    }
}
```

----

需求：定义一个方法，求圆的面积，将结果在方法中进行打印。

~~~java
package com.itheima.test;

public class Test2 {
    public static void main(String[] args) {
        //目标：根据不同的需求，选择定义无参的方法，还是带参数的方法

        getArea(1.5);
    }

    //1.我要干嘛？求圆的面积
    //2.我干这件事情，需要什么才能完成？ 半径的平方
    public static void getArea(double radius){
        double result = radius * radius * 3.14;
        System.out.println(result);
    }

}
~~~



-----

# 66.带返回值方法的定义和调用

## 一、引入

方法的返回值就是方法的最终运行结果。

调用处拿到方法的结果后，才能根据结果进行下一步操作。

- 如果在调用处要根据方法的结果，去编写另外一段代码逻辑。
- 为了在调用处拿到方法产生的结果，就需要定义带有返回值的方法。

---

## 二、定义格式

定义格式

```java
public static 数据类型 方法名 ( 参数 ) { 
	return 数据 ;
}
```

范例

```java
public static boolean isEvenNumber( int number ) {           
	return true ;
}
public static int getMax( int a, int b ) {
	return  100 ;
}
```

注意：方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错

调用格式

```java
// 1.直接调用
方法名 ( 参数 ) ; // 表示对返回值不做任何处理
// 2.赋值调用
数据类型 变量名 = 方法名 ( 参数 ) ; // 表示把方法运行的结果赋值给左边的变量
// 3.输出调用
System.out.println(方法名 (实参)); // 将方法的返回结果直接进行输出
```

范例

```java
isEvenNumber ( 5 ) ;
boolean  flag =  isEvenNumber ( 5 ); 
```

注意：方法的返回值通常会使用变量接收，否则该返回值将无意义

----

## 三、练习：人肉计算机

需求：定义一个方法，求一家商场每个季度的营业额。根据方法结果再算出全年营业额。

~~~java
package com.itheima.methoddemo;

public class MethodDemo5 {
    public static void main(String[] args) {
        //目标：掌握带返回值方法的定义和调用格式

        //直接调用，一般会用在没有返回值的方法中
        //getSum(10,20,30);

        //赋值调用，这个是
        //int sum = getSum(10,20,30);
        //System.out.println(sum);

        //输出调用
        //System.out.println(getSum(10,20,30));


        //先计算第一个季度的营业额
        int sum1 = getSum(10,20,30);
        //再来计算第二个季度的营业额
        int sum2 = getSum(20,30,40);
        //计算第三个季度的营业额
        int sum3 = getSum(20,30,40);
        //计算第四个季度的营业额
        int sum4 = getSum(20,30,40);

        //求全年的总营业额
        int sum = sum1 + sum2 + sum3 + sum4;

        System.out.println(sum);
    }

    public static int getSum(int num1,int num2,int num3){
        int result = num1 + num2 + num3;
        return result;//返回给方法的调用处
    }
}
~~~

----

## 四、练习：比较两个长方形的面积

需求：定义方法，比较两个长方形的面积

~~~java
package com.itheima.test;

public class Test3 {
    public static void main(String[] args) {
        //目标：要能区分出什么时候使用带返回值的方法

        //调用方法获取长方形的面积，再进行比较
        double area1 = getArea(5.3, 1.7);
        double area2 = getArea(2.4, 2.7);

        if(area1 > area2){
            System.out.println("第一个长方形更大");
        }else{
            System.out.println("第二个长方形更大");
        }
    }


    //1.我要干嘛？比较两个长方形的面积
    //2.需要什么？两个长 两个宽
/*    public static void compare(double len1, double width1, double len2, double width2){
        double area1 = len1 * width1;
        double area2 = len2 * width2;

        if(area1 > area2){
            System.out.println("第一个长方形更大");
        }else{
            System.out.println("第二个长方形更大");
        }
    }*/
    
    
    //在以后实际开发当中，我们一般是把重复的代码或者具有独立功能的代码抽取到方法当中。
    //以后我们直接调用就可以了
    //定义一个方法求长方形的面积
    //1.我要干嘛？求长方形的面积
    //2.需要什么？长 和 宽
    //3.方法的调用处，是否需要继续使用方法的结果。
    //如果要用，那么方法必须有返回值
    //如果不要用，方法可以写返回值，也可以不写返回值。
    public static double getArea(double len, double width){
        double area = len * width;
        return area;
    }
}
~~~



----

# 67.方法的小结

## 一、方法的完整写法

方法名需要见名知意，采用小驼峰命名。

```java
public static 返回值类型 方法名(参数) {
   方法体; 
   return 数据 ;
}
```

----

##  二、方法的注意事项

### 1）方法不调用就不执行

---

### 2）方法与方法之间是平级关系，方法不能嵌套定义

方法与方法之间是平级关系：即方法在定义的时候是没有上下顺序的，我们甚至可以把自己写的代码定义在main方法上面。只不过为了程序阅读性，第一个一般都是main方法，表示程序的出入口，下面才是我们自己写的方法。

![image-20240404105059387](./assets/image-20240404105059387.png)

方法不能嵌套定义，示例代码：

```java
public class MethodDemo {
    public static void main(String[] args) {

    }

    public static void methodOne() {
		public static void methodTwo() {
       		// 这里会引发编译错误!!!
    	}
    }
}
```

----

### 3）方法的编写顺序和执行顺序是没有关系的

方法的编写顺序和执行顺序是没有关系的，执行顺序看的应该是调用顺序，谁先调用谁就先执行。

<img src="./assets/image-20240404105226241.png" alt="image-20240404105226241" style="zoom: 67%;" />

---

### 4）void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据

示例代码：

```java
public class MethodDemo {
    public static void main(String[] args) {

    }
    public static void methodTwo() {
        //return 100; 编译错误，因为没有具体返回值类型
        return;	// 后面不加数据
    }
}
```

---

### 5）return后面不能编写其他代码

return语句下面，不能编写代码，因为永远执行不到，属于无效的代码。

~~~java
public class MethodDemo {
    public static void main(String[] args) {

    }
    public static void methodTwo() {
        return;	 // return表示结束方法，方法都结束了，下面的代码肯定执行不到了 
        System.out.println(100); // 这里会报错
    }
}
~~~

----

## 三、return关键字

1、方法没有返回值：可以省略不写。如果书写，表示结束方法。

2、方法又返回值：return必须要写。表示结束方法和返回结果。



----

# 68.方法的重载

## 一、引入

如下图，相似的需求每个方法名却都不相同，这样对取名的人和调用方法的人都很困扰。因为调用的人还需要查清楚方法名叫什么他才能调用。

![image-20240404110712270](./assets/image-20240404110712270.png)

所以Java为了减轻我们的痛苦，它做了一个规定：这些相同功能的方法可以取同一个名字，都可以叫做sum，但是方法的形参不能一样，这个就叫做方法的重载。

![image-20240404110936925](./assets/image-20240404110936925.png)

----

## 二、概念

方法重载概念：方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载

- 在同一个类中，定义了多个同名的方法，这些同名的方法具有同种的功能。
- 每个方法具有不同的参数类型或参数个数，这些同名的方法，就构成了重载关系。

**简单记：同一个类中，方法名相同，参数不同的方法。与返回值无关**

参数不同：个数不同、类型不同、顺序不同

> 顺序不同可以构成重载，但是不建议！

示例：下面这两个方法是构成重载关系的。1、在同一个类里，并且方法名相同；2、参数不一样（上面有两个参数，下面有三个参数）

<img src="./assets/image-20240404111610165.png" alt="image-20240404111610165" style="zoom:67%;" />

我们在调用方法的时候，Java虚拟机会 **通过参数的不同** 来区分 **同名的方法**。这个就对应了我们之前学的一个知识点：在调用方法的时候，实参要和形参一一对应。

![image-20240404112223688](./assets/image-20240404112223688.png)

----

## 三、代码示例

正确范例

```java
public class MethodDemo {
	public static void fn(int a) {
    	//方法体
    }
    public static int fn(double a) {
    	//方法体
    }
}

public class MethodDemo {
	public static float fn(int a) {
    	//方法体
    }
    public static int fn(int a , int b) {
    	//方法体
    }
}

public class MethodDemo { // 形参顺序不同
	public static int fn(int a , double b) {
    	//方法体
    }
    public static int fn(double a , int b) {
    	//方法体
    }
}
```

错误范例

```java
public class MethodDemo {
	public static void fn(int a) {
    	//方法体
    }
    public static int fn(int a) { 	/*错误原因：重载与返回值无关*/
    	//方法体
    }
}

public class MethodDemo01 {
    public static void fn(int a) {
        //方法体
    }
} 
public class MethodDemo02 {
    public static int fn(double a) { /*错误原因：这是两个类的两个fn方法*/
        //方法体
    }
}
```

---

## 四、方法重载练习

需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long） 

> PS：IDEA中，定义一个变量 / 方法没有被用到，就会是灰色的

代码：

```java
public class MethodTest {
    public static void main(String[] args) {
        //调用方法
        System.out.println(compare(10, 20));
        System.out.println(compare((byte) 10, (byte) 20)); // 值不能写10，因为整数默认是int类型，如果需要变成byte类型，需要做一个强转。
        System.out.println(compare((short) 10, (short) 20));
        System.out.println(compare(10L, 20L));
    }

    //把相同功能的方法名起成一样的名字
    //好处1：定义方法的时候可以不用那么多的单词了
    //好处2：调用方法的时候也不需要那么麻烦了。
    //int
    public static boolean compare(int a, int b) {
        System.out.println("int");
        return a == b;
    }

    //byte
    public static boolean compare(byte a, byte b) {
        System.out.println("byte");
        return a == b;
    }

    //short
    public static boolean compare(short a, short b) {
        System.out.println("short");
        return a == b;
    }

    //long
    public static boolean compare(long a, long b) {
        System.out.println("long");
        return a == b;
    }

}
```

----

# 69.方法的三个练习

## 一、数组遍历

需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] 

代码：

```java
public class Test1 {
    public static void main(String[] args) {
      /*  //先打印数据，再进行换行
        System.out.println("aaa");
        //只打印不换行
        System.out.print("bbb");
        System.out.print("ddd");
        //不打印任何内容，只换行
        System.out.println();
        System.out.print("cc");*/
        //设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55]
        int[] arr = {1,2,3,4,5};
        printArr(arr);
    }
    
    //定义方法用于数组的遍历
    //1.我要遍历数组
    //2.需要什么？  数组
    //3.调用处是否需要使用方法的结果。 不需要返回值
    public static void printArr(int[] arr){
        System.out.print("[");
        for (int i = 0; i < arr.length; i++) {
            if(i == arr.length - 1){
                System.out.println(arr[i]);
            }else{
                System.out.print(arr[i] + ", ");
            }
        }
        System.out.print("]");
    }
}
```

---

## 二、数组最大值

需求：设计一个方法用于获取数组中元素的最大值 

代码：

```java
public class MethodTest02 {
    public static void main(String[] args) {
        //定义一个数组，用静态初始化完成数组元素初始化
        int[] arr = {12, 45, 98, 73, 60};

        //调用获取最大值方法，用变量接收返回结果
        int number = getMax(arr);

        //把结果输出在控制台
        System.out.println("number:" + number);
    }

    //定义一个方法，用来获取数组中的最大值
    /*
        两个明确：
            返回值类型：int
            参数：int[] arr
     */
    public static int getMax(int[] arr) {
        int max = arr[0];

        for(int x=1; x<arr.length; x++) {
            if(arr[x] > max) {
                max = arr[x];
            }
        }
        return max;
    }
}
```

-----

## 三、return 和 break关键字的区别

return：跟循环没有什么关系，跟方法有关，表示1、结束方法；2、返回结果。如果方法执行到return，那么整个方法全部结束，里面的循环也会随之结束。

break：跟方法没有什么关系，是用来结束循环或者switch的。

~~~java
// 需求：判断 number 是否存在
public static boolean contains(int[] arr, int number) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == number) {
            // 这里用return就很好
            return true;
        }
    }
    return false;
}
~~~



----

# 70.拷贝数组

需求：定义一个方法 `copyOfRange(int[] arr, int from, int to)`。

功能：将数组arr中从索引from（包含from）开始。到索引to结束（不包含to）的元素复制到新数组中，将新数组返回。

![image-20240404115608787](./assets/image-20240404115608787.png)



----

# 71.方法的基本内存原理

## 一、回顾

之前我们曾经讲过，每款软件在运行的时候都会占用一块内存区域。Java也不例外，在运行的时候虚拟机也会占用一块内存空间，只不过为了更好的利用这块空间，JVM虚拟机会把它分成5个部分。每个部分都有其各自的作用。

![image-20240404125855146](./assets/image-20240404125855146.png)

目前我们只需要掌握栈和堆即可

![image-20240404125930700](./assets/image-20240404125930700.png)

----

## 二、方法调用的基本内存原理

以下代码由于没有new，所以这里用不到堆，我们只需要暂时去关注栈就行了。

![image-20240404125959003](./assets/image-20240404125959003.png)

这里面只有一个main方法，main方法被调用后就会进栈运行。然后从上往下执行里面的第一行代码。

![image-20240404130248221](./assets/image-20240404130248221.png)

第一行代码是定义了一个变量，所以在main方法里面就会有一个小空间，给这个小空间起个名字叫：number，并给它做了一个 `int` 类型的限定，表示这块小空间以后只能存储 `int类型` 的整数。这就是变量。`100` 就是真实存储在小空间的值。

![image-20240404130535359](./assets/image-20240404130535359.png)

往下就是输出number的值，number里面记录多少，它就打印多少。

当输出语句打印完后，方法中所有语句都执行完后，方法就需要出栈，变量也会随之消失。

----

## 三、方法在栈的流程

方法在栈里的运行过程是 `先进后出`。

假设我现在有三个方法，第一次使用的是方法一，所以方法一就要进到栈里。

![image-20240404131323907](./assets/image-20240404131323907.png)

然后我调用方法二，方法二就要进去，压在方法一身上。

![image-20240404131336082](./assets/image-20240404131336082.png)

最后调用方法三，方法三就压在了最上面。

![image-20240404131347111](./assets/image-20240404131347111.png)

当要出去的时候，就是上面的最先出去，即方法三。

![image-20240404131513287](./assets/image-20240404131513287.png)

然后再是方法二出去。

![image-20240404131528002](./assets/image-20240404131528002.png)

最后是方法一出去。

![image-20240404131539010](./assets/image-20240404131539010.png)

示例解析图

![image-20240404131710730](./assets/image-20240404131710730.png)



---

# 72.方法传递基本数据类型的内存原理

## 一、基本数据类型

内存图：变量中存储的是真实的数据

![image-20240404132428203](./assets/image-20240404132428203.png)

----

## 二、引用数据类型

此时变量arr中记录的并不是真实的数据 `123`，而是记录其他空间的地址值。

如果我们想要获取数组中的数据，只能通过arr找到右边的数组，再通过索引去获取数据。

所以当一个变量中存储的不是真实的数据，而是其他空间的地址值的时候，这个变量我们就会称之为叫做：引用数据类型。

![image-20240404132834661](./assets/image-20240404132834661.png)

所以引用数据类型变量中存储的是地址值。引用：使用了其他空间中的数据。

----

## 三、总结

从内存的角度解释基本数据类型和引用数据类型的区别：

- 基本数据类型：数据值是存储在自己的空间中的

  特点：赋值给其他变量，也是赋的真实的值。如下图，变量b进行了修改，是不会影响变量a中的值的。

  ![image-20240404133120619](./assets/image-20240404133120619.png)

- 引用数据类型：数据值是存储在其他空间中的，自己空间中存储的是地址值

  特点：赋值给其他变量，赋的是地址值

  ![image-20240404133225134](./assets/image-20240404133225134.png)

  由于赋的是地址值，所以现在两个变量指向了同一块空间，在这种情况下，不管是arr1还是arr2对右侧数据发生改变，另外一个再访问的时候就是修改之后的结果了。

  ![image-20240404133209080](./assets/image-20240404133209080.png)

-----

# 73.方法的值传递

## 一、传递基本数据类型

一开始main方法先进栈，然后定义一个变量number。然后打印number，打印的肯定是number中记录的值：100。

接着调用change方法。就会将change方法加载到栈中。在调用的时候，change方法中也有一个变量number，它记录的就是当前传递过来的100，它记录的也是100；

![image-20240404142107357](./assets/image-20240404142107357.png)

再往下执行change里面的代码，将200赋值给number，它其实就是将这个200赋值给了change方法中的200。

但它并不会影响main方法中的number，因为变量是有作用范围的，变量只能在所属的范围中有效。

![image-20240404142221548](./assets/image-20240404142221548.png)

change方法中的代码都执行完了，此时change方法就需要出栈。然后继续往下执行，继续打印number，这个number还是100。

![image-20240404142444626](./assets/image-20240404142444626.png)

打印完毕后，main方法中所有代码都执行完了，所以main方法也需要出栈。

结论：传递基本数据类型时，传递的是真实的数据，形参的改变不影响实际参数的值。



---

## 二、传递引用数据类型

![image-20240404142647893](./assets/image-20240404142647893.png)

实参传递给形参的时候，赋值过去的是地址值，因此，change方法执行的时候，形参和实参指向的是同一块空间。

![image-20240404142813499](./assets/image-20240404142813499.png)

在change方法中修改1索引后。main方法中arr的索引1自然也会发生改变。

![image-20240404143047559](./assets/image-20240404143047559.png)

索引1的值就是修改后的200了。

![image-20240404142658429](./assets/image-20240404142658429.png)

结论：传递引用数据类型时，传递的是地址值，形参的改变，会影响实际参数的值。

----

## 三、结论

![image-20240404143149897](./assets/image-20240404143149897.png)



----

# -------------------------------

# Day7 综合练习

# 74.飞机票和打印素数

## 练习一：飞机票

需求:

​	机票价格按照淡季旺季、头等舱和经济舱收费、输入机票原价、月份和头等舱或经济舱。

​	按照如下规则计算机票价格：旺季（5-10月）头等舱9折，经济舱8.5折，淡季（11月到来年4月）头等舱7折，经济舱6.5折。

代码示例：

```java
package com.itheima.test;

import java.util.Scanner;

public class Test1 {
    public static void main(String[] args) {
        /* 机票价格按照淡季旺季、头等舱和经济舱收费、输入机票原价、月份和头等舱或经济舱。
        按照如下规则计算机票价格：旺季（5-10月）头等舱9折，经济舱8.5折，淡季（11月到来年4月）头等舱7折，经济舱6.5折。*/

        //分析：
        //1.键盘录入机票原价、月份、头等舱或经济舱
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入机票的原价");
        int ticket = sc.nextInt();
        System.out.println("请输入当前的月份");
        int month = sc.nextInt();
        System.out.println("请输入当前购买的舱位 0 头等舱 1 经济舱"); // 不能使用 true / false，因为之后有可能还需要加商务舱
        int seat = sc.nextInt();
        //2.先判断月份是旺季还是淡季
        //IDEA快捷键：ctrl + alt + M 自动抽取方法 首先选中要抽取的代码，然后按住快捷键
        if (month >= 5 && month <= 10) {
            //旺季 //3.继续判断当前机票是经济舱还是头等舱
            //ticket = getPrice(ticket, seat, 0.9, 0.85);
            ticket = getTicket(ticket, seat, 0.9, 0.85);
        } else if ((month >= 1 && month <= 4) || (month >= 11 && month <= 12)) {
            //淡季
            //ticket = getPrice(ticket, seat, 0.7, 0.65);
            ticket = getTicket(ticket, seat, 0.7, 0.65);
        } else {
            //表示键盘录入的月份是一个非法数据
            System.out.println("键盘录入的月份不合法");
        }

        System.out.println(ticket);
    }

    public static int getTicket(int ticket, int seat, double v, double v2) {
        if (seat == 0) {
            //头等舱
            ticket = (int) (ticket * v); // ticket * v 得到的是一个小数，结果得到的小数赋值给一个整数需要进行强转
        } else if (seat == 1) {
            //经济舱
            ticket = (int) (ticket * v2);
        } else {
            System.out.println("没有这个舱位");
        }
        return ticket;
    }

    //1.我要干嘛？根据舱位和折扣来计算最终的票价
    //2.我干这件事，需要什么才能完成？原价 舱位 头等舱的折扣 经济舱的折扣
    //3.方法的调用处是否需要继续使用这个结果  需要
    /*  public static int getPrice(int ticket, int seat, double v0, double v1) {
        if (seat == 0) {
            //头等舱
            ticket = (int) (ticket * v0);
        } else if (seat == 1) {
            //经济舱
            ticket = (int) (ticket * v1);
        } else {
            System.out.println("没有这个舱位");
        }
        return ticket;
    }*/
}
```

----

## 二、IDEA抽取方法快捷键

IDEA快捷键：ctrl + alt + M 自动抽取方法 首先选中要抽取的代码

![image-20240404145510683](./assets/image-20240404145510683.png)

然后按住快捷键 <kbd>ctrl + alt + M</kbd>

之后会弹出一个页面，说收取完后还有重复的代码，是否要一起抽取，点击 `Accept Signature Change` 即可。

![image-20240404150350807](./assets/image-20240404150350807.png)

接下来又会有一个提示：这段重复代码要不要用调用方法的形式去调用，必须的噻，所以点击 `Replace`

![image-20240404150303976](./assets/image-20240404150303976.png)

-----

## 练习二：打印素数

判断101~200之间有多少个素数，并输出所有素数。

备注：素数就是质数

代码示例：

```java
package com.itheima.test;

public class Test2 {
    public static void main(String[] args) {
        //判断 101 ~ 200 之间有多少个素数，并打印所有素数

        //思路一： 2 ~ 99
        //定义变量i ，赋值100
        //判断i是否为质数

        //定义一个变量用来统计有多少个质数
        int count = 0;
        //外循环：遍历101~200这个范围，依次得到这个范围之内的每一个数字
        for (int i = 101; i <= 200; i++) {
            //i 依次表示循环中的每一个数字
            //继续判断i是否为一个质数
            boolean flag = true;
            //内循环:判断当前数字是否为一个质数。
            for (int j = 2; j < i; j++) {
                //j 表示2~99之间的每一个数字
                if(i % j == 0){
                    flag = false;
                    //跳出单层循环，即内循环
                    break;
                }
            }
            if(flag){
                System.out.println("当前数字"+i+"是质数");
                count++;
            }
        }

        System.out.println("一共有" + count + "个质数");

        /* int i = 7;
        boolean flag = true;
        for (int j = 2; j < i; j++) {
            //j 表示2~99之间的每一个数字
            if(i % j == 0){
                flag = false;
                break;
            }
        }
        if(flag){
            System.out.println("当前数字是质数");
        }else{
            System.out.println("当前数字不是一个质数");
        }*/
    }
}

```

----

# 75.开发验证码和数组元素的复制

## 一、开发验证码

需求：定义方法实现随机产生一个5位的验证码

验证码格式：长度为5，前四位是大写字母或者小写字母，最后一位是数字

代码示例：

```java
package com.itheima.test;

import java.util.Random;

public class Test3 {
    public static void main(String[] args) {
        /*   需求：
            定义方法实现随机产生一个5位的验证码
            验证码格式：
            长度为5
            前四位是大写字母或者小写字母
            最后一位是数字
     */

        //方法：
        //在以后如果我们要在一堆没有什么规律的数据中随机抽取
        //可以先把这些数据放到数组当中
        //再随机抽取一个索引

        //分析：
        //1.大写字母和小写字母都放到数组当中
        char[] chs = new char[52];
        for (int i = 0; i < chs.length; i++) {
            //ASCII码表
            if(i <= 25){
                //添加小写字母
                chs[i] = (char)(97 + i);
            }else{//27
                //添加大写字母
                // A --- 65
                chs[i] = (char)(65 + i - 26);
            }
        }

        //定义一个字符串类型的变量，用来记录最终的结果
        String result = "";

        //2.随机抽取4次
        //随机抽取数组中的索引
        Random r = new Random();
        for (int i = 0; i < 4; i++) {
            int randomIndex = r.nextInt(chs.length);
            //利用随机索引，获取对应的元素
            //System.out.println(chs[randomIndex]);
            result = result + chs[randomIndex];
        }
        //System.out.println(result);
        //3.随机抽取一个数字0~9
        int number = r.nextInt(10);
        //生成最终的结果
        result = result + number;

        //打印最终结果
        System.out.println(result);
    }
}
```

-----

## 二、复制数组

需求：把一个数组中的元素复制到另一个新数组中去。

代码示例：

```java
package com.itheima.test;

public class Test4 {
    public static void main(String[] args) {
        /* 需求：
        把一个数组中的元素复制到另一个新数组中去。*/

        //分析：
        //1.定义一个老数组并存储一些元素
        int[] arr = {1,2,3,4,5};
        //2.定义一个新数组的长度跟老数组一致
        int[] newArr = new int[arr.length];
        //3.遍历老数组，得到老数组中的每一个元素，依次存入到新数组当中
        for (int i = 0; i < arr.length; i++) {
            //i 表示老数组中的索引。新数组中的每一个索引
            //arr[i]  表示老数组中的元素
            newArr[i] = arr[i];
        }

        //4.新数组中已经存满元素了
        for (int i = 0; i < newArr.length; i++) {
            System.out.println(newArr[i]);
        }
    }
}
```



-----

# 76.评委打分

需求 :  在唱歌比赛中，有6名评委给选手打分，分数范围是[0 - 100]之间的整数。选手的最后得分为：去掉最高分、最低分后的4个评委的平均分，请完成上述过程并计算出选手的得分。

代码示例：

```java
package com.itheima.test;

import java.util.Scanner;

public class Test5 {
    public static void main(String[] args) {
        //在唱歌比赛中，有6名评委给选手打分，分数范围是[0 - 100]之间的整数。
        // 选手的最后得分为：去掉最高分、最低分后的4个评委的平均分，请完成上述过程并计算出选手的得分。


        //分析：
        //1.定义一个数组，用来存储6名评委的打分（0~100）
        int[] scoreArr = getScores();
        for (int i = 0; i < scoreArr.length; i++) {
            System.out.println(scoreArr[i]);
        }
        //2.求出数组中的最大值
        int max = getMax(scoreArr);
        //3.求出数组中的最小值
        int min = getMin(scoreArr);
        //4.求出数组中6个分数的总和
        int sum = getSum(scoreArr);
        //5.（总和 - 最大值 - 最小值 ）/4
        int avg =  (sum - max - min)/(scoreArr.length - 2); // scoreArr.length - 2：值能不写死就不写死 
        //6.打印结果
        System.out.println("选手的最终得分为：" + avg);
    }

    public static int getSum(int[] scoreArr){
        int sum = 0;
        for (int i = 0; i < scoreArr.length; i++) {
            sum = sum + scoreArr[i];
        }
        return  sum;

    }


    //求数组的最大值
    public static int getMax(int[] scoreArr){
        int max = scoreArr[0];
        for (int i = 1; i < scoreArr.length; i++) {
            if(scoreArr[i] > max){
                max = scoreArr[i];
            }
        }
        return max;
    }

    //求数组的最小值
    // 这个方法直接复制粘贴max方法即可，然后进行变量max的批量替换，变成min
    public static int getMin(int[] scoreArr){
        // 变量批量替换的快捷键：shift + F6
        int min = scoreArr[0];
        for (int i = 1; i < scoreArr.length; i++) {
            if(scoreArr[i] < min){
                min = scoreArr[i];
            }
        }
        return min;
    }


    //1.我要干嘛？定义一个数组，用来存储6名评委的打分（0~100）
    //2.我需要什么？都不需要
    //3.干完了这件事情，是否需要返回？必须返回
    public static int[] getScores(){
        //定义数组
        int[] scores = new int[6];
        //使用键盘录入的形式，输入分数：0~100
        Scanner sc = new Scanner(System.in);
        for (int i = 0; i < scores.length; ) {
            System.out.println("请输入评委的打分");
            int score = sc.nextInt();//100
            // 难点1：需要对范围进行判断
            if(score >=0 && score<= 100){
                scores[i] = score;
                i++;
            }else{
                System.out.println("成绩超出了范围,继续录入，当前的i为：" + i);
            }
        }
        return  scores;
    }
}
```

----

# 77.数字加密和解密

## 一、数字加密

需求：某系统的数字密码（大于0），比如1983，采用加密方式进行传输。

规则如下：先得到每位数，然后每位数都加上5 , 再对10求余，最后将所有数字反转，得到一串新数。

举例：

```java
		1	9	8	3
+5		6   14  13   8
%10		6   4   3    8
反转	   8   3   4    6
加密后的结果就是：8346
```

代码示例：当我们要对一个数字批量操作时，一般会将数字的每一位都先放到一个数组中

```java
package com.itheima.test;

public class Test6 {
    public static void main(String[] args) {
        /*
        某系统的数字密码（大于0）。比如1983，采用加密方式进行传输，
        规则如下：
            每位数加上5
            再对10求余，
            最后将所有数字反转，
            得到一串新数。
*/


        //分析：
        //1.把整数里面的每一位放到数组当中
        int[] arr = {1, 9, 8, 3};
        //2.加密
        //每位数加上5
        for (int i = 0; i < arr.length; i++) {
            arr[i] = arr[i] + 5;
        }
        //再对10求余，
        for (int i = 0; i < arr.length; i++) {
            arr[i] = arr[i] % 10;
        }
        //将所有数字反转
        for (int i = 0, j = arr.length - 1; i < j; i++, j--) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        //8 3 4 6 --> 8346
        //3.把数组里面的每一个数字进行拼接，变成加密之后的结果
        int number = 0;
        for (int i = 0; i < arr.length; i++) {
            number = number * 10 + arr[i];
        }
        System.out.println(number);
    }
}
```

---

## 扩展：把整数上的每一位都添加到数组当中

```java
package com.itheima.test;

public class Test7 {
    public static void main(String[] args) {
        //需求：
        //把整数上的每一位都添加到数组当中
        //反向推导


        //1.计算出数组的长度
        int number = 12345;
        //定义一个变量临时记录number的值，就是为了第三步的时候再次使用
        int temp = number;
        //定义一个变量进行统计
        int count = 0;
        while(number != 0){
            //每一次循环就去掉右边的一个数字
            number = number / 10;
            //去掉一位计数器就自增一次。
            count++;
        }
        //2.定义数组
        //动态初始化
        int[] arr = new int[count];
        //3.把整数上的每一位都添加到数组当中
        int index = arr.length -1;
        while(temp != 0){//12345
            //获取temp里面的每一位数组
            int ge = temp % 10;
            //再去掉右边的那位数字
            temp = temp / 10;
            //把当前获取到的个位添加到数组当中
            arr[index] = ge;
            index--;
        }
        //验证结果  1  2  3  4 5
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }
}
```

---

## 二、数字解密

把上一题加密之后的数据进行解密

> 难点：`%10` 如何反过来？这个需要结合前面的 `+5` 来看。
>
> 每位的位数范围在 `0 ~ 9`，`+5` 后范围在 `5 ~ 14`，取余后，`5 ~ 9` 就是本身，而 `10 ~ 15` 取余后去掉了一个10。
>
> 因此在还原的时候，如果是 `0 ~ 4` 之间的数字，就需要将这个10补回来。
>
> ![image-20240404160314467](./assets/image-20240404160314467.png)

代码示例：

```java
package com.itheima.test;

public class Test8 {
    public static void main(String[] args) {
        /*某系统的数字密码（大于0）。比如1983，采用加密方式进行传输，
        规则如下：
            每位数加上5
            再对10求余，
            最后将所有数字反转，
            得到一串新数。
            按照以上规则进行解密：
            比如1983加密之后变成8346，解密之后变成1983
        */


        //1.定义数组记录解密之后的结果
        int[] arr = {8, 3, 4, 6};
        //2.反转
        for (int i = 0, j = arr.length - 1; i < j; i++, j--) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        //3.由于加密是通过对10取余的方式进行获取的
        //所以在解密的时候就需要判断，0~4之间+10  5~9数字不变
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] >= 0 && arr[i] <= 4) {
                arr[i] = arr[i] + 10;
            }
        }
        //4.每一位减5
        for (int i = 0; i < arr.length; i++) {
            arr[i] = arr[i] - 5;
        }
        //5.获取数组里面的每一位数字拼接成最终的结果
        int number = 0;
        for (int i = 0; i < arr.length; i++) {
            number = number * 10 + arr[i];
        }
        System.out.println(number);
    }
}
```



----

# 78.抽奖

需求：一个大V直播抽奖，奖品是现金红包，分别有{2, 588 , 888, 1000, 10000}五个奖金。请使用代码模拟抽奖，打印出每个奖项，奖项的出现顺序要随机且不重复。打印效果如下：（随机顺序，不一定是下面的顺序）

```java
888元的奖金被抽出
588元的奖金被抽出
10000元的奖金被抽出
1000元的奖金被抽出
2元的奖金被抽出
```

## 解法一：重新定义一个数组

解决重复问题：重新定义一个数组，如果已经抽取到了，就将它添加到新的数组中去，用来记录。

```java
package com.itheima.test;

import java.util.Random;

public class Test9 {
    public static void main(String[] args) {
        /* 需求：
        一个大V直播抽奖，奖品是现金红包，分别有{2, 588 , 888, 1000, 10000}五个奖金。
        请使用代码模拟抽奖，打印出每个奖项，奖项的出现顺序要随机且不重复。
        打印效果如下：（随机顺序，不一定是下面的顺序）
            888元的奖金被抽出
            588元的奖金被抽出
            10000元的奖金被抽出
            1000元的奖金被抽出
            2元的奖金被抽出
        */


        //分析：
        //1.定义数组表示奖池
        int[] arr = {2, 588, 888, 1000, 10000};
        //2.定义新数组用于存储抽奖的结果
        int[] newArr = new int[arr.length];
        //3.抽奖
        Random r = new Random();
        //因为有5个奖项，所以这里要循环5次
        for (int i = 0; i < 5; ) {
            //获取随机索引
            int randomIndex = r.nextInt(arr.length);
            //获取奖项
            int prize = arr[randomIndex];
            //判断当前的奖项是否存在，如果存在则重新抽取，如果不存在，就表示是有效奖项
            boolean flag = contains(newArr, prize);
            if(!flag){
                //把当前抽取到的奖项添加到newArr当中
                newArr[i] = prize;
                //添加完毕之后，移动索引
                i++;
            }
        }
        //4.遍历newArr
        for (int i = 0; i < newArr.length; i++) {
            System.out.println(newArr[i]);
        }


    }

    //判断prize在数组当中是否存在
    //存在：true
    //不存在：false
    public static boolean contains(int[] arr,int prize){
        for (int i = 0; i < arr.length; i++) {
            if(arr[i] == prize){
                return true;
            }
        }
        return false;
    }
}
```

---

## 解法二：先将奖池先打乱

```java
package com.itheima.test;

import java.util.Random;

public class Test10 {
    public static void main(String[] args) {
       /* 需求：
        一个大V直播抽奖，奖品是现金红包，分别有{2, 588 , 888, 1000, 10000}五个奖金。
        请使用代码模拟抽奖，打印出每个奖项，奖项的出现顺序要随机且不重复。
        打印效果如下：（随机顺序，不一定是下面的顺序）
            888元的奖金被抽出
            588元的奖金被抽出
            10000元的奖金被抽出
            1000元的奖金被抽出
            2元的奖金被抽出
        */

        //1.把奖池里面的所有奖项打乱顺序
        int[] arr = {2, 588, 888, 1000, 10000};
        Random r = new Random();
        for (int i = 0; i < arr.length; i++) {
            //获取随机索引
            int randomIndex = r.nextInt(arr.length);
            //拿着i跟随机索引randomIndex上的值进行交换
            int temp = arr[i];
            arr[i] = arr[randomIndex];
            arr[randomIndex] = temp;
        }
        //2.遍历奖池,从0索引开始获取每一个奖项
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }


    }
}
```



---

# 79.双色球

规则：投注的号码是分为两部分的，一个是红球号码，另一个是蓝球号码。红球号码是从 `1 ~ 33` 之间选择的，蓝球号码是从 `1 ~ 16` 之间选择的。根据中奖的个数就可以断定中的是几等奖。

 ![图片1](./assets/图片1-1712212458332-1.png)



代码示例:

```java
package com.itheima.test;

import java.util.Random;
import java.util.Scanner;

public class Test11 {
    public static void main(String[] args) {
        //1.生成中奖号码
        int[] arr = createNumber(); // 123456  7

        System.out.println("=======================");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }

        System.out.println("=======================");



        //2.用户输入彩票号码（红球 + 蓝球）//654321
        int[] userInputArr = userInputNumber();

        //3.判断用户的中奖情况
        //红球 蓝球
        int redCount = 0;
        int blueCount = 0;

        //判断红球
        for (int i = 0; i < userInputArr.length - 1; i++) {
            int redNumber = userInputArr[i];
            for (int j = 0; j < arr.length - 1; j++) {
                if(redNumber == arr[j]){
                    redCount++;
                    //如果找到了，那么后面的数字就没有必要继续比较了
                    //跳出内循环，继续判断下一个红球号码是否中奖
                    break;
                }
            }
        }

        //判断蓝球
        int blueNumber = userInputArr[userInputArr.length-1];
        if(blueNumber == arr[arr.length - 1]){
            blueCount++;
        }

        //根据红球的个数以及蓝球的个数来判断中奖情况
        if(redCount == 6 && blueCount == 1){
            System.out.println("恭喜你，中奖1000万");
        }else if(redCount == 6 && blueCount == 0){
            System.out.println("恭喜你，中奖500万");
        }else if(redCount == 5 && blueCount == 1){
            System.out.println("恭喜你，中奖3000");
        }else if((redCount == 5 && blueCount == 0) ||  (redCount == 4 && blueCount == 1)){
            System.out.println("恭喜你，中奖200");
        }else if((redCount == 4 && blueCount == 0) ||  (redCount == 3 && blueCount == 1)){
            System.out.println("恭喜你，中奖10");
        }else if((redCount == 2 && blueCount == 1) ||  (redCount == 1 && blueCount == 1)|| (redCount == 0 && blueCount == 1)){
            System.out.println("恭喜你，中奖5");
        }else{
            System.out.println("谢谢参与，谢谢惠顾");
        }
    }

    public static int[] userInputNumber() {
        //1.创建数组用于添加用户购买的彩票号码
        //6个红球 1个蓝球 数组长度：7
        int[] arr = new int[7];

        //2.利用键盘录入让用输入
        Scanner sc = new Scanner(System.in);
        //让用户输入红球号码
        for (int i = 0; i < 6; ) {
            System.out.println("请输入第" + (i + 1) + "个红球号码");
            int redNumber = sc.nextInt();
            //redNumber  在1~33  唯一不重复
            if (redNumber >= 1 && redNumber <= 33) {
                boolean flag = contains(arr, redNumber);
                if (!flag) {
                    //不存在
                    //有效的，可以添加到数组当中
                    arr[i] = redNumber;
                    i++;
                } else {
                    //存在
                    System.out.println("当前红球号码已经存在，请重新输入");
                }
            } else {
                System.out.println("当前红球号码超出范围");
            }
        }

        //让用户输入篮球号码
        System.out.println("请输入篮球号码");
        //1~16
        while (true) {
            int blueNumber = sc.nextInt();
            if (blueNumber >= 1 && blueNumber <= 16) {
                arr[arr.length - 1] = blueNumber;
                break;
            } else {
                System.out.println("当前篮球号码超出范围");
            }
        }
        return arr;

    }


    public static int[] createNumber() {
        //1.创建数组用于添加中奖号码
        //6个红球 1个蓝球 数组长度：7
        int[] arr = new int[7];

        //2.随机生成号码并添加到数组当中
        //红球：不能重复的  可以是：1 2 3 4 5 6
        //蓝球：可以跟红球号码重复， 例如5

        //生成红球号码并添加到数组当中
        Random r = new Random();
        for (int i = 0; i < 6; ) {
            //获取红球号码
            int redNumber = r.nextInt(33) + 1;
            boolean flag = contains(arr, redNumber);
            if (!flag) {
                //把红球号码添加到数组当中
                arr[i] = redNumber;
                i++;
            }
        }

        //生成蓝球号码并添加到数组当中
        int blueNumber = r.nextInt(16) + 1;
        arr[arr.length - 1] = blueNumber;
        return arr;
    }

    //用于判断数组在数组中是否存在
    public static boolean contains(int[] arr, int number) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == number) {
                return true;
            }
        }
        return false;
    }
}
```



----

# 80.二维数组

## 一、什么是二维数组？

即：数组中存的还是数组。最外层的大数组就叫做二维数组。

我们可以将多个一维数组放到一个大的数组中方便管理，这个大的数组就叫做二维数组。

![image-20240404165831819](./assets/image-20240404165831819.png)

其实也有三维、四维、五维等数组，但是这些几乎是用不到的。

----

## 二、应用场景

当我们需要把数组分组管理的时候，就需要用到二维数组。

如图，定义四个一维数组，单独记录每个季度的营业额，然后将四个一维数组放到一个大的二维数组中统一管理。

![image-20240404170306752](./assets/image-20240404170306752.png)

当我们需要把数据分组管理的时候，就需要用到二维数组。

----

## 三、静态初始化

格式

~~~java
数据类型[][] 数组名 = new 数据类型[][] {{元素1, 元素2}, {元素1, 元素2}};
数据类型 数组名[][] = new 数据类型[][] {{元素1, 元素2}, {元素1, 元素2}};
~~~

示例

~~~java
int[][] arr = new int[][] {{11, 22}, {33, 44}};
int arr[][] = new int[][] {{11, 22}, {33, 44}};
~~~

由于上面那种书写格式相对来讲比较麻烦，所以我们会用简化书写格式

~~~java
数据类型[][] 数组名 = {{元素1, 元素2}, {元素1, 元素2}};
数据类型 数组名[][] = {{元素1, 元素2}, {元素1, 元素2}};
~~~

示例

~~~java
int[][] arr = {{11, 22}, {33, 44}};
int arr[][] = {{11, 22}, {33, 44}};
~~~

**虽然有两种书写格式，但是一般会将中括号放在变量的前面**，打开阿里巴巴代码规范。因此以后在书写的时候使用约定的代码来写就可以了。

![image-20240404170859405](./assets/image-20240404170859405.png)

---

## 四、静态初始化代码示例

### 1）利用静态初始化格式创建二维数组

~~~java
// 完整写法
int[][] arr1 = new int[][] {{1, 2, 3}, {4, 5, 6, 7, 8}};
// 简化
int[][] arr2 = {{1, 2, 3}, {4, 5, 6, 7, 8}};
// 由于上面的写法看着不方便，所以每一个一维数组我们一般都会另起一行
// 以后建议这样定义，把每一个一维数组单独写成一行。
// 注意：每一个一维数组其实是二维数组中的元素，所以每一个一维数组之间需要用逗号隔开。最后一个一维数组后面不需要加逗号
int[][] arr3 = {
    {1, 2, 3},
    {4, 5, 6, 7, 8}
};
~~~

---

### 2）获取元素

~~~java
System.out.println(arr3[0]); // [I@1197047 // 表示获取二维数组中的第一个一维数组，所以它打印出来的就是二维数组中第一个一维数组的地址值。
~~~

打印出来是一个地址值，`[` 表示它是一个数组，`@` 是固定格式，`1197047` 是真正的地址值。如果想要获取里面的元素，`arr3[0]` 后面还需要再加一个 `[]`。

~~~java
// arr3[0]：二维数组中的第一个一维数组
// arr3[0][0]：获取第一个一维数组中0索引的元素
System.out.println(arr3[0][0]);
~~~

获取元素 `arr[i][j]` 中：

- `i`：二维数组的索引，获取出来的是里面的一维数组
- `j`：表示一维数组中的索引，获取出来的就是真正的元素

---

### 3）遍历数组

思想：先得到一维数组，再遍历一维数组获取元素

~~~java
// 外循环：遍历二维数组，得到里面的每一个一维数组
for (int i = 0; i < arr3.length; i++) {
    // 这里的i表示二维数组中的每一个索引
    // arr3[i]：表示二维数组中的每一个元素（一维数组）
    // 内循环：遍历一维数组，得到里面的每一个元素
    for (int j = 0; i < arr3[i].length; j++) {
        // j：表示一维数组中的每一个元素
        System.out.print(arr3[i][j] + " ");
    }
    System.out.println();
}
~~~

---

## 五、动态初始化格式

- m表示这个二维数组，可以存放多少个一维数组
- n表示每一个一维数组，可以存放多少个元素

~~~java
数据类型[][] 数组名 = new 数据类型[m][n];
~~~

示例：该数组可以存放2个一维数组，每个一维数组中可以存放3个int类型元素

~~~java
int[][] arr = new int[2][3];
~~~

----

## 六、利用动态初始化格式创建二维数组

~~~~java
// 3：表示二维数组长度为3，可以装3个一维数组
// 5：表示每一个一维数组的长度都是5，可以装5个int类型的元素
int[][] arr = new int[3][5];

// 给二维数组赋值一个元素
arr[0][0] = 10;

// 遍历二维数组
// 外循环：遍历二维数组，获取里面的每一个一维数组
// 内循环：遍历一维数组，获取每一个元素
for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr[i].length; j++) {
        System.out.print(arr[i][j] + " ");
    }
    System.out.println();
}
~~~~

----

## 七、二维数组的内存图

假设创建了一个二维数组，main方法先进栈，然后再执行main方法的第一行代码。

等号的左边，就是在内存中定义了一个变量。其中`arr`是变量名，`int[][]` 是数据类型，表示 `arr` 可以记录int类型的二维数组的地址值。

![image-20240404174124991](./assets/image-20240404174124991.png)

由于等号右边有 `new` 关键字，所以在堆里面给二维数组开辟了一个小空间。假设二维数组的地址值是 `0x0011`，并在二维数组中创建了两个默认初始化值 `null`。

![image-20240404174336157](./assets/image-20240404174336157.png)

左边的代码中，还制定了一维数组的长度	

![image-20240404174406440](./assets/image-20240404174406440.png)

所以在内存中还会创建两个长度为3的一维数组，再把两个一维数组的地址值赋值给二维数组。最后再将二维数组的地址值 `0x0011` 赋值给左边的变量 `arr`，这样这个二维数组才创建完毕。

![image-20240404174539535](./assets/image-20240404174539535.png)

如果我们在代码中获取 `arr[0]`，获取的其实就是二维数组中 0 索引的元素。

![image-20240404174738778](./assets/image-20240404174738778.png)

0索引记录的是 `0x0022`，其实获取到的就是第一个一维数组。

![image-20240404174757393](./assets/image-20240404174757393.png)

因此如果我们要打印 `arr[0]` 的话，打印的就是一维数组的地址值。

---

但如果我们获取的是 `arr[0][1]`，首先通过前面的 `arr[0]`，获取地址值 `0x0022`，其实就是第一个一维数组。

![image-20240404174937099](./assets/image-20240404174937099.png)

然后再通过后面的 1，获取到1索引上的元素 0。

![image-20240404174953667](./assets/image-20240404174953667.png)

----

## 八、二维数组的特殊写法

### 1）特殊情况1

表示在内存中只创建一个二维数组，不创建一维数组，此时二维数组中存储的数据就是 `null`。

~~~java
public static void main(String[] args) {
    int[][] arr = new int[2][]; 
}
~~~

![image-20240404175137576](./assets/image-20240404175137576.png)

此时就需要我们手动去创建一维数组

~~~java
int[] arr1 = {11, 22};
int[] arr2 = {44, 55, 66};
~~~

假设这两个一维数组的地址值分别是 `0x00AA`、`0x00BB`。此时将一维数组的地址值添加给二维数组。

~~~java
arr[0] = arr1; // 将arr1赋值给arr的0索引
arr[1] = arr2; // 将arr2赋值给arr的1索引
~~~

在内存图当中，其实就是把 `0x00AA`、`0x00BB`添加到了arr对应的索引处。

![image-20240404175451393](./assets/image-20240404175451393.png)

这样写起来会相对比较麻烦，但是也有它的好处。在定义二维数组的时候，不需要Java帮我去创建一维数组了，下面我自己来创建。这样我自己创建就比较灵活了，我想要创建多大，它就创建多大。第一个一维数组长度是2，第二个一维数组长度是3，都可以。

如果写了固定的数字，Java会帮我们自动去创建一维数组，但是一维数组的长度都是一样的。

----

### 2）特殊情况2

创建arr的时候已经让Java自动帮我们创建一维数组。然后后面又将一维数组 `arr2` 赋值给二维数组 `arr` 的 0 索引。

~~~java
public static void main(String[] args) {
    int[][] arr = new int[2][3]; 
    int[] arr1 = {11, 22};
    int[] arr2 = {44, 55, 66};
    arr[0] = arr1;
    arr[1] = arr2; 
}
~~~

在内存图中，同样会把 `arr1` 和 `arr2` 都创建出来。

![image-20240404180106245](./assets/image-20240404180106245.png)

我们可以把 `arr1` 的地址 `0x00AA` 赋值给 `arr` 的0索引，将 `arr2` 的地址 赋值给 `arr` 的1索引。那么此时arr中存储的地址都会被覆盖。

此时二维数组的 `0索引` 和 `1索引` 就指向了两个新数组。

![image-20240404180415697](./assets/image-20240404180415697.png)

原来的两个旧数组就没有人去用了，它们两个就会变成垃圾，从而从内存中消失。



----

# 81.面向对象介绍

## 一、引入

面向对象就是写程序的套路，从字面意思来理解。

- 面向：拿、找
- 对象：能干活的东西
- 面向对象编程：拿东西过来做对应的事情

例如，之前我们要获取随机数的时候，我们找的就是 `Random` 来解决的。当我们要在控制台上输出内容的时候，就找了 `System` 来解决。当我们要获取键盘输入的数据的时候，就找了 `Scanner` 来解决。

在这个代码中我们要做对应的事情，都是找对应的东西来解决的。这种找东西来解决的思路就叫做面向对象编程。

![image-20240404193724864](./assets/image-20240404193724864.png)

----

## 二、为什么Java会采取面向对象这种方式来编程？

其实它跟我们现实当中采取的套路是一模一样的。

在现实生活中，我们会找一个洗衣机来帮我们做这件事情；如果我们要扫地，就会找一个扫地机器人帮我们做；如果我们要跟女朋友聊天，也是通过手机来做这件事的。

![image-20240404194509344](./assets/image-20240404194509344.png)

在生活中想干什么，都是找一个个东西来解决的。我们在程序中想干什么，也是找一个个东西来解决的，那有没有觉得，这种方式更符合人类思维习惯，编程更简单，更好理解。

----

## 三、面向对象重点学习什么？

**1、学习获取已有对象并使用**

例如之前获取随机数的 `Random`，键盘录入的 `Scanner`。

<img src="./assets/image-20240404194704356.png" alt="image-20240404194704356" style="zoom:67%;" />

**2、学习如何自己设计对象并使用**

如果要解决的东西是没有已有的东西帮你做的，此时就需要自己设计东西来解决了。



---

# 82.类和对象

## 一、引入

对象就是一个又一个能帮助我们解决问题的东西，但是这些东西都不是凭空出现的，在我们造对象的时候是需要根据设计图才能造出来的。在Java中的设计图其实就叫做 `类`。

类（设计图）：是对象共同特征的描述。

对象：是真实存在的具体实例。

在Java中，必须先设计类，才能获得对象。例如我们定义一个Phone类，它就表示是一个手机的设计图。它里面暂时写什么我们不管，但是可以通过new关键字就可以获取到一部真正的手机。

![image-20240404200200698](./assets/image-20240404200200698.png)

----

## 二、如何定义类

~~~java
public class 类名 {
    1、成员变量（代表属性，一般是名词）
    2、成员方法（代表行为，一般是动词）
    3、构造器
    4、代码块
    5、内部类
}
~~~

* 属性：在类中通过成员变量来体现（类中方法外的变量）

  例如手机的品牌、价格、颜色。

* 行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）

  例如手机能打电话、发短信、玩游戏等等。

类的定义步骤：

① 定义类，类名使用大驼峰命名

② 编写类的成员变量。要注意的是，类是表示手机这类事务，并不表示一部真正的手机，所以这里的变量只定义，不给值。

③ 编写类的成员方法

```java
public class 类名 {
	// 成员变量
	变量1的数据类型 变量1；
	变量2的数据类型 变量2;
	…
	// 成员方法
	方法1;
	方法2;	
}
```

示例代码：

```java
/*
    手机类：
        类名：
        手机(Phone)

        成员变量：
        品牌(brand)
        价格(price)

        成员方法：
        打电话(call)
        发短信(sendMessage)
 */
public class Phone {
    //成员变量
    String brand;
    int price;

    //成员方法
    public void call() {
        System.out.println("打电话");
    }

    public void sendMessage() {
        System.out.println("发短信");
    }
}
```

----

## 三、对象的使用

创建对象的格式：`类名 对象名 = new 类名();`

调用成员的格式：

* 对象名.成员变量
* 对象名.成员方法();

编写Phone类

```java
package com.itheima.test1;

public class Phone {

    //属性
    String brand;
    double price;


    //行为：
    public void call(){
        System.out.println("手机在打电话");
    }

    public void playGame(){
        System.out.println("手机在玩游戏");
    }
}
```

创建Phone对象

~~~java
package com.itheima.test1;

public class PhoneTest {
    public static void main(String[] args) {
        //创建手机的对象
        Phone p = new Phone();

        //叫做给手机赋值
        p.brand = "小米";
        p.price = 1999.98;

        //获取手机对象中的值
        System.out.println(p.brand);
        System.out.println(p.price);


        //调用手机中的方法即可
        p.call();
        p.playGame();

        // 创建第2部手机
        Phone p2 = new Phone();
        p2.brand = "苹果";
        p2.price = 8999;

        p2.call();
        p2.playGame();
    }
}
~~~

---

## 四、定义类的补充注意事项

### 1）Javabean类

- 用来描述一类事物的类，专业叫做：Javabean类。

  在Javabean类中，是不写main方法的。

- 在以前我们写的类是编写main方法的，这样的类我们会称做：测试类。

  我们可以在测试类中创建javabean类的对象并进行赋值调用。

Javabean类中，我们是可以编写属性跟行为去描述一类事务的。其中属性是由成员变量的形式体现的，而行为是由成员方法的形式体现的。

例如我们可以定义一个Student类来描述学生这类群体，学生会有很多属性，例如姓名、身高......行为就是学习和睡觉，我们可以定义两个方法来进行表示。在编写这个类的时候会有以下注意点：

- **类名首字母建议大写、英文、有意义，需要见名知意，大驼峰命名，满足标识符固定。**

- **一个Java文件中可以定义多个class类，且只能一个类是public修饰的，而且public修饰的类名必须成为代码文件名。**

  但由于在一个Java文件中写多个类一般没什么实际的意义，所以实际开发中建议还是一个文件定义一个class类。

- **成员变量的完整定义格式是：`修饰符 数据类型 变量名称 = 初始化值`，在代码中一般只定义，不给值，存在默认值。**

  这是因为Student类并不是特指某一个具体的学生，Student这个类只是用来描述学生这个群体的，而每个学生的姓名、身高都是不一样的，所以在这里我们一般都是只定义，不给值的。如果强行赋值 `String name = "张三";`，代码的语法也没有错，但是它就表示所有的人都叫做张三了。

  **因此我们赋值并不是在类中赋值，而是当创建了对象之后，才可以赋值**，因为我创建的对象才可以表示某个特定的学生，因此在这里我就可以给这个特定的学生赋它的姓名、身高等等。

  这是因为右边创建出的对象才表示某个特定的学生，因此在这里我们就可以对这个特定的学生赋它的身高、姓名等。

  ![image-20240404203751849](./assets/image-20240404203751849.png)

----

### 2）对象的成员变量的默认值规则

| 数据类型 |          明细          | 默认值 |
| :------: | :--------------------: | :----: |
| 基本类型 | byte、short、int、long |   0    |
|          |     float、double      |  0.0   |
|          |        boolean         | false  |
| 引用类型 | 类、接口、数组、String |  null  |

----

## 五、练习：女朋友类

编写女朋友类，创建女朋友类的对象。给女朋友的属性赋值并调用女朋友类中的方法。

GirlFriend.java

~~~java
package com.itheima.test2;

public class GirlFriend {
    //属性
    String name;
    int age;
    String gender;

    //行为
    public void sleep(){
        System.out.println("女朋友在睡觉");
    }

    public void eat(){
        System.out.println("女朋友在吃饭");
    }
}
~~~

GirlFriendTest.java

~~~java
package com.itheima.test2;

public class GirlFriendTest {
    public static void main(String[] args) {
        //创建女朋友的对象
        GirlFriend gf1 = new GirlFriend();
        gf1.name = "小诗诗";
        gf1.age = 18;
        gf1.gender = "萌妹子";

        System.out.println(gf1.name);
        System.out.println(gf1.age);
        System.out.println(gf1.gender);

        gf1.eat();
        gf1.sleep();


        System.out.println("===================");
        // 如果要拥有第二个女朋友
        GirlFriend gf2 = new GirlFriend();
        gf2.name = "小丹丹";
        gf2.age = 19;
        gf2.gender = "萌妹子";

        System.out.println(gf2.name);
        System.out.println(gf2.age);
        System.out.println(gf2.gender);

        gf2.eat();
        gf2.sleep();
    }
}
~~~



----

# 83.封装

## 一、引入

如果在一个需求中有多个事物，有的行为不知道归属于哪个类了，该怎么办呢？

例如 `人画圆` ，是把画圆写到人这个类中，还是写到圆这个类中呢？此时就用到了我们现在学习的知识点 —— 封装

<img src="./assets/image-20240404210347113.png" alt="image-20240404210347113" style="zoom:67%;" />

封装是面向对象三大特征之一。

面向对象三大特征：封装、继承、多态。

----

##  二、概念

封装：告诉我们，拿到一个需求之后，该如何正确设计对象的属性和方法。

例如：现在拿到一个需求，要求我们定义一个类描述人。属性有：姓名、年龄。行为有：吃饭、睡觉。

~~~java
public class Person {
    //属性
    String name;
    int age;
    
    public void eat(){
        System.out.println("吃饭");
    }

    //行为
    public void sleep(){
        System.out.println("睡觉");
    }
}
~~~

但是，在实际开发中需求不会这么简单的，经常会涉及到多个对象。例如：人画圆，请针对这个需求进行面向对象设计。

人画圆涉及到两个对象，定义 `Person` 类代表人，定义 `Circle` 类代表圆。由于画圆是一个行为，我肯定要定义一个 `draw` 方法来进行表示，请问 `draw` 方法我应该设计在人这个对象中，还是应该设计在原这个对象中呢？

![image-20240404212002924](./assets/image-20240404212002924.png)

大部分人在接触到这个问题时会这么想：人画圆，画圆的方法当然是属于人的，但是这个是错误的理解！

人画圆，应该属于圆的方法。

![image-20240404212219033](./assets/image-20240404212219033.png)

如果想要知道为什么，就需要讲到封装思想里一个非常重要的原则：对象代表什么，就得封装对应的数据，并提供数据对应的行为。

结合我们的案例就是：我们既然是定义了一个类来代表圆，肯定会涉及一些属性来封装圆的信息。例如：圆的半径。画圆就需要根据半径来画。应我们刚刚那句话：Circle代表圆，封装了圆的半径，那就得提供和半径相关的画圆方法。因此画圆这个方法当然是属于圆的。

----

## 三、示例：人关门

这个门是人关的，还是门自己关的？答案是自己关的，因为人只是给门一个作用力，然后门就自己把自己关起来了。

因此关门这个方法一定是门的方法，而不是人的。

<img src="./assets/image-20240404212943135.png" alt="image-20240404212943135" style="zoom:50%;" />

~~~java
public class Door {
    boolean flag = true; // 门的状态数据
    
    public void open() {
        ...
    }
    
    public void close() {
        ...
    }
}
~~~

我们也同样用到我们上面的思想来理解这个场景：对象代表什么，就得封装对应的数据，并提供数据对应的行为。

门是开还是关，是门的状态数据，既然门封装了这个数据，那么和这个数据相关的开门、关门的方法就是门这个对象的方法了。

---

## 四、封装的好处

### 1）对象代表什么，就得封装对应的数据，并提供对应的行为

Sun公司为了Java能在市场上胜出，它基本上把我们程序员要干的事情全都提前想好了，并且设计了很多很多对象给我们用。![image-20240404213812530](./assets/image-20240404213812530.png)

因为比较多，这些东西我们也不会背，Java都会汇总到一个文档当中。这个文档就叫 `JDK-API文档.CHM`。

![image-20240405100318278](./assets/image-20240405100318278.png)

可以看见这里有很多很多Java已经写好的类，Sun公司设计的每个对象都是用来代表一个事物的，在设计的时候都会按照我们之前讲的原则进行设计，因此它在设计的时候，不仅会提供相应的属性来封装对应的数据，还会根据我们程序员可能会涉及到的需求来涉及对数据进行相应处理的方法。

这意味着我们以后要干什么事情，我们只需要找到Sun公司给你提供的对象，然后把处理的数据交给它，调用它的方法进行操作就行了，而不需要自己去写，这样就极大降低了我们编程的门槛。

![image-20240405100515894](./assets/image-20240405100515894.png)

例如：Sun公司知道我们对字符串的处理是非常常见的，因此它提供了一个代表字符串的 `String` 对象。Sun公司既然提供了一个String类代表字符串，它一定会设计相应的属性来封装我们要处理的字符串，并且会提供字符串处理的所有的方法。那就意味着我们程序员将来想对字符串进行操作的话，就不需要自己写代码了，只需要使用String去封装处理的字符串，然后去找String对应的方法就行了。

![image-20240405110809429](./assets/image-20240405110809429.png)

~~~java
public class StringTest {
    public static void main(String[] args) {

        // 用String去记录我想要处理的字符串
        String s  = "wefipuhweiduhwiuehd";

        int len = s.length(); // 调用里面的方法
        System.out.println(len);
        
        // 调用toUpperCase方法，结果就是转为大写之后的
        String ss = s.toUpperCase();
        System.out.println(ss);
    }
}
~~~



例如：Sun公司提供了一个 `Socket` 对象代表网络连接，如果我们想要做网络编程，想要连别人的电脑，就可以使用这个对象。

Socket既然代表一个网络连接，就必须有一个属性要记住连接谁。既然有这个属性，那就一定会提供相应的连接方法，和对应的发送数据的方法。因此用Java做网络编程就很简单，创建对象，调用方法，就可以完成我们想做的事情。

----

### 2）降低我们的学习成本，可以少学、少记，或者说压根不用学，不用记对象有哪些方法，有需要时去找就行了。

这是因为Sun公司为了简化我们的开发，提供了很多很多的对象给我们用，每个对象又会有很多很多的方法。

---

## 五、private引入

例如之前写的女朋友类，如果按照之前的去写，就会不安全。原因如下：

~~~java
public class GirlFriend {
    //属性
    String name;
    int age;
    String gender;
}
~~~

我们创建一个女朋友对象，然后给age赋值，赋值18是正常的操作。

~~~java
GirlFriend gf1 = new GirlFriend();
gf1.age = 18;
~~~

但是如果有其他的人，小手一抖，赋了一个 `-18`。代码的语法是没有问题的，但是跟我们的实际情况就不符合了。

~~~java
GirlFriend gf1 = new GirlFriend();
gf1.age = -18;
~~~

这时候我们就需要来学习`private关键字`了。

----

## 六、private关键字

private是一个权限修饰符，可以修饰成员（成员变量和成员方法）。被 `private` 修饰的成员只能在本类中才能访问。

例如我们刚刚的代码，直接这么写是不安全的，因为别人在使用的时候它可以赋一些不合理的值。

~~~java
public class GirlFriend {
    //属性
    String name;
    int age;
    String gender;
}
~~~

所以我们在它的前面就需要加上 `private` 私有关键字，一旦成员变量用 `private` 修饰后，那就表示当前的成员变量已经变成私有的了，只能在本类（GirlFriend）中使用，其他类中就不能用了。

~~~java
public class GirlFriend {
    //属性
    String name;
    int age;
    String gender;
}
~~~

例如下面代码就会报错

~~~java
GirlFriend gf1 = new GirlFriend();
gf1.age = -18; // ×
~~~

现在数据安全的问题已经解决了，但是与此同时，又带来了一个新的问题：如果我给age赋了一个正确的18岁，但是代码依旧会报错，因为所有的成员变量都统一用private来修饰了，因此在其他类中都不能够像下面这样直接去调用了。

~~~java
GirlFriend gf1 = new GirlFriend();
gf1.age = 18;
~~~

那这不行，这不是我想要的，我们真正想要的是：正确的可以正常赋值，但是错误的数据无法赋值。那应该怎么办呢？

有人就会说，在左边的时候不加 `private`，然后在右边赋值的时候判断一下。这样写代码是不行的，因为

- 如果我有3000个女朋友，那每一次赋值都要判断，太麻烦了！

- 我们之前学习过封装，在封装中说过：对象代表什么，就得封装对应的数据，并提供数据对应的行为。

  而现在GirlFriend类就代表女朋友，它里面封装了女朋友所有的属性，那么对这些属性进行校验的方法，就必须也写在GirlFriend类中。

![image-20240405113749682](./assets/image-20240405113749682.png)

----

## 七、`set` & `age`

因此，最为标准的代码应该如下去写：

所有的属性都加上 `private` 关键字，不让外界直接去访问。与此同时，每个属性我们都要提供由 `public` 修饰的 `get` 和 `set` 方法。

`public`也是一个权限修饰符，它跟`private`是反过来的，`public`表示公共的，公开的，它表示在所有的类中都可以使用它修饰的成员。

针对 `age` 属性来讲，我们就需要提供 `setAge`、`getAge` 这两个方法，其中 `setAge` 是给 `age` 赋值的，在赋值的时候就可以对传递过来的数据进行一些校验。`getAge` 就是对外提供 `age` 这个属性的值。

![image-20240405114049663](./assets/image-20240405114049663.png)

----

## 八、`set` & `age` 练习

1、首先在所有成员变量前面都加上 `private` 修饰符，一旦加上，测试类中就不能直接使用里面的成员变量了。

2、针对每一个私有化的成员变量，都要提供 `get` 和 `set` 方法。

GirlFriend.java

~~~java
package com.itheima.test3;

public class GirlFriend {
    //属性
    private String name;
    private int age;
    private String gender;


    //针对于每一个私有化的成员变量，都要提供get和set方法
    //set方法：给成员变量赋值
    //get方法：对外提供成员变量的值

    //作用：给成员变量name进行赋值的
    public void setName(String name){
        //局部变量表示测试类中调用方法传递过来的数据
        //等号的左边：就表示成员位置的name，将局部变量的值赋值给成员变量
        this.name = name;
    }

    //作用：对外提供name属性的
    public String getName(){
        return name;
    }


    //age
    //setAge:给成员变量age进行赋值的
    //getAge：对外提供成员变量age的值
    public void setAge(int age){
        if(age >= 18 && age <= 50){
            this.age = age;
        }else{
            System.out.println("非法参数");
        }
    }

    public int getAge(){
        return age;
    }


    //gender
    public void setGender(String gender){
        this.gender = gender;
    }

    public String getGender(){
        return gender;
    }


    //行为
    public void sleep() {
        System.out.println("女朋友在睡觉");
    }

    public void eat() {
        System.out.println("女朋友在吃饭");
    }
}
~~~

GirlFriendTest.test 

~~~java
public class GirlFriendTest {
    public static void main(String[] args) {
        //创建女朋友的对象
        GirlFriend gf1 = new GirlFriend();
        //赋值
        gf1.setName("小诗诗");
        gf1.setAge(-18); // 赋值失败，此时会打印出 “非法参数”，下面获取值的时候获取的还是age的默认值 0
        gf1.setGender("女");

        System.out.println(gf1.getName());
        System.out.println(gf1.getAge()); 
        System.out.println(gf1.getGender());

        gf1.eat();
        gf1.sleep();
    }
}
~~~

---

## 九、private总结

1、private关键字是一个权限修饰符

2、可以修饰成员（成员变量和成员方法）

3、被private修饰的成员只能在本类中才能访问

4、针对private修饰的成员变量，如果需要被其他类使用，需要提供相应的操作

5、提供 “setXXX(参数)“ 方法，用于给成员变量赋值，方法用 public 修饰

6、提供 “getXXX() ” 方法，用于获取成员变量的值，方法用public修饰，返回值的数据类型 需要 与成员变量的数据类型对应



----

# 84.就近原则和this关键字

this关键字的作用：可以区分成员变量和局部变量。

## 一、引入

先来看一段代码，这个是将传过来的 n 赋值给 name成员变量。但是之前我们讲过，起名字的时候需要见名知意，因此这里的 `n` 就不符合规矩了，对于姓名来讲，`name` 更合适。

~~~java
public void setName(String n){
    name = n;
}
~~~

但是形参改为 `name`，就会发生一个问题：它跟成员变量的 `name` 重复了

~~~java
private String name;
public void setName(String name){
    name = name;
}
~~~

重新执行获取姓名的代码，结果为 `null`。这是因为 `setName` 的时候没有赋值成功。

~~~java
System.out.println(gf1.getName());
~~~

要解释为什么没有赋值成功，就需要先解释两个专业名词：成员变量和局部变量。

----

## 二、成员变量和局部变量

按顺序看解说

~~~java
public class GirlFriend {
    private int age; // 2.如果将变量定义在方法的外面，类的里面，这个变量就叫做成员变量
    public void method() {
        int age = 10; // 1.将变量定义在方法中，就叫做局部变量
        System.out.println(age); // 3. 当成员变量和局部变量重名的时候，打印出来的是局部变量的10
    }
}
~~~

上面打印结果涉及到一个理论：就近原则 —— 谁离我近，我就用谁。

针对上述代码，局部变量离它更近，因此打印的就是局部变量的10。

那如果我就是想打印成员变量的age，该怎么办呢？此时就需要在age前面加一个 `this` 关键字，此时它就不会用方法里面的 `age`，而是直接使用成员变量的 `age`。

~~~java
public class GirlFriend {
    private int age;
    public void method() {
        int age = 10; 
        // 谁离我近，我就用谁
        System.out.println(age);  // 由于这行代码age前没有this，它就会先去局部位置找age，如果局部位置有，使用的就是局部位置的age；但如果局部位置没有，它就会去成员变量的位置去找
        System.out.println(this.age);  // 不会到局部位置找，而是直接使用成员变量的age
    }
}
~~~

但如果只有成员变量，没有局部变量，此时的 `this` 就可以省略不写。

~~~java
public class GirlFriend {
    private int age;
    public void method() {
        // int age = 10; 
        System.out.println(age); // this省略不写
    }
}
~~~



----

# 85. 构造方法

## 一、概述

构造方法也叫作构造器、构造函数。但是我们平时习惯上还是会叫做构造方法。

作用：在创建对象的时候给成员变量进行初始化。

> 这里的 `初始化` 是一个专业名字，其实就是赋值的意思。
>
> 因此构造方法简单理解，就是在创建对象的时候给成员变量进行赋值的。

在以前的代码中，小括号中都是空着的，什么也不写。此时就表示我们调用的是空参的构造方法。

<img src="./assets/image-20240405142757180.png" alt="image-20240405142757180" style="zoom:67%;" />

----

## 二、构造方法格式

### 1）格式

~~~java
public class Student {
    修饰符 类名(参数) {
        方法体;
    }
}
~~~

----

### 2）特点

1. 方法名与类名必须完全一样，大小写也要一致。
2. 构造方法它虽然叫做方法，但是它是没有返回值类型的，连void都不能写。
3. 因为构造方法没有返回值，因此在大括号里面是不能写return的，一旦写了，代码就会报错。

---

### 3）示例

第一个是 `空参构造`（空参构造一般是空的，什么也不写），利用空参构造来创建对象的时候，成员变量都是默认初始化值。

第二个是 `带全部参数构造方法`，在方法里面就可以给所有的成员变量进行赋值了。这样我们在创建对象的时候，name 和 age就有值了，就省的我们再去调用 `set方法` 进行赋值了，可以让我们的代码变得更加的简单。

---

### 4）执行时机

1. 创建对象的时候由虚拟机调用，不能手动调用构造方法
2. 每创建一次对象，构造方法就会被调用一次

----

## 三、代码示例

Student.java

~~~java
package com.itheima.test5;

public class Student {
    private String name;
    private int age;


    // 如果我们自己没有写任何的构造方法
    // 那么虚拟机给我们加一个空参构造方法
    /* public Student(){
        System.out.println("看看我执行了吗？");
    } */

    // 有参构造
    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
~~~

StudentTest.java

~~~java
package com.itheima.test5;

public class StudentTest {
    public static void main(String[] args) {
        //创建对象
        //调用的空参构造 tudent ss = new Student();

        Student ss = new Student("zhangsan",23);
        System.out.println(ss.getName());
        System.out.println(ss.getAge());
    }
}
~~~

----

## 四、赋值的原理

在我们创建对象的时候，会自动根据后面的参数去调用对应的构造方法。

因为我这里传了两个参数，一个是 String，一个是 int，所以它会调用这里的有参构造。

~~~java
Student ss = new Student("zhangsan",23);
~~~

一般写代码的时候有参构造和无参构造我们一般都是会写上的。因为在实际开发中，有的时候我们创建对象时，是不知道属性值的。例如：对象的属性值不是直接写死的，而是由键盘录入来的，此时我创建对象的时候，就不知道对象里的属性是什么了，此时我只能先用空参构造先把对象创建出来，然后等用户键盘录入了，此时再通过 `s.setName"";`，把用户键盘录入的数据进行复制。

----

## 五、构造方法注意事项

### 1、构造方法的定义

- 如果没有定义构造方法，系统将给出一个默认的无参数构造方法
- 如果定义了构造方法，系统将不再提供默认的构造方法

Student.java

~~~java
package com.itheima.test5;

public class Student {
    private String name;
    private int age;

    // 有参构造
    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }
}
~~~

由于在 `Student` 类中已经定义了一个有参构造，系统将不再提供默认的构造方法，下述代码就会报错。

~~~java
// 会调用Student的无参构造
Student s = new Student(); // 报错
~~~

----

### 2、构造方法的重载

带参构造方法，和无参构造方法，两者方法名相同，但是参数不同，这叫做构造方法的重载。

推荐的使用方式：**无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法**。这是因为在以后的实际开发，基本上不是你一个人写一个项目，而是很多人一起开发的。假设现在自己只用到了有参构造，但是别人却可能使用无参构造。因此无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法，这已经成为了一个习惯了。

----

## 六、总结

**1、构造方法的作用？**

创建对象的时候，由虚拟机自动调用，给成员变量进行初始化的。

**2、构造方法有几种，各自的作用是什么？**

- 无参数构造方法（空参构造方法）：初始化对象时，成员变量的数据均采用默认值。
- 有参数构造方法：在初始化对象的时候，同时可以为对象进行赋值。

**3、构造方法有哪些注意事项？**

- 任何类定义出来，默认就自带了无参数构造器，写不写都有。
- 一旦定义了有参数构造器，无参数构造器就没了，此时就需要自己写无参数构造器了。
- 建议在任何时候都手动写上空参和带全部参数的构造方法。

----

## 七、构造方法扫盲

有很多资料书都这么解释：构造方法就是用来创建对象的。其实这句话是错误的。

真正创建对象其实是 `new` 关键字干的。虚拟机在创建对象的时候其实是有很多很多步骤的，其中调用构造方法只是创建对象的其中一步而已，这一步就是为了给成员变量进行初始化的。

![image-20240405155248518](./assets/image-20240405155248518.png)

因此真正构造方法的作用就是：在创建对象的时候，虚拟机会自动调用构造方法，它的作用是给成员变量进行初始化的。



----

# 86.标准的Javabean类

## 一、标准的Javabean类定义标准

① 类名需要见名知意

例如老师就加 `Teacher`，学生就叫 `Student`

② 为了保证数据的安全性，所有的成员变量都要 `private` 修饰

③ 提供至少两个构造方法 

* 无参构造方法
* 带全部参数的构造方法

④ get和set方法 

提供每一个成员变量对应的setXxx()/getXxx()

如果题目还有其他行为，也需要写上。例如学生还有学习、吃饭、睡觉；老师还有上课、教书等等方法。

----

## 二、代码示例

如下是某个网站的注册页面，现在就写一个标准的Javabean去描述用户。

![image-20240405160351517](./assets/image-20240405160351517.png)

既然要描述用户，类名就叫做 `User`。成员变量就是：用户名、密码、确认密码、邮箱、性别、年龄。

User.java

~~~java
package com.itheima.test6;

public class User {
    //属性
    private String username;
    private String password;
    private String email;
    private String gender;
    private int age;

    // 空参
    public User() {
    }

    // 带全部参数的构造
    public User(String username, String password, String email, String gender, int age) {
        this.username = username;
        this.password = password;
        this.email = email;
        this.gender = gender;
        this.age = age;
    }

    // 快捷键：alt + insert，如果按没反应，就按 alt + Fn + insert
    /**
     * 获取
     * @return username
     */
    public String getUsername() {
        return username;
    }

    /**
     * 设置
     * @param username
     */
    public void setUsername(String username) {
        this.username = username;
    }

    /**
     * 获取
     * @return password
     */
    public String getPassword() {
        return password;
    }

    /**
     * 设置
     * @param password
     */
    public void setPassword(String password) {
        this.password = password;
    }

    /**
     * 获取
     * @return email
     */
    public String getEmail() {
        return email;
    }

    /**
     * 设置
     * @param email
     */
    public void setEmail(String email) {
        this.email = email;
    }

    /**
     * 获取
     * @return gender
     */
    public String getGender() {
        return gender;
    }

    /**
     * 设置
     * @param gender
     */
    public void setGender(String gender) {
        this.gender = gender;
    }

    /**
     * 获取
     * @return age
     */
    public int getAge() {
        return age;
    }

    /**
     * 设置
     * @param age
     */
    public void setAge(int age) {
        this.age = age;
    }


    

    //插件PTG 1秒生成标准Javabean
}
~~~

---

## 三、快捷键

### 1）生成构造、get、set方法的快捷键设置

快捷键：<kbd>alt + insert</kbd>，如果按没反应，就按 <kbd>alt + Fn + insert</kbd>，可以创建构造、get、set方法。

但是我们不使用这个默认的快捷键，而是将它修改为 <kbd>ctrl + g</kbd>。

settings —> Keymap ——> 搜索 `Generate` ——> 右击`Generate...` ——> Remove Alt+Insert

![image-20240405161631836](./assets/image-20240405161631836.png)

然后再右击，选择 `Add Keyboard Shortcut`。

![image-20240405161723225](./assets/image-20240405161723225.png)

然后在键盘上输入 <kbd>ctrl + G</kbd>，点击OK，点击Apply，点击OK即可。

![image-20240405161824796](./assets/image-20240405161824796.png)

如果出现警告，直接点击 `Remove` 即可。

![image-20240405161852554](./assets/image-20240405161852554.png)

----

### 2）生成构造

输入快捷键 <kbd>ctrl + g</kbd>，然后点击 `Constructor`

![image-20240405162117828](./assets/image-20240405162117828.png)

它默认选中的是第一个参数：username

<img src="./assets/image-20240405162201302.png" alt="image-20240405162201302" style="zoom:67%;" />

这个时候还不能点ok，因为一旦点了ok，它就会对第一个参数 `username` 来生成构造，但这并不是我们想要的。如果需要创建空参构造，只需要点击下方的 `Select None`，表示什么属性都不选

![image-20240405162341610](./assets/image-20240405162341610.png)

或者按两下 `tab`键，第一下 `tab` 是取消默认选择。第二下 `tab` 会把 `Select None` 按钮背景变蓝，即选中 `Select None`。

![image-20240406120036329](./assets/image-20240406120036329.png)

点击完成后，它就会直接生成空参构造。

![image-20240405162758127](./assets/image-20240405162758127.png)

如果需要生成带全部参数的构造方法，重新按住快捷键<kbd>ctrl + g</kbd>，重新点击 `Constructor`。这次需要按住 `shift` 不松开，再点击最下面的 `age`，相当于将所有的属性全选了，当然也可以按快捷键 <kbd>ctrl + a</kbd> 全选，再点击下面的ok即可。

<img src="./assets/image-20240405162655926.png" alt="image-20240405162655926" style="zoom:67%;" />

或者直接按住 `shift` 不要松，然后按键盘中上下键的下键，它就会逐一选择，直到全部选中，此时再点 `OK` 即可。但 <kbd>Ctrl + A</kbd> 更方便。

此时就会生成带有全部参数的构造方法。

![image-20240405162748637](./assets/image-20240405162748637.png)

----

### 3）get、set方法的生成

使用快捷键<kbd>ctrl + g</kbd>，然后选中第四个 `Getter and Setter`

![image-20240405162908629](./assets/image-20240405162908629.png)

同样的，我们也可以<kbd>ctrl + A</kbd>全选，然后点击OK。

<img src="./assets/image-20240405163025792.png" alt="image-20240405163025792" style="zoom:67%;" />

此时都给每个成员变量提供了对应的`get`跟`set`方法，非常的快。

---

### 4）PTG插件

PTG插件可以1秒生成标准Javabean。

首先进入下载插件的地方：settings ——> Plugins ——> Marketplace

`Marketplace`：表示下载页面。`Installed`：表示在电脑当中已经安装了的插件。

![image-20240405163415467](./assets/image-20240405163415467.png)

在插件市场搜索 `ptg`，然后直接点击 `Install` 即可。

![image-20240405163517257](./assets/image-20240405163517257.png)

此时就可以右键点击空白处，选择 `Ptg To JavaBean`，也就是利用 `ptg` 插件去生成Javabean。

![image-20240405164012042](./assets/image-20240405164012042.png)

点击后发现，它将空参构造、全参构造、get跟set方法全都自动生成了。更爽的是，它连注释都帮我们自动生成了。

<img src="./assets/image-20240405164156875.png" alt="image-20240405164156875" style="zoom:67%;" />

----

# 87.对象内存图

## 一、简单回顾内存

在之前我们讲过，每款软件在运行的时候都是要占用一块内存区域的，Java也不例外。在运行的时候，虚拟机也会占用一块内存空间。

只不过为了更好地去利用这块内存，JVM把它分成了五个部分，每个部分都有它自己的作用。

![image-20240404125855146](./assets/image-20240404125855146.png)

现在我们要知道的就是里面的三块：栈、堆、方法区

<img src="./assets/image-20240405164717457.png" alt="image-20240405164717457" style="zoom:67%;" />

这个里面的方法区我们要额外单独来说一下。方法区本身有很多作用、很多功能。其中，当我们要运行一个类的时候，这个类字节码文件就会被加载到方法区中临时存储。

在JDK7以前，方法区跟堆空间它们两个是连在一起的，在真实的物理内存当中也是一块连续的空间，但是这种设计方式并不是很好。

<img src="./assets/image-20240403170838621.png" alt="image-20240403170838621" style="zoom:50%;" />

到了JDK8的时候，就改进了这种设计，取消了方法区，新增了一块元空间的区域，把它跟堆空间分开了，把原来方法区要做的很多的事情都进行拆分，有的功能放到了堆当中，有的功能放到了堆中，有的功能放到了元空间中，而现在加载字节码文件的功能在JDK8以后就归属于元空间了。

<img src="./assets/image-20240403170257736.png" alt="image-20240403170257736" style="zoom: 50%;" />

但是它具体叫什么名字不重要，重要的是它加载完后，代码该如何运行。为了方便大家理解，我们暂时将这块区域仍叫做方法区。

当运行一个类的时候，这个类的字节码文件就会加载到方法区中临时存储。比如说，这里有个`HelloWorld.class`、`Test.class`，在运行的时候都会加载到方法区中临时存储。

![image-20240405165350962](./assets/image-20240405165350962.png)

----

## 二、回顾栈和堆

栈：当方法被调用的时候，需要进栈执行，而方法里面所定义的变量其实也是在这里面的。当方法执行完毕后，它就需要出栈。

堆：只要是 `new` 出来的就会在堆中开辟一个小空间。堆里还有一个特点，就是堆里面开辟的空间都会有自己的地址值。

----

## 三、一个对象的内存图

### 1）创建变量的步骤

当我们在创建一个对象的时候，比如

~~~java
Student s = new Student();
~~~

在创建 `Student` 对象的时候，内存里面至少会做以下7件事情。

**1、加载class文件**

其实也就是把Student类的字节码文件加载到内存。

**2、声明局部变量**

其实就是对等号左边的 `s` 来进行声明。

**3、在堆内存中开辟一个空间**

这句话说的就是等号的右边，有一个 `new` 关键字，所以在堆里就会开辟一个小空间。而这个小空间其实也就是我们平时所说的对象。

**4、默认初始化**

**5、显示初始化**

**6、构造方法初始化**

这里的4、5、6三步，其实都是对第3步中的变量来进行赋值的。

**7、将堆内存中的地址值赋值给左边的局部变量**

----

### 2）画图解释

#### 创建变量前的代码

首先来看一下要画图的代码：写了一个很简单的`Student类`，这里面有两个属性 —— name、age，然后还有一个 `study` 学习方法。

然后在测试类中创建对象。测试类名字叫做 `TestStudent`，在这里面首先创建了它的对象，然后打印 `s`，再使用 `s` 对 name 和 age 进行打印。然后再对 name 和 age 进行赋值，赋完值之后，再获取并打印，最后再调用 `s` 的 `study` 方法。

![image-20240405170554690](./assets/image-20240405170554690.png)

接下来看看这些代码在内存当中到底干了那些事。

首先程序肯定先从main方法开始执行的，所以说第一步，它要将 `StudentTest类` 的字节码文件（StudentTest.class）加载到方法区里，这里面就会把main方法进行临时存储。

![image-20240405171048683](./assets/image-20240405171048683.png)

然后虚拟机会自动调用程序的主入口 `main方法`，所以此时main方法会被加载到栈里。

![image-20240405171215816](./assets/image-20240405171215816.png)

然后我们就要开始执行main方法中的代码了。第一句就是创建一个对象 `Student s = new Student();`。

刚才我们说了，创建对象的代码，虚拟机至少做了以下的7步。

![image-20240405171655557](./assets/image-20240405171655557.png)

----

#### 按步骤创建变量

**① 加载class文件**

由于`Student s = new Student()` 中用到了Student类，所以在方法区里面，它会把 `Student.class` 加载到这里面，临时存储。在 `Student.class` 中会有 `Student` 类的所有信息。例如所有的成员变量，还有所有的成员方法。

![image-20240405174253462](./assets/image-20240405174253462.png)

**② 声明局部变量**

其实就是在创建对象等号左边的这个代码，在main方法中，它就会开辟一个空间，这个空间的名字就叫做 `s`，这个空间以后能存储 `Student` 这个类对象的地址值。

![image-20240405174235668](./assets/image-20240405174235668.png)

**③ 在堆内存中开辟一个空间**

其实也就是在创建对象等号右边的代码。因为有 `new` 关键字，所以此时在堆里就会有一个这样的小空间。而堆里的这些空间都是有地址值的。

所以现在假设这块空间的地址值是 `001`，那么这块空间里面，就会把Student里面所有成员变量拿过来，拷贝一份放过来。除此之外，它还会有所有成员方法的地址，存储方法的地址是为了以后对象调方法的时候，我们能找到对应的方法。

此时堆里 `001` 的空间其实就是我们平时说的对象，但是现在这个对象还没有创建完毕，因为这里的 name 跟 age 都还没有值。

![image-20240405174915799](./assets/image-20240405174915799.png)

此时就需要4、 5、 6这三步。

![image-20240405174847164](./assets/image-20240405174847164.png)

首先它会进行默认初始化。

**④ 默认初始化**

这里 name 默认初始化就是 null，age默认初始化值就是 0。

![image-20240405175030961](./assets/image-20240405175030961.png)

**⑤ 显示初始化**

如果我们在Student类中定义成员变量的时候是直接给值了，这个就叫做显示初始化。

如果你这么写了，在显示初始化这一步，默认初始化值 null 跟 0，就会被 “张三” 和 23 所覆盖。

![image-20240405175243353](./assets/image-20240405175243353.png)

但是此时我们在代码当中并没有写这个代码，所以显示初始化我们可以忽略。

**⑥ 构造方法初始化**

在代码当中，由于小括号里什么都没写，所以就表示我现在调用的是空参构造。空参构造里也没有写代码，所以构造方法初始化我们也可以忽略。

![image-20240405175504773](./assets/image-20240405175504773.png)

但是假如此时，你用的是有参构造来创建对象，那么此时 name 跟 age 就会有值了。

因此，构造方法就是创建对象中的一步而已。

**⑦ 将堆内存中的地址赋值给左边的局部变量**

其实也就是把这里的 `001` 通过中间的 等号运算符 赋值给了左边的变量 s，此时s这个变量里就会存储地址值 `001`。

s也可以通过 `001` 这个地址值找到右边的这个空间。

到目前为止，一个对象才创建完毕。

![image-20240405175706398](./assets/image-20240405175706398.png)

-----

#### 创建变量后的代码

所以说在下面，如果我们直接打印 `s` 的话，其实就是打印s中记录的地址值，此时在控制台中看到的其实也就是它的地址值。

但是这个地址值对我们来讲没有用，我们需要的是获取里面的属性。

因此在代码当中我们要通过 `s` 调用 `name`， `s` 调用 `age` 。要注意的是，现在的 `s` 记录的是 `001` 地址值。

所以下面这个代码我们也可以理解为：我现在要打印 `001` 里面的 `name`，还有 `001` 里面的 `age`。`001` 找到的就是右边的这块空间。

所以就会把里面的 null 和 0 获取到了，在控制台中打印的也就是 null 和 0。

![image-20240405180641306](./assets/image-20240405180641306.png)

再往下就是通过 `s.name` 去给它赋值了。相当于就是把 `"阿强"` 赋值给了 `001` 的 `name`，把 `23` 赋值给了 `001` 的 `age`。此时它同样的也是找到了右边的这块空间。将原来的 null 和 0 给覆盖了。

赋值成功之后再获取，`001` 的 `name` 和 `001` 的 `age` 就变成了 `阿强` 和 `23`。所以在控制台中打印的就是 `阿强` 和 `23`。

![image-20240405180925479](./assets/image-20240405180925479.png)

最后一步 `s.study()` ，即用 s 调用 study，它也会先去找s中存储的，也就是 `001` 这个空间。

在 `001` 空间中，会有成员方法的地址，然后就找到下面的 `study()` 方法，这个时候study方法就会被加载进栈。

这个方法里的代码很简单，就是一句打印 “好好学习”。

![image-20240405181143470](./assets/image-20240405181143470.png)

当这句话打印完后，study方法就执行完毕，所以它就要从栈里面出去。

当study方法执行完毕后，整个main方法也执行完毕了，所以main方法也出栈了。

既然main方法都出去了，main中的变量也就随之消失了。所以 `s` 就会跟着消失。

当变量 `s` 消失的时候，变量指向的箭头，也就没有了。

![image-20240405181352212](./assets/image-20240405181352212.png)

针对右边的对象来讲，就没有人再去用这个对象了，专业是叫做：没有变量指向这个空间了。这个空间也会消失变成垃圾。

-----

## 四、两个对象的内存图

两个对象的内存图 其实就是将刚刚的 一个对象创建的过程 重复了两次而已。

![image-20240405181858001](./assets/image-20240405181858001.png)

由于前面的内存图解释都是一样的，我们直接跳到创建第2个对象的时候的内存图。

但是在正式的画内存图之前，问你一个问题：这一次 `.class` 字节码文件是否要再加载一次？

答案是不需要，因为在刚刚这个 class文件 已经加载过了，所以第二次在创建对象的时候，class文件不需要再加载了，直接用就可以了。

这个时候它还是在等号的左边来声明了一个局部变量，这个局部变量的名字叫做 `s2`，它以后能存储 `Student类` 对象的地址值。

再到了等号右边，因为有 `new` 关键字，所以同样也是在堆里面开辟了一块空间，这个里面也有 `name` 跟 `age`，下面也会有成员方法的地址，此时还会给里面的变量进行默认初始化、显示初始化、构造方法初始化。

最后将堆空间中的地址赋值给 `s2`。第二个对象的地址为 `002`。`s2` 通过 `002` 这个地址能找到第二块空间。

所以在下面，我直接打印 `s2` 的话，它打印的其实是 `s2` 记录的地址 `002`。

![image-20240405182644677](./assets/image-20240405182644677.png)

再往下赋值，是将 “阿珍” 赋值给了 `s2` 的 name ！而 `s2` 记录的地址值是 `002`，所以  “阿珍” 就赋值给了 `002` 的 name，24

 就是赋值给了 `002` 的 age。`002` 里面 null 跟 0 就被覆盖了。

要注意的是我现在操作的仅仅是 `002` 的这块空间，对 `001` 空间里面的值没有任何影响。它们是两个互相独立的空间、

![image-20240405182708728](./assets/image-20240405182708728.png)

再往下获取的是 `s2` 的 name 和 `s2` 的 age，而 `s2` 记录的是 `002` ，所以 `s2.name` 就是获取 `002` 里面的name，`s2.age` 获取的就是 `002` 里面的 `age`。

因此打印出来的就是 阿珍 和 24。

![image-20240405182859491](./assets/image-20240405182859491.png)

最后一步，它是通过 `s2` 去调用的 `study()` 方法。所以我们需要先通过 `s2` 去找到 `002` 这块空间，再通过 `002` 找到下面的 study方法，再把这个 study加载到栈里，打印里面的好好学习。

![image-20240405183251481](./assets/image-20240405183251481.png)

当study方法执行完毕，它就要出去。

当study方法执行完毕后，main方法也执行完毕，也要出去了。一旦main方法出去，变量 `s1` 跟 `s2` 也就没有了。针对于右边堆中的两个对象而言，就没有人再去使用这两个对象了。一旦没有人用它们，它们也就变成垃圾，这两个对象也就使用不了了。

![image-20240405183352885](./assets/image-20240405183352885.png)

----

## 五、两个引用指向同一个对象

由于 `Student stu2 = stu1;` 前面的代码和之前的代码都是一样的。

![image-20240405183644311](./assets/image-20240405183644311.png)

我们直接跳到 `Student stu2 = stu1;` 的地方。

这句话相当于把 `stu1` 变量里记录的东西赋值给 `stu2`。

在内存是这样的，它首先会去栈中声明一个 `stu2` 的小空间，这块空间的名字就叫做 `stu2`，这个类以后也能存储 `Student` 对象的地址值。此时它就将 `stu1` 记录的 `001` 赋值给了 `stu2`，所以一旦赋值完后，`stu2` 里面存的也就是 `001` 了。

此时 `stu2` 通过 `001` 也能找到右边的空间，这个就相当于两个变量都指向了同一个对象。

![image-20240405184105675](./assets/image-20240405184105675.png)

再往下看，`stu2.name = "阿珍"`，“阿珍”赋值给了 `stu2` 的 name，但此时 `stu2` 中记录的是 `001` ，所以这句话可以理解成：“阿珍” 赋值给了 `001` 的 name。`001` 里面 name 中存储的 阿强 就被 阿珍 给覆盖了。

![image-20240405184340410](./assets/image-20240405184340410.png)

此时再来执行最后一句话，由于 `stu1` 和 `stu2` 记录的都是 `001`，所以这句话就相当于在获取 `001` 的 `name` 和 `001` 的 `name`，即将 `001` 的 `name` 获取了两次，这个时候在代码中打印的就是 `阿珍...阿珍`。

![image-20240405184355932](./assets/image-20240405184355932.png)

代码继续往下，在代码当中有一些其他的情况需要考虑，那就是 `stu1 = null`。

`null` 就表示一个不存在的空间，相当于将 `stu1` 里面的 `001` 给覆盖了，这个时候这根线就断掉了。

![image-20240405184651808](./assets/image-20240405184651808.png)

再往下，再使用 `stu1.name` 再去获取的时候，`stu1`就已经找不到 `001` 了，因为中间的这个连接已经断开了。

所以此时在程序中就会触发 `NullPointerException` 异常。（空指针异常）

再往下获取 `stu2.name` ，`stu2`里是`001`，它没有被任何东西给覆盖，它还能获取到 `001` 的空间，找到里的阿珍并进行打印。

最后一行，再把 null 获取给 stu2 ，这就表示 stu2 里记录的地址也没有了，那么中间这根黑色的连接也就断开了。

![image-20240405185032881](./assets/image-20240405185032881.png)

一旦断开之后，右边的这个对象就没有人去用它了，一旦没有人用它，这个对象就会变成垃圾，以后就用不了了。

当这行代码执行完毕后，main方法所有代码就执行完毕了，main方法就会从栈中出去。

总结：当两个变量指向同一个对象时，只要有一个变量对这个空间里的值发生了改变，那么其他变量再次访问的时候，就是改变之后的结果了。



----

# 88.基本数据类型和引用数据类型

## 一、引入

在刚刚我们已经讲解了对象的内存图，那么通过这个内存图我们就可以把基本数据类型和引用数据类型最本质的区别给讲明白了。

在以前，我们学过基本数据类型是四类八种，而引用数据类型就是除了左边，其他所有的数据类型都是引用数据类型。

![image-20240405203807608](./assets/image-20240405203807608.png)

但是这种属于强行记忆，没有抓到问题的本质。说到本质，还是得来看看内存图。

----

## 二、基本数据类型

例如这段代码，`int a = 10;`，在内存当中它其实就是开辟了一个小空间，它的名字叫做 `a`，`int` 表示这个小空间中能存储 `int` 类型的整数。而整数 10，那就是真实存在当前小空间的数据，跟其他的空间是没有任何关系的。

例如此时再来定义一个 `double b = 20.0;`，那么在内存当中它就会开辟第二个空间，名字叫做 `b`，而 `20.0` 就是存储在第二个小空间里的，这个就是基本数据类型。

<img src="./assets/image-20240405204244782.png" alt="image-20240405204244782" style="zoom:67%;" />

所以说基本数据类型就是在变量当中它存储的是真实的数据值。

----

## 三、引用数据类型

### 1）对象

我们在代码当中创建的`任意的对象`、`数组`都是引用数据类型。

例如下面的代码 `Student s = new Student();`，这里的变量 `s` 就是引用数据类型。

当 main方法加载到内存后，我们主要的还是关注创建变量的这行代码。

![image-20240405204503907](./assets/image-20240405204503907.png)

在等号的左边它其实就是定义了一个变量，变量的名字就叫做 `s`，而 `Student` 就表示它能存储 `Student` 这个类对象的地址值。

这个对象里的数据 `name` 、`age` 不是存在变量 `s` 里面的，而是会在堆里开辟一个小空间，对象中真实的数据 `name` 、 `age` 是存储在堆里这个小空间中的。而左边的变量 `s` 记录的仅仅是其他小空间的地址值。因此 `s` 是引用数据类型，这里的`引用`就可以理解为叫做使用其他空间的数据。

![image-20240405204923093](./assets/image-20240405204923093.png)

---

### 2）数组

`int[] arr = {1, 2, 3, 4};` 代码中，等号的左边其实就是一个变量，变量的名字叫做 `arr`，`int[]` 表示这个空间能存储 `int类型数组` 的地址。

![image-20240405205209615](./assets/image-20240405205209615.png)

等号的右边就是在堆里面开辟了一个空间，里面存储的就是 `1, 2, 3, 4`，而左边的变量 `arr` 记录的并不是数组里真实的数据，而是其他空间的地址值。

如果我想要获取数组里面的数据，那只能先找到 `arr`，通过 `arr` 找到右边的这块空间，然后再通过 `索引` 获取里面的数据。此时这个标量 `arr` 我们就称之为叫做 `引用数据类型`。

![image-20240405205352230](./assets/image-20240405205352230.png)

这里的引用也可以理解为使用其他空间的意思。所以说引用，就是把别的空间的数据拿过来用。

---

## 四、总结

**基本数据类型**：数据值是存储在自己的空间中。

例如 `int a = 10;` ，这个 `10` 就存储在 `a` 空间中，不会跟其他的空间产生任何的关系。	![image-20240405205758143](./assets/image-20240405205758143.png)

**特点**：赋值给其他变量，也是赋的真实的值。

例如我们可以把 `a` 交给 `b`，此时赋给 `b` 的也是变量 `a` 里的真实的数据 `10`。	![image-20240405205811088](./assets/image-20240405205811088.png)

那如果我将变量 `b` 中的值发生了修改，此时是不会影响变量 `a` 里的值的。

----

**引用数据类型**：数据值是存储在其他空间中，自己空间中存储的是其他空间的地址值。

例如我们之前看见的学生对象，`s1` 中存的就是其它空间的地址值，假设是 `001`，在 `001` 这个空间里存储的的才是真实的数据。

**特点**：赋值给其他变量的时候，赋的是地址值。

例如 `Student s2 = s1;` ，将 `s1` 交给了 `s2`，真正交给 `s2` 的其实是 `s1` 中存储的地址值。这样就会形成两个变量指向同一个空间。如果有一个变量对这个空间里的值发生了修改，那么另外一个再次访问的时候，就是修改之后的结果。

![image-20240405210146049](./assets/image-20240405210146049.png)



----

# 89.this的内存原理

## 一、回顾 `this`

在之前我们学习过 `this` 关键字，它的作用就是 用来区分局部变量和成员变量重名的。

例如下面这段代码，如果直接在 `method()` 方法中直接打印 `age`，它就会触发就近原则，谁离它更近，它就会用谁。所以第一个打印语句会打印 `10`。但如果就是想使用成员变量的 `age`，就可以在 `age` 前面加上 `this.`，此时它就会打印 `0`。

![image-20240405210445835](./assets/image-20240405210445835.png)

----

## 二、this的内存原理

this的本质：它其实就表示所在方法调用者的地址值。

如下内存图，首先是main方法先进栈，然后执行main方法中第一行代码，这里用到了 `Student` 这个类，所以会把 `Student` 这个类的字节码文件加载到内存。

等号的左边其实是定一个了一个变量 `s`，所以在栈中会有一个变量 `s`。

等号的右边有一个 `new` 关键字，所以就是在堆当中开辟了一块空间。假设这块空间的地址值是 `001`。

空间里因为只有成员变量 `age`，所以在 `001` 的空间里也就只有一个成员变量 `age`。除此之外还会有成员方法的地址引用。

最后再把 `001` 这个地址值赋值给左边的变量 `s`。

这些都是之前讲过的，暂时还没有涉及到 `this` 关键字。

![image-20240405211012339](./assets/image-20240405211012339.png)

但是下面的调用method方法就非常重要了。

`method方法` 是被 `s` 调用的，所以方法里记录的调用者的地址值就是 `001`，那么 `this` 记录的也是 `001`，这点非常的关键，因为 `this` 的本质是代表方法调用者的地址值。由于 `mehtod` 方法 是 `s` ，即 `001` 调用的，所以 `this` 记录的就是 `001`。

![image-20240405211419464](./assets/image-20240405211419464.png)

接下来我们看方法里面代码的执行情况。

第一行代码定义变量 `age`，所以在 `method方法` 里面就定义了一个叫做 `age` 的变量，里面记录的是数据 `10`。

再往下打印 `age`，此时它前面是没有 `this`，所以就触发就近原则，很显然，肯定是本方法中的 `age` 离它更近，所以在控制台就会打印 `10`。

最后一行代码打印 `this.age`。由于 `this` 代表方法调用者的地址值，现在 `this` 记录的是 `001` ，所以 `this.age` 这句话可以看成：我要获取 `001` 里面的 `age`。而 `001` 就是右边的这块空间，所以我们获取的其实就是这块空间里面的 `0`。

![image-20240405211710703](./assets/image-20240405211710703.png)

----

## 三、set方法中this的内存原理

创建了一个对象之后，set方法里也有 `this`，那set方法中的 `this` 是怎么给对象进行赋值的呢？

我们也通过内存图来看一下。

先来看左边的代码，首先利用空参，创建了两个学生对象，然后通过 `set方法` 分别对两个学生对象赋值，分别是 “竹小玲”、“桥小九”。

首先还是老套路，main方法首先进栈，然后再来执行里面的第一行代码。

`Student s1 = new Student();`，等号的左边相当于就是在main中创建了一个变量 `s1`，等号的右边因为有 `new` 关键字，所以就是在堆中开辟了一段空间。假设这段空间地址是 `001`，那么 `s1` 记录的就是 `001`。

![image-20240405213040901](./assets/image-20240405213040901.png)

接下来我们就可以利用 `s1` 去调用 `set` 方法进行赋值了。

首先 `setName()` 方法就会被加载进栈，方法里面有一个形参。所以在调用 `setName()` 方法的时候，它就会接收实际参数`“竹小玲”`。

![image-20240405213332975](./assets/image-20240405213332975.png)

而在内存当中，方法的形参其实也就是一个变量。所以此时这个变量就有值了，这个值就是传递过来的``。

由于 `setName` 方法是由 `s1` 调用的，所以方法调用者的地址值就是 `001`。

而我们曾经讲过，this的本质是：代表方法调用者的地址值。

因此，方法中的 `this` 也就记录了 `001` 地址。

![image-20240405213530212](./assets/image-20240405213530212.png)

关键来了，来看看方法里面的这行代码。

`this.name = name;`。等号的右边有个 `name`，这个 `name` 前面是没有 `this`的，所以就触发了就近原则，它就表示是形参 `name`。而形参记录的是`“竹小玲”`，所以我们现在认为等号的右边就是 `“竹小玲”`。

等号的左边它是用 `this` 去调用的name，而在刚刚的内存图中我们看见了，`this` 就表示调用者的地址值，也就是 `001`。所以说整句话的意思就是：把 `“朱小玲”` 赋值给 `001` 里面的 `name`，而 `001` 就是我们右边的这个空间，所以 `001` 里面的 `name` 就变成了 `“竹小玲”`。

![image-20240405214111808](./assets/image-20240405214111808.png)

赋值完毕后，方法执行完了，`setName()` 就会出栈。然后继续往下，再来创建第二个学生对象。这个过程跟刚刚其实是类似的。

等号的左边就是在方法里面定义了一个变量 `s2`，等号的右边就是在堆里面又开辟了一个新的小空间。假设第二个小空间的地址值是 `002`，那么 `s2` 记录的地址值就是 `002`。

接下来我们用 `s2` 去调用了 `setName()` 方法，`setName()` 也需要被加载进栈。

同样的，方法里面也是有一个形参 `name`，所以说在调用方法的时候，它就会接受实际参数 `“桥小九”`。而内存中，方法的形参其实也就是一个变量，所以这个变量现在也就有值了，那就是 `“桥小九”`。

除此之外我们还要知道，`setName()` 方法在第二次调用的时候，是 `s2` 调的。所以现在方法调用者的地址值就变成了 `002`。而方法里的 `this` 既然代表方法者的地址值，所以第二次调用 `set` 方法的时候，里面的 `this` 记录的就是 `002`。

![image-20240405214623450](./assets/image-20240405214623450.png)

下面再来看，关键代码又来了。

`this.name = name;`。等号的右边前面是没有 `this` 的，所以触发了就近原则，它就是这里的形参 `name`，而形参记录的是上面的 `“桥小九”`。而现在 `setName()` 方法第二次被调用的时候，这里的 `this` 记录的就是 `002`。所以这整句话的意思就是：我要把 `“桥小九”` 赋值给 `002` 的 `name`。而 `002` 就是堆里面第二个小空间，所以 `002` 里面的 `name` 就变成了 `“桥小九”`。此时对第一个空间里面是没有任何影响的，`setName()` 方法执行完毕后，同样也会出栈，这个就是它赋值的整个过程。

![image-20240405214955138](./assets/image-20240405214955138.png)

----

## 四、总结

来看一下刚刚两次调用 `setName()` 的方法。第一次是被 `s1` 调用的，所以第一次 `this` 记录的就是 `001` 的地址值。第二次是被 `002` 给调用的，`this` 记录的就是 `002` 的地址。

上面过程有点复杂，我们只需要记住一句话就行了： `this` 的本质是 —— 所在方法调用者的地址值。



---

# 90.成员变量和局部变量的区别

## 一、前言

成员变量和局部变量的区别有很多，不需要记。学完了这个知识点后，我们只要知道什么是局部变量，什么是成员变量就可以了。在之前我们经常的使用它们。

----

## 二、成员变量

成员变量：类中、方法外的变量。

例如下面代码，类中、方法外有两个变量 `name` 和 `age`。这两个都是成员变量。

![image-20240405215627268](./assets/image-20240405215627268.png)

成员变量它是没有上下顺序的，没有规定谁一定要写在上面。只不过我们平时在写代码的时候，为了方便阅读，一般来讲都是把它们写在最上面的。

---

## 三、局部变量

局部变量：方法中的变量。

再来看刚刚的代码，蓝色部分，`i` 和 下面的 `j` 都是局部变量

![image-20240405215737045](./assets/image-20240405215737045.png)

----

## 四、成员变量和局部变量区别

|     区别     |                  成员变量                  |                    局部变量                    |
| :----------: | :----------------------------------------: | :--------------------------------------------: |
| 类中位置不同 |                类中，方法外                |               方法内、方法声明上               |
| 初始化值不同 |               有默认初始化值               |           没有，使用之前需要完成赋值           |
| 内存位置不同 |               堆内存的对象中               |                  栈里的方法中                  |
| 生命周期不同 | 随着对象的创建而存在，随着对象的消失而消失 | 随着方法的调用而存在，随着方法的运行结束而消失 |
|    作用域    |                整个类中有效                |                 当前方法中有效                 |

----

## 五、通过内存图解释

在下面测试类中，首先我们定义了一个变量 `a`，这个变量在方法里面，所以它是局部变量。

然后我们又创建了一个 `Student` 对象。在这个 `Student` 里面它有两个成员变量：`name` 和 `age`。

接下来看内存图。首先还是 `main方法` 先进栈，第一行代码 `int a = 10;` 就是定义了一个变量 `a`，这个变量 `a` 就是在栈里面的，它就是局部变量。

而第2行代码就是创建了一个 `Student` 对象，相当于是在堆中开辟了一块空间。这个空间里有 `name`，有 `age`，这里的 `name` 跟 `age` 是成员变量，所以就是在堆当中，它们都是有默认初始化值的。引用数据类型默认初始化值是 `null`，`age` 是整数类型，所以它的默认初始化值是 `0`。

![image-20240406112234617](./assets/image-20240406112234617.png)

当 `main方法` 执行完毕后就要出栈。一旦出栈后，`main方法` 里的变量 `a` 就会从内存中消失。

右边创建出来的对象，如果没有变量去指向它，这个对象也会变成垃圾。它里面的 `name`、`age` 也就无法使用了

![image-20240406112400902](./assets/image-20240406112400902.png)



----

# ------------------------------

# Day8  面向对象综合训练



# 91.文字版格斗游戏 

## 一、练习一：文字版格斗游戏 

需求：格斗游戏，每个游戏角色的姓名，血量，都不相同，在选定人物的时候（new对象的时候），这些信息就应该被确定下来。 

举例：

​	程序运行之后结果为：

​	姓名为:乔峰		血量为:100

​	姓名为:鸠摩智	血量为:100

​	乔峰举起拳头打了鸠摩智一下，造成了XX点伤害，鸠摩智还剩下XXX点血。

​	鸠摩智举起拳头打了鸠摩智一下，造成了XX点伤害，乔峰还剩下XXX点血。

​	乔峰举起拳头打了鸠摩智一下，造成了XX点伤害，鸠摩智还剩下XXX点血。

​	鸠摩智举起拳头打了鸠摩智一下，造成了XX点伤害，乔峰还剩下XXX点血。

​	乔峰K.O.了鸠摩智 

代码示例：

Role.java

~~~java
package com.itheima.test1;

import java.util.Random;

public class Role {
    private String name;
    private int blood;

    public Role() {
    }

    public Role(String name, int blood) {
        this.name = name;
        this.blood = blood;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getBlood() {
        return blood;
    }

    public void setBlood(int blood) {
        this.blood = blood;
    }


    //定义一个方法用于攻击别人
    //思考：谁攻击谁？
    //Role r1 = new Role（）；
    //Role r2 = new Role（）；
    //r1.攻击(r2);
    //方法的调用者去攻击参数
    public void attack(Role role) {
        //计算造成的伤害 1 ~ 20
        Random r = new Random();
        int hurt = r.nextInt(20) + 1;

        //剩余血量
        int remainBoold = role.getBlood() - hurt;
        //对剩余血量做一个验证，如果为负数了，就修改为0
        remainBoold = remainBoold < 0 ? 0 : remainBoold;
        //修改一下挨揍的人的血量
        role.setBlood(remainBoold);

        //this表示方法的调用者
        System.out.println(this.getName() + "举起拳头，打了" + role.getName() + "一下，" +
                "造成了" + hurt + "点伤害，" + role.getName() + "还剩下了" + remainBoold + "点血");
    }
}
~~~

GameTest.java

```java
package com.itheima.test1;

public class GameTest {
    public static void main(String[] args) {
        //1.创建第一个角色
        Role r1 = new Role("乔峰",100);
        //2.创建第二个角色
        Role r2 = new Role("鸠摩智",100);

        //3.开始格斗 回合制游戏
        while(true){
            //r1开始攻击r2
            r1.attack(r2);
            //判断r2的剩余血量
            if(r2.getBlood() == 0){
                System.out.println(r1.getName() + " K.O了" + r2.getName());
                break;
            }

            //r2开始攻击r1
            r2.attack(r1);
            if(r1.getBlood() == 0){
                System.out.println(r2.getName() + " K.O了" + r1.getName());
                break;
            }
        }
    }
}
```

---

## 二、练习二：文字版格斗游戏进阶

在上一个的基础上，我想看到人物的性别和长相，打斗的时候我想看到武功招式。

举例：

​	程序运行之后结果为：

​	姓名为:乔峰		血量为:100	性别为:男	长相为:气宇轩昂

​	姓名为:鸠摩智	血量为:100	性别为:男	长相为:气宇轩昂

​	乔峰使出了一招【背心钉】，转到对方的身后，一掌向鸠摩智背心的灵台穴拍去。给鸠摩智造成一处瘀伤。

​	鸠摩智使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向乔峰。结果乔峰退了半步，毫发无损。 

​	。。。。

​	乔峰K.O.了鸠摩智 

分析：长相是提前定义好的，提前放在一个数组当中，程序运行之后，从数组中随机获取。

```java
//男生长相数组
String[] boyfaces = {"风流俊雅", "气宇轩昂", "相貌英俊", "五官端正", "相貌平平", "一塌糊涂", "面目狰狞"};
//女生长相数组
String[] girlfaces = {"美奂绝伦", "沉鱼落雁", "婷婷玉立", "身材娇好", "相貌平平", "相貌简陋", "惨不忍睹"};
```

武功招式也是提前定义好的，提前放在一个数组当中，程序运行之后，从数组随机获取

```java
//attack 攻击描述：
String[] attacks_desc = {
    "%s使出了一招【背心钉】，转到对方的身后，一掌向%s背心的灵台穴拍去。",
    "%s使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向%s。",
    "%s大喝一声，身形下伏，一招【劈雷坠地】，捶向%s双腿。",
    "%s运气于掌，一瞬间掌心变得血红，一式【掌心雷】，推向%s。",
    "%s阴手翻起阳手跟进，一招【没遮拦】，结结实实的捶向%s。",
    "%s上步抢身，招中套招，一招【劈挂连环】，连环攻向%s。"
```

受伤的提前也是提前定义好的，只不过不是随机了，根据剩余血量获取不同的描述

```java
//injured 受伤描述：
String[] injureds_desc = {
    "结果%s退了半步，毫发无损",
    "结果给%s造成一处瘀伤",
    "结果一击命中，%s痛得弯下腰",
    "结果%s痛苦地闷哼了一声，显然受了点内伤",
    "结果%s摇摇晃晃，一跤摔倒在地",
    "结果%s脸色一下变得惨白，连退了好几步",
    "结果『轰』的一声，%s口中鲜血狂喷而出",
    "结果%s一声惨叫，像滩软泥般塌了下去"
```

----

## 三、`%s`

其中输出语句跟以前不一样了，用的是 `System.out.printf( );`该输出语句支持%s占位符。注意不是 `sout`，而是 `souf`！！！

`System.out.printf( );` 这个输出语句只能做一个输出，它没有换行效果。如果想要换行，则需要在两个 `souf` 语句中间加一个 `System.out.println();` 语句。

```java
public class Test {
    public static void main(String[] args) {
        //两部分参数：
        //第一部分参数：要输出的内容%s（可以理解为占位）
        //第二部分参数：填充的数据
        
        System.out.printf("你好啊%s","张三");//用张三填充第一个%s
        System.out.println();//换行
        // 一旦写了两个占位，后面也需要拿着两个数据去填。如果有两个占位，却只使用了一个数据填，就会报错！
        System.out.printf("%s你好啊%s","张三","李四");//用张三填充第一个%s，李四填充第二个%s
    }
}
```

最终代码示例：

```java
package com.itheima.test2;

import java.util.Random;

public class Role {
    private String name;
    private int blood;
    private char gender;
    private String face;//长相是随机的

    String[] boyfaces = {"风流俊雅", "气宇轩昂", "相貌英俊", "五官端正", "相貌平平", "一塌糊涂", "面目狰狞"};
    String[] girlfaces = {"美奂绝伦", "沉鱼落雁", "婷婷玉立", "身材娇好", "相貌平平", "相貌简陋", "惨不忍睹"};

    //attack 攻击描述：
    String[] attacks_desc = {
            "%s使出了一招【背心钉】，转到对方的身后，一掌向%s背心的灵台穴拍去。",
            "%s使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向%s。",
            "%s大喝一声，身形下伏，一招【劈雷坠地】，捶向%s双腿。",
            "%s运气于掌，一瞬间掌心变得血红，一式【掌心雷】，推向%s。",
            "%s阴手翻起阳手跟进，一招【没遮拦】，结结实实的捶向%s。",
            "%s上步抢身，招中套招，一招【劈挂连环】，连环攻向%s。"
    };

    //injured 受伤描述：
    String[] injureds_desc = {
            "结果%s退了半步，毫发无损",
            "结果给%s造成一处瘀伤",
            "结果一击命中，%s痛得弯下腰",
            "结果%s痛苦地闷哼了一声，显然受了点内伤",
            "结果%s摇摇晃晃，一跤摔倒在地",
            "结果%s脸色一下变得惨白，连退了好几步",
            "结果『轰』的一声，%s口中鲜血狂喷而出",
            "结果%s一声惨叫，像滩软泥般塌了下去"
    };

    public Role() {
    }

    public Role(String name, int blood, char gender) {
        this.name = name;
        this.blood = blood;
        this.gender = gender;
        //随机长相
        setFace(gender);
    }


    public char getGender() {
        return gender;
    }

    public void setGender(char gender) {
        this.gender = gender;
    }

    public String getFace() {
        return face;
    }

    public void setFace(char gender) {
        Random r = new Random();
        //长相是随机的
        if (gender == '男') {
            //从boyfaces里面随机长相
            int index = r.nextInt(boyfaces.length);
            this.face = boyfaces[index];
        } else if (gender == '女') {
            //从girlfaces里面随机长相
            int index = r.nextInt(girlfaces.length);
            this.face = girlfaces[index];
        } else {
            this.face = "面目狰狞";
        }


    }


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getBlood() {
        return blood;
    }

    public void setBlood(int blood) {
        this.blood = blood;
    }


    //定义一个方法用于攻击别人
    //思考：谁攻击谁？
    //Role r1 = new Role（）；
    //Role r2 = new Role（）；
    //r1.攻击(r2);
    //方法的调用者去攻击参数
    public void attack(Role role) {
        Random r = new Random();
        int index = r.nextInt(attacks_desc.length);
        String KungFu = attacks_desc[index];

        //输出一个攻击的效果
        System.out.printf(KungFu, this.getName(), role.getName());
        System.out.println();

        //计算造成的伤害 1 ~ 20
        int hurt = r.nextInt(20) + 1;

        //剩余血量
        int remainBoold = role.getBlood() - hurt;
        //对剩余血量做一个验证，如果为负数了，就修改为0
        remainBoold = remainBoold < 0 ? 0 : remainBoold;
        //修改一下挨揍的人的血量
        role.setBlood(remainBoold);

        //受伤的描述
        //血量> 90 0索引的描述
        //80 ~  90  1索引的描述
        //70 ~  80  2索引的描述
        //60 ~  70  3索引的描述
        //40 ~  60  4索引的描述
        //20 ~  40  5索引的描述
        //10 ~  20  6索引的描述
        //小于10的   7索引的描述
        if (remainBoold > 90) {
            System.out.printf(injureds_desc[0], role.getName());
        }else if(remainBoold > 80 && remainBoold <= 90){ // 后面这段代码 remainBoold <= 90 是可以省略的，但为了提高程序的可阅读性，这里还是加上了。
            System.out.printf(injureds_desc[1], role.getName());
        }else if(remainBoold > 70 && remainBoold <= 80){
            System.out.printf(injureds_desc[2], role.getName());
        }else if(remainBoold > 60 && remainBoold <= 70){
            System.out.printf(injureds_desc[3], role.getName());
        }else if(remainBoold > 40 && remainBoold <= 60){
            System.out.printf(injureds_desc[4], role.getName());
        }else if(remainBoold > 20 && remainBoold <= 40){
            System.out.printf(injureds_desc[5], role.getName());
        }else if(remainBoold > 10 && remainBoold <= 20){
            System.out.printf(injureds_desc[6], role.getName());
        }else{
            System.out.printf(injureds_desc[7], role.getName());
        }
        System.out.println(); // 换行
    }

    public void showRoleInfo() {
        System.out.println("姓名为：" + getName());
        System.out.println("血量为：" + getBlood());
        System.out.println("性别为：" + getGender());
        System.out.println("长相为：" + getFace());
    }
}
```

GameTest

~~~java
package com.itheima.test2;

public class GameTest {
    public static void main(String[] args) {
        //1.创建第一个角色
        Role r1 = new Role("乔峰",100,'男');
        //2.创建第二个角色
        Role r2 = new Role("鸠摩智",100,'男');

        //展示一下角色的信息
        r1.showRoleInfo();
        r2.showRoleInfo();

        //3.开始格斗 回合制游戏
        while(true){
            //r1开始攻击r2
            r1.attack(r2);
            //判断r2的剩余血量
            if(r2.getBlood() == 0){
                System.out.println(r1.getName() + " K.O了" + r2.getName());
                break;
            }

            //r2开始攻击r1
            r2.attack(r1);
            if(r1.getBlood() == 0){
                System.out.println(r2.getName() + " K.O了" + r1.getName());
                break;
            }
        }
    }
}
~~~



----

# 92.两个对象数组练习

## 一、练习三：对象数组（商品）

需求：

​	定义数组存储3个商品对象。

​	商品的属性：商品的id，名字，价格，库存。

​	创建三个商品对象，并把商品对象存入到数组当中。

> 扩展快捷键：例如 `Goods g1 = new Goods();` 中，我相对 `g1` 在创建对象的时候同时进行初始化，那小括号里面那些参数的顺序我需要点开 `Goods` 类一个一个对比着看吗？这是不需要的。
>
> 这里我们只需要用鼠标点击一下小括号，然后按快捷键 <kbd>ctrl + p</kbd> 。此时就会把方法所对应的参数给你做一个展示。
>
> 此时会展现两个，第一个叫：`<no parameters>` ，表示没参数，你可以什么都不传。第二个就是有参构造的
>
> ![image-20240406120822866](./assets/image-20240406120822866.png)

代码示例：

```java
package com.itheima.test3;

public class Goods {
    private String id;
    private String name;
    private double price; // 价格
    private int count; // 库存

    public Goods() {
    }

    public Goods(String id, String name, double price, int count) {
        this.id = id;
        this.name = name;
        this.price = price;
        this.count = count;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public int getCount() {
        return count;
    }

    public void setCount(int count) {
        this.count = count;
    }
}

```

GoodsTest.java

~~~java
package com.itheima.test3;

public class GoodsTest {
    public static void main(String[] args) {
        //1.创建一个数组
        Goods[] arr = new Goods[3];

        //2.创建三个商品对象
        Goods g1 = new Goods("001","华为P40",5999.0,100);
        Goods g2 = new Goods("002","保温杯",227.0,50);
        Goods g3 = new Goods("003","枸杞",12.7,70);

        //3.把商品添加到数组中
        arr[0] = g1; // 把第一个商品对象放到了 0 索引。
        arr[1] = g2;
        arr[2] = g3;

        //4.遍历
        for (int i = 0; i < arr.length; i++) {
            //i表示的数组里的索引， arr[i]表示元素
            Goods goods = arr[i];
            System.out.println(goods.getId() + ", " + goods.getName() + ", " + goods.getPrice() + ", " + goods.getCount());
        }
    }
}
~~~

----

## 二、键盘录入涉及到的方法

### 1）前言

在之前，我们学习过键盘录入的一个方法，那就是 `nextInt()`。这个方法表示你可以录入整数，但如果你录入小数，或者字符串，这个方法就会报错。但如果我想要接收其他的数据类型怎么办呢？在Java中也有其他的方法。

键盘录入一共有以下几种：`next()`、`nextLine()`、`nextInt()`、`nextDouble()`。

----

### 2）第一套体系：`nextInt()`、`next()`、`nextDouble()`

|      方法      |                             使用                             |
| :------------: | :----------------------------------------------------------: |
|  `nextInt()`   |  只能接收整数。如果录入小数，或者字符串，这个方法就会报错。  |
| `nextDouble()` | 能接收整数和小数，但是都会看做小数返回。<br />例如你录入的是 `10`，但是它也会按照 `10.0` 的形式返回。录入字母会报错。 |
|    `next()`    | 可以接受任意数据，但是都会返回一个字符串。例如键盘录入 `123`，但是它也是以字符串的形式来体现的。<br />比如：键盘录入abc，那么会把abc看做字符串返回。键盘录入123，那么会把123看做字符串返回。 |

`next()`，`nextInt()`，`nextDouble()` 在接收数据的时候，会遇到空格，回车，制表符其中一个就会停止接收数据，这些符号后面的数据就不会接收了。

并且在进行读取的时候，会自动跳过前面的结束符，直到读取一个有效的字符串之后，这些方法才会将其后输入的空格键、Tab键或Enter键等视为结束符。

**代码示例**

示例1

~~~java
Scanner sc = new Scanner(System.in);
System.out.println("请输入一个整数");
int num1 = sc.nextInt(); // 1.假设输入的是 "123 123"，但是 sc.nextInt() 遇到 "空格" 就停止接收了，所以下面 num1 打印出来的就是 123。但此时在内存里面还有剩下来的数据 " 123"，此时 " 123"就会给下面的第二次键盘录入的数据去接收。
System.out.println(num1); // 2.打印 "123"
System.out.println("请输入第二个整数"); // 3.相当于输入的是 " 123"，但是nextInt()在进行读取的时候，会自动跳过前面的结束符，所以 nextInt() 读取的就是 "123"
int num2 = sc.nextInt(); // 4.打印出来的就是 "123"
System.out.println(num2);
~~~

示例2

~~~java
Scanner sc = new Scanner(System.in);
System.out.println("请输入一个字符串");
String str1 = sc.next();// 1.输入 "abc bcd"，此时 str1 就会读取前面的 "abc"，剩下的 " bcd" 留在内存
System.out.println(str1);
System.out.println("请输入第二个字符串");
String str2 = sc.next(); // 2.接收到内存剩下的" bcd"，但是next()在进行读取的时候，会自动跳过前面的结束符，所以 next() 读取的就是 "bcd"
System.out.println(str2);
~~~

----

### 3）第二套体系：`nextLine()`

`nextLine()` 方法是把一整行全部接收完毕，对应了方法名中的 `line`。它可以接收空格，制表符，遇到回车才停止接收数据。

**代码示例**

```java
Scanner sc = new Scanner(System.in);
System.out.println("请输入一个字符串");
String line1 = sc.nextLine();// 输入"abc bcd"
System.out.println(line1); // 输出 abc bcd
System.out.println("请输入第二个字符串");
String line2 = sc.nextLine(); // 输入 "123 789"
System.out.println(line2); // 输出 "123 789"
```

----

### 4）混用引起的后果

上面说的两套键盘录入不能混用，如果混用会有严重的后果。

代码示例：

```java
Scanner sc = new Scanner(System.in);
int i = sc.nextInt(); // 输入的是 "123"，但其实我录入的是 "123 + 回车"，此时nextInt只接收了123，但回车还在内存里面！
String s = sc.nextLine(); // 此时nextLine就会接收内存中剩下的回车。
System.out.println(i); 
System.out.println(s);
```

当代码运行到第二行，会让我们键盘录入，此时录入123。但是实际上我们录的是 `123 + 回车` 。

而nextInt是遇到空格，回车，制表符都会停止。所以nextInt只能接收123，回车符还在内存中没有被接收。此时就被 `nextLine()` 接收了，打印出来的就是 `回车换行`。所以，如果混用就会导致nextLine接收不到数据。

----

### 5）结论 & 建议

- next（）、nextInt（）、nextDouble（）这三个配套使用。

如果用了这三个其中一个，就不要用nextLine（）。

- nextLine（）需要单独使用。

如果想要整数，那么先接收，再使用Integer.parseInt进行类型转换。

**代码示例**

```java
Scanner sc = new Scanner(System.in);
String s = sc.nextLine(); // 键盘录入123
System.out.println("此时为字符串" + s); // 此时123是字符串
int i = Integer.parseInt(s); // 想要整数再进行转换
System.out.println("此时为整数：" + i);
```

----

## 三、练习四：对象数组（汽车）

需求：定义数组存储3部汽车对象。

​	汽车的属性：品牌，价格，颜色。

​	创建三个汽车对象，数据通过键盘录入而来，并把数据存入到数组当中。

**代码示例**

Car.java

```java
package com.itheima.test5;

public class Car {
    private String brand;//品牌
    private int price;//价格
    private String color;//颜色

    public Car() {
    }

    public Car(String brand, int price, String color) {
        this.brand = brand;
        this.price = price;
        this.color = color;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }
}
```

CarTest.java

~~~java
package com.itheima.test5;

import java.util.Scanner;

public class CarTest {
    public static void main(String[] args) {
        //1.创建一个数组用来存3个汽车对象
        Car[] arr = new Car[3];

        //2.创建汽车对象，数据来自于键盘录入
        Scanner sc = new Scanner(System.in);
        for (int i = 0; i < arr.length; i++) {
            //创建汽车的对象，这个代码只能放在for里面，每次都需要创建一个新的对象
            Car c = new Car();
            //录入品牌
            System.out.println("请输入汽车的品牌");
            String brand = sc.next();
            c.setBrand(brand);
            //录入价格
            System.out.println("请输入汽车的价格");
            int price = sc.nextInt();
            c.setPrice(price);
            //录入颜色
            System.out.println("请输入汽车的颜色");
            String color = sc.next();
            c.setColor(color);

            //把汽车对象添加到数组当中
            arr[i] = c;
        }

        //3.遍历数组
        for (int i = 0; i < arr.length; i++) {
            Car car = arr[i];
            System.out.println(car.getBrand() + ", " + car.getPrice() + ", " + car.getColor());
        }
    }
}
~~~



----

# 93.对象数组练习

## 一、练习五：对象数组（手机）

需求 :  定义数组存储3部手机对象。

​	手机的属性：品牌，价格，颜色。

​	要求，计算出三部手机的平均价格

**代码示例**

Phone.java

```java
package com.itheima.test6;

public class Phone {
    private String brand;//品牌
    private int price;//价格
    private String color;//颜色

    public Phone() {
    }

    public Phone(String brand, int price, String color) {
        this.brand = brand;
        this.price = price;
        this.color = color;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }
}
```

PhoneTest.java

~~~java
package com.itheima.test6;

import java.math.BigDecimal;

public class PhoneTest {
    public static void main(String[] args) {
        //1.创建一个数组
        Phone[] arr = new Phone[3];

        //2.创建手机的对象
        Phone p1 = new Phone("小米",1999,"白色");
        Phone p2 = new Phone("华为",4999,"蓝色");
        Phone p3 = new Phone("魅族",3999,"红色");

        //3.把手机对象添加到数组当中
        arr[0] = p1;
        arr[1] = p2;
        arr[2] = p3;

        //4.获取三部手机的平均价格
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            //i表示的是索引  arr[i]表示的是元素（在这里就是手机对象）
            Phone phone = arr[i];
            sum = sum + phone.getPrice();
        }

        //5.求平均值
        //建议：数据能不写死，尽量不写死
        //int avg = sum / arr.length; // 这样打印出来的只能是整数

        double avg2 = sum * 1.0 / arr.length; // 整数操作只能得到整数，想要得到小数，必须有浮点数参与运算

        System.out.println(avg2);//3665.6666666666665，在代码中，如果有小数参与计算，结果有可能不精确的
        // 如果想要精确运算，并且小数点后面想要保留两位、四舍五入等等，使用 BigDecimal 就可以实现精确运算了
    }
}
~~~

----

## 二、练习六：对象数组（女朋友）

需求：定义数组存储4个女朋友的对象。女朋友的属性：姓名、年龄、性别、爱好

​	要求1：计算出四女朋友的平均年龄

​	要求2：统计年龄比平均值低的女朋友有几个？并把她们的所有信息打印出来。

**代码示例**

GirlFriend.java

```java
package com.itheima.test7;

public class GirlFriend {
    private String name;//姓名
    private int age;//年龄
    private String gender;//性别
    private String hobby;//爱好


    public GirlFriend() {
    }

    public GirlFriend(String name, int age, String gender, String hobby) {
        this.name = name;
        this.age = age;
        this.gender = gender;
        this.hobby = hobby;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public String getHobby() {
        return hobby;
    }

    public void setHobby(String hobby) {
        this.hobby = hobby;
    }
}
```

GirlFriendTest.java

~~~java
package com.itheima.test7;

public class GirlFriendTest {
    public static void main(String[] args) {
        //1.定义数组存入女朋友的对象
        GirlFriend[] arr = new GirlFriend[4];

        //2.创建女朋友对象
        GirlFriend gf1 = new GirlFriend("小诗诗",18,"萌妹子","吃零食");
        GirlFriend gf2 = new GirlFriend("小丹丹",19,"萌妹子","玩游戏");
        GirlFriend gf3 = new GirlFriend("小惠惠",20,"萌妹子","看书，学习");
        GirlFriend gf4 = new GirlFriend("小莉莉",21,"憨妹子","睡觉");

        //3.把对象添加到数组当中
        arr[0] = gf1;
        arr[1] = gf2;
        arr[2] = gf3;
        arr[3] = gf4;

        //4.求和
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            //i表示的是索引，arr[i]表示的是数组中的元素（这就指的就是女朋友对象）
            GirlFriend gf = arr[i];
            //累加
            sum = sum + gf.getAge();
        }

        //5.平均值
        int avg = sum / arr.length;

        //6.统计年龄比平均值低的有几个，打印他们的信息
        int count = 0;
        for (int i = 0; i < arr.length; i++) {
            GirlFriend gf = arr[i];
            if(gf.getAge() < avg){
                count++;
                System.out.println(gf.getName() + ", " + gf.getAge() + ", " + gf.getGender() + ", " + gf.getHobby());
            }
        }

        System.out.println(count + "个");
    }
}
~~~



---

# 94.练习七：复杂的对象数组操作

定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。

学生的属性：学号，姓名，年龄。

要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。

要求2：添加完毕之后，遍历所有学生信息。

要求3：通过id删除学生信息

​             如果存在，则删除，如果不存在，则提示删除失败。

要求4：删除完毕之后，遍历所有学生信息。

要求5：查询数组id为“2”的学生，如果存在，则将他的年龄+1岁

**代码示例**

Student.java

```java
package com.itheima.test8;

public class Student {
    private int id;
    private String name;
    private int age;

    public Student() {
    }

    public Student(int id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

## 1）Test.java

这个 Test 先写 `要求1` 和 `要求2` 。

要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。

要求2：添加完毕之后，遍历所有学生信息。

```java
package com.itheima.test8;

public class Test {
    public static void main(String[] args) {
        /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。
        学生的属性：学号，姓名，年龄。
        要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。
        要求2：添加完毕之后，遍历所有学生信息。

        要求3：通过id删除学生信息
        如果存在，则删除，如果不存在，则提示删除失败。
        要求4：删除完毕之后，遍历所有学生信息。
        要求5：查询数组id为“heima002”的学生，如果存在，则将他的年龄+1岁*/


        //1.创建一个数组用来存储学生对象
        Student[] arr = new Student[3];
        //2.创建学生对象并添加到数组当中
        Student stu1 = new Student(1, "zhangsan", 23);
        Student stu2 = new Student(2, "lisi", 24);

        //3.把学生对象添加到数组当中
        arr[0] = stu1;
        arr[1] = stu2;


        //要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。
        Student stu4 = new Student(4, "zhaoliu", 26);

        //唯一性判断
        //已存在 --- 不用添加
        //不存在 --- 就可以把学生对象添加进数组
        boolean flag = contains(arr, stu4.getId());
        if(flag){
            //已存在 --- 不用添加
            System.out.println("当前id重复，请修改id后再进行添加");
        }else{
            //不存在 --- 就可以把学生对象添加进数组
            //把stu4添加到数组当中
            //1.数组已经存满 --- 只能创建一个新的数组，新数组的长度 = 老数组 + 1
            //2.数组没有存满 --- 直接添加
            int count = getCount(arr);
            if(count == arr.length){
                //已经存满
                //创建一个新的数组，长度 = 老数组的长度 + 1
                //然后把老数组的元素，拷贝到新数组当中
                Student[] newArr = creatNewArr(arr);
                //把stu4添加进去
                newArr[count] = stu4;

                //要求2：添加完毕之后，遍历所有学生信息。
                printArr(newArr);
            }else{
                //没有存满
                //[stu1,stu2,null]
                //getCount获取到的是2，表示数组当中已经有了2个元素
                //还有一层意思：如果下一次要添加数据，就是添加到2索引的位置
                arr[count] = stu4;
                //要求2：添加完毕之后，遍历所有学生信息。
                printArr(arr);
            }
        }
    }


    public static void printArr(Student[] arr){
        for (int i = 0; i < arr.length; i++) {
            Student stu = arr[i];
            if(stu != null){
                System.out.println(stu.getId() + ", " + stu.getName() + ", " + stu.getAge());
            }
        }
    }

    //创建一个新的数组，长度 = 老数组的长度 + 1
    //然后把老数组的元素，拷贝到新数组当中
    public static Student[] creatNewArr(Student[] arr){
        Student[] newArr = new Student[arr.length + 1];

        //循环遍历得到老数组中的每一个元素
        for (int i = 0; i < arr.length; i++) {
            //把老数组中的元素添加到新数组当中
            newArr[i] = arr[i];
        }

        //把新数组返回
        return newArr;
    }

    //定义一个方法判断数组中已经存了几个元素
    public static int getCount(Student[] arr){
        //定义一个计数器用来统计
        int count = 0;
        for (int i = 0; i < arr.length; i++) {
            if(arr[i] != null){
                count++;
            }
        }
        //当循环结束之后，我就知道了数组中一共有几个元素
        return count;
    }


    //1.我要干嘛？  唯一性判断
    //2.我干这件事情，需要什么才能完成？ 数组、id
    //3.调用处是否需要继续使用方法的结果？ 必须返回
    public static boolean contains(Student[] arr, int id) {
        for (int i = 0; i < arr.length; i++) {
            //依次获取到数组里面的每一个学生对象
            Student stu = arr[i];
            //获取数组中学生对象的id
            int sid = stu.getId();
            //比较
            if(sid == id){
                return true;
            }
        }

        //当循环结束之后，还没有找到一样的，那么就表示数组中要查找的id是不存在的。
        return false;
    }
}
```

----

## 2）学会看Bug

执行上面代码，就会报下图错误。遇到Bug不要怕，要学会去阅读，从上往下看。

![image-20240406151756154](./assets/image-20240406151756154.png)

点击蓝色的可以跳到对应的行数。

<img src="./assets/image-20240406151944613.png" alt="image-20240406151944613" style="zoom:67%;" />

此时就知道了，如果数组没装满，数组中就会有值为 `null`，在代码中 `null` 是不能直接使用的，用 `null` 去调用其他的方法就是会报错。所以在这个方法中我们需要对它去做一个非空判断。

~~~java
public static boolean contains(Student[] arr, int id) {
    for (int i = 0; i < arr.length; i++) {
        //依次获取到数组里面的每一个学生对象
        Student stu = arr[i];
        if(stu != null){
            //获取数组中学生对象的id
            int sid = stu.getId();
            //比较
            if(sid == id){
                return true;
            }
        }
    }

    //当循环结束之后，还没有找到一样的，那么就表示数组中要查找的id是不存在的。
    return false;
}
~~~

----

## 3）主题逻辑

```java
package com.itheima.test8;

public class Test2 {
    public static void main(String[] args) {
        /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。
        学生的属性：学号，姓名，年龄。
        要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。
        要求2：添加完毕之后，遍历所有学生信息。

        要求3：通过id删除学生信息
        如果存在，则删除，如果不存在，则提示删除失败。
        要求4：删除完毕之后，遍历所有学生信息。
        要求5：查询数组id为“heima002”的学生，如果存在，则将他的年龄+1岁*/



        //1.创建一个长度为3的数组


        //2.创建学生对象


        //3.把学生对象添加到数组当中



        //4.再次创建一个学生对象


        //5.唯一性判断
        //5.1 已存在 --- 提示重复
        //5.2 不存在 --- 添加学生对象



        //6.添加学生对象
        //6.1 老数组已经存满
        //6.2 老数组没有存满

    }
}
```



----

# 95.需求3、4、5

# Test3.java

要求3：通过id删除学生信息。如果存在，则删除，如果不存在，则提示删除失败。

要求4：删除完毕之后，遍历所有学生信息。

```java
package com.itheima.test8;

public class Test3 {
    public static void main(String[] args) {
        /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。
        学生的属性：学号，姓名，年龄。

        要求3：通过id删除学生信息
            如果存在，则删除，如果不存在，则提示删除失败。
        要求4：删除完毕之后，遍历所有学生信息。

        要求5：查询数组id为“2”的学生，如果存在，则将他的年龄+1岁*/


        //1.创建一个数组用来存储学生对象
        Student[] arr = new Student[3];
        //2.创建学生对象并添加到数组当中
        Student stu1 = new Student(1, "zhangsan", 23);
        Student stu2 = new Student(2, "lisi", 24);
        Student stu3 = new Student(3, "wangwu", 25);

        //3.把学生对象添加到数组当中
        arr[0] = stu1;
        arr[1] = stu2;
        arr[2] = stu3;

        /*要求3：通过id删除学生信息
        如果存在，则删除，如果不存在，则提示删除失败。*/

        //要找到id在数组中对应的索引
        int index = getIndex(arr, 2);
        if (index >= 0){
            //如果存在，则删除
            arr[index] = null;
            //遍历数组
            printArr(arr);
        }else{
            //如果不存在，则提示删除失败
            System.out.println("当前id不存在，删除失败");
        }
    }


    //1.我要干嘛？  找到id在数组中的索引
    //2.我需要什么？ 数组 id
    //3.调用处是否需要继续使用方法的结果？ 要
    public static int getIndex(Student[] arr , int id){
        for (int i = 0; i < arr.length; i++) {
            //依次得到每一个学生对象
            Student stu = arr[i];
            //对stu进行一个非空判断
            if(stu != null){
                int sid = stu.getId();
                if(sid == id){
                    return i;
                }
            }
        }

        //当循环结束之后，还没有找到就表示不存在
        return -1;
    }

    public static void printArr(Student[] arr){
        for (int i = 0; i < arr.length; i++) {
            Student stu = arr[i];
            if(stu != null){
                System.out.println(stu.getId() + ", " + stu.getName() + ", " + stu.getAge());
            }
        }
    }
}
```

----

## Test4.java

要求5：查询数组id为“2”的学生，如果存在，则将他的年龄+1岁

~~~java
package com.itheima.test8;

public class Test4 {
    public static void main(String[] args) {
        /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。
        学生的属性：学号，姓名，年龄。

        要求5：查询数组id为“2”的学生，如果存在，则将他的年龄+1岁*/


        //1.创建一个数组用来存储学生对象
        Student[] arr = new Student[3];
        //2.创建学生对象并添加到数组当中
        Student stu1 = new Student(1, "zhangsan", 23);
        Student stu2 = new Student(2, "lisi", 24);
        Student stu3 = new Student(3, "wangwu", 25);

        //3.把学生对象添加到数组当中
        arr[0] = stu1;
        arr[1] = stu2;
        arr[2] = stu3;


        //4.先要找到id为2的学生对于的索引
        int index = getIndex(arr, 2);

        //5.判断索引
        if(index >= 0){
            //存在， 则将他的年龄+1岁
            Student stu = arr[index];
            //把原来的年龄拿出来
            int newAge = stu.getAge() + 1;
            //把+1之后的年龄塞回去
            stu.setAge(newAge);
            //遍历数组
            printArr(arr);
        }else{
            //不存在，则直接提示
            System.out.println("当前id不存在，修改失败");
        }


    }

    //1.我要干嘛？  找到id在数组中的索引
    //2.我需要什么？ 数组 id
    //3.调用处是否需要继续使用方法的结果？ 要
    public static int getIndex(Student[] arr , int id){
        for (int i = 0; i < arr.length; i++) {
            //依次得到每一个学生对象
            Student stu = arr[i];
            //对stu进行一个非空判断
            if(stu != null){
                int sid = stu.getId();
                if(sid == id){
                    return i;
                }
            }
        }

        //当循环结束之后，还没有找到就表示不存在
        return -1;
    }

    public static void printArr(Student[] arr){
        for (int i = 0; i < arr.length; i++) {
            Student stu = arr[i];
            if(stu != null){
                System.out.println(stu.getId() + ", " + stu.getName() + ", " + stu.getAge());
            }
        }
    }
}
~~~



----

# -----------------------------

# Day10 API & 字符串

# 96.API

## 一、概念

API (Application Programming Interface) ：应用程序编程接口

简单理解：API就是别人已经写好的东西，我们不需要自己编写，直接使用即可。

java中的API：指的就是 JDK 中提供的各种功能的 Java类。

这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。

我们已经学习过的API：Scanner（键盘录入）、Random（获取随机数）

----

## 二、使用API帮助文档

API帮助文档：帮助开发人员更好的使用API和查询API的一个工具。

Java会将所有的API都收录到 `JDK帮助文档`，当我们忘记了，就可以去帮助文档中查。

打开帮助文档

![01](./assets/01-1712386562237-1.png)

在文档的正中央是Java已经定义好的各种各样的包，每个包都有自己各自的作用，在每个包里都有很多很多类。

例如 `java.io` 包，这个包所有类的作用就是用来读取文件的内容，或者将数据写到文件中去，所以在以后，如果我们想要读取一个文件里的信息，就可以用这个包里的类去完成。

再往下还有一个非常重要的包：`java.lang`包，这个包提供了利用 Java 编程语言进行程序设计的基础类。意思就是说，这个包是Java当中最基础，最核心的内容。它有一个特点，在使用 `java.lang` 包里面的类的时候，是不需要我们写 `import` 进行导包的。

![image-20240406202821607](./assets/image-20240406202821607.png)

在页面的左上角，就罗列了Java所有的包

![image-20240406203358407](./assets/image-20240406203358407.png)

例如我们点击一下 `java.lang` 包，然后在下面就会出现这个包中所有的内容

<img src="./assets/image-20240406203456058.png" alt="image-20240406203456058" style="zoom: 67%;" />

往下翻，可以发现有个 `String`，它就是用来表示字符串的。然后用鼠标点一下 `String`，在右侧就会出现 `String类` 所有的信息，我们从上往下来阅读就好了。

![image-20240406203622858](./assets/image-20240406203622858.png)

我们学习完API帮助文档以后，如果说以后每一次都要先找包，再找类，太麻烦了。

点击右上角的 `显示`

![image-20240406204256396](./assets/image-20240406204256396.png)

找到索引选项卡中的输入框，在里面就可以输入我们想要查找的类了。

![image-20240406204546179](./assets/image-20240406204546179.png)

看类在哪个包下，Random这个类是定义在 `java.util` 包下的，所以说在使用 Random 这个类的时候需要写 `import` 导包。

导包其实就是先找到 `Random` 这个类在哪。

![image-20240406204606033](./assets/image-20240406204606033.png)

看类的描述，一般情况下我们只需要阅读第一行就可以了。实例就是对象的意思。这句话的意思就是：这个类的对象可以用来获取一个随机数。

![image-20240406204902256](./assets/image-20240406204902256.png)

查看版本，下图的意思是 `Random类` 在JDK1.0 的时候就出现了，所有的版本都可以使用这个类。

如果说在以后，看到了一个其他的类，它这里的版本写的是8，那就表示这个类在JDK8的时候才出现，低于8的版本是不能用的，大于等于8的才能使用。

![image-20240406205032122](./assets/image-20240406205032122.png)

看构造方法。

既然我们要用这个类里的方法去帮我们做事情，此时就需要获取这个类的对象，构造方法就决定了我们如何去创建对象。

在这里有一个空参的，所以在之前，我们其实是利用空参来创建的对象。

![image-20240406205322912](./assets/image-20240406205322912.png)

对象有了，我们就可以看成员方法，通过方法来做事情了。以这里的 `nextInt()` 为例，第一个 `nextInt()` 是空参，方法名叫 `nextInt`，形参没有，返回值是 `int`。它会生成随机数，这个随机数是分布在int范围内的，这个随机数用不了，因为数值太大了。

所以一般来讲我们都会指定范围，我们用的一般是下面的方法，在括号中传入参数，表示范围，方法会返回一个int类型的整数。它会返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值

![image-20240406205955014](./assets/image-20240406205955014.png)

----

## 三、API文档练习

需求：按照帮助文档的使用步骤学习 Scanner 类的使用，并实现接收键盘录入一个小数，最后输出在控制台。

步骤：

1. 打开API文档

2. 找到左上角的显示 ——> 索引 ——> 输入框中输入要查询的类名 `Scanner` ——> 点击 `显示`

3. 查看包名 `java.util`，所以在使用的时候我们要写 `import java.util.Scanner` 这样的一个导包

4. 类的描述一般都会非常的长，我们不用一个个去看，只要知道Scanner这个类是用来获取键盘输入的数据即可

5. 查看版本号，表示这个类从 `JDK5` 的时候才出现，低于 5 的版本是不能用的

   ![image-20240406211249949](./assets/image-20240406211249949.png)

6. 我们要调用里面的方法，就需要创建对象，创建对象肯定要看它的构造方法

   可以看见，它里面并没有一个空参构造，所以如果我们在创建Scanner对象的时候，如果小括号里空着不写，代码是会报错的

   在之前，我们使用的其实是第三个构造，它的类型是 `InputStream`，这个我们后面会学，现在我们只要知道传递一个 `System.in` 就可以了，`System.in` 就表示它会扫描你的键盘。

   ![image-20240406211519158](./assets/image-20240406211519158.png)

7. 对象有了之后，下面就要来键盘输入了。由于题目中要求的是接收一个小数，因此方法的返回值应该是一个小数类型的才对。

   此时就会找到 `nextDouble()`，方法里面是个空参，所以在调用的时候什么都不用传，方法返回一个 `double`。它会把我们输入的信息扫描为一个 `double` 输入的数据。

   ![image-20240406211838149](./assets/image-20240406211838149.png)

8. 方法找到了，我们就可以打开IDEA来书写代码了。

   在IDEA中也是有代码提示的

   ![image-20240406212247054](./assets/image-20240406212247054.png)

~~~java
package com.itheima.apidemo;

import java.util.Scanner;

public class ScannerDemo1 {
    public static void main(String[] args) {
        //1.创建对象
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个小数");
        //2.接收一个小数
        double result = sc.nextDouble();
        //3.输出打印
        System.out.println(result);
    }
}
~~~



----

# 97.字符串概述

## 一、引入

在之前我们已经接触很久的字符串了，只要用双引号引起来的就是字符串，并且用字符串跟任意的数据类型进行相加，它们做的都是拼接操作，并产生了一个新的字符串，如下图所示。

<img src="./assets/image-20240406212555781.png" alt="image-20240406212555781" style="zoom: 67%;" />

在实际开发中，除了拼接，其实还有很多很多其他的操作，常见的处理有：比较、替换、截取、拼接、查找、切割、检索、加密、打乱内容、大小写转换等等.........

---

## 二、字符串在开发中的应用场景

### 1）用户登录

在上网的时候经常遇到的事情就是登录操作了，可以打开一个浏览器，然后将里面的页面放大来看一下。

在登录页面当中，用户输入的用户名和密码其实就是字符串。在我们登记登录按钮以后，程序员拿到用户输入的信息之后，就去跟正确的用户名和密码进行比较，此时就需要掌握字符串的比较功能。

<img src="./assets/image-20240406213038904.png" alt="image-20240406213038904" style="zoom:67%;" />

---

### 2）玩游戏

我们在玩游戏的时候，经常会遇见喷子，如果喷子说的话它是含脏字的，它不会直接展示出来，在显示的时候它会变成 `**`。

此时就需要我们掌握对字符串的敏感词进行替换。

<img src="./assets/image-20240406213256882.png" alt="image-20240406213256882" style="zoom:67%;" />

---

### 3）银行转账

下面是手机银行的转账界面，我们将中间的局部放大看一下，当我们在输入转账金额的时候，程序就会把数据转成人民币的大写，再显示出来。

此时就需要我们掌握字符串的转换功能。

![image-20240406213614854](./assets/image-20240406213614854.png)

---

## 4）公司面试

公司面试的时候，经常会出现一些字符串相关的练习题。

![image-20240406213706608](./assets/image-20240406213706608.png)

---

## 四、字符串学习内容

1、由于对字符串处理和操作非常多，所以Java提供了很多字符串相关的API，例如：String、StringBuilder、StringJonier、StringBuffer、Pattern、Matcher。掌握了这些，通常就能应对开发中常见的需求了。

2、利用字符串去处理开发中的常见问题。

3、了解字符串底层原理。掌握原理能更好的应对面试，处理开发中的一些复杂问题。

----

## 五、String概述

`java.lang.String类` 就代表字符串，Java程序中的所有字符串文字（例如 `"abc"` ）都为此类的对象。而 `java.lang` 包是Java的核心包，所以我们在使用的时候是不需要导包的。

例如下面在代码当中定义一个字符串，记录名字。还可以定义一个变量叫做 `"黑马程序员"`。

~~~java
String name = "尼古拉斯·阿伟";
String schoolName = "黑马程序员";
~~~

PS：**字符串的内容是不能发生改变的，它的对象在创建后就不能被更改了。**例如我将下面两个字符串进行拼接，它会产生一个新的字符串，对原来的 `尼古拉斯·阿伟` 或者 `黑马程序员` 是没有任何影响的，在这个过程中一共产生了三个字符串。

~~~java
String name = "尼古拉斯·阿伟";
String schoolName = "黑马程序员";
System.out.println(name + schoolName); // 字符串拼接产生一个新的字符串
~~~

---

## 六、总结

1、String是Java定义好的一个类。定义在 `java.lang` 包中，所以使用的时候不需要导包。

2、Java程序中的所有字符串文字（例如：`"abcdefg"`）都被视为此类的对象。

3、字符串不可变，它们的值在创建后不能被更改。



----

# 98.String构造方法 和 内存分析

## 一、创建String对象的两种方式

1、直接赋值。

2、通过 `new` 关键字来使用不同的构造方法去创建字符串的对象。

常用的构造方法

| 方法名                          | 说明                                      |
| ------------------------------- | ----------------------------------------- |
| public   String()               | 创建一个空白字符串对象，不含有任何内容    |
| public  String(String original) | 根据传入的字符串，创建一个新的字符串对象  |
| public   String(char[] chs)     | 根据字符数组的内容，来创建字符串对象      |
| public   String(byte[] bys)     | 根据字节数组的内容，来创建字符串对象      |
| String s =   “abc”;             | 直接赋值的方式创建字符串对象，内容就是abc |

在以前我们想都不用想，肯定用的是 `String s = "abc";` 这种创建方式，在实际开发当中，绝大多数用的也是第一种，其他的创建方式也是需要我们知道的。

**代码示例**

~~~java
package com.itheima.stringdemo;

public class StringDemo1 {
    public static void main(String[] args) {
        //1.使用直接赋值的方式获取一个字符串对象
        String s1 = "abc";
        System.out.println(s1);//abc

        //2.使用new的方式来获取一个字符串对象
        //空参构造：可以获取一个空白的字符串对象
        String s2 = new String();
        System.out.println("@" + s2 + "!");// 为了看的更方便一些，来做一个字符串的拼接。打印出来的是："@!"

        //有参构造，这种方式我们可以传多种类型的参数，它可以根据传递的字符串内容再创建一个新的字符串对象
        //这里就是传递一个字符串，根据传递的字符串内容再创建一个新的字符串对象
        String s3 = new String("abc"); // 此时IDEA中 "new String" 显示的是灰色，它是为了提示你这个东西可以不写，省略。因此这种方式只要知道有它的存在就可以了。
        System.out.println(s3);

        //传递一个字符数组
        //需求：我要修改字符串的内容。  将abc修改为Qbc
        //由于字符串是不可以发生改变的，所以我们将字符串先变成一个字符数组，然后再去修改数组里的内容，修改完了后，再利用String的这个构造，再把修改后的数组进行拼接，变成我们最终要想的字符串就可以了
        //abc  -->  {'a','b','c'}  -->  {'Q','b','c'} --> "Qbc"
        char[] chs = {'a', 'b', 'c', 'd'};
        String s4 = new String(chs); // 根据字符数组的内容再创建一个新的字符串对象
        System.out.println(s4);//abcd

        //传递一个字节数组，根据字节数组的内容再创建一个新的字符串对象
        //字节就是byte，所以字节数组就是一个byte类型的数组
        //应用场景：以后在网络当中传输的数据其实都是字节信息，而这个我们看不懂
        //我们一般要把字节信息进行转换，转成字符串，此时就要用到这个构造了。
         // 它并不是直接将 97, 98, 99, 100 直接进行拼接，而是拿着这个数字先到ASCII码表中去查，查到对应的字符，再把它进行转换，变成字符串
        String s5 = new String(bytes);
        System.out.println(s5);//abcd
    }
}
~~~

----

## 二、创建String对象不同方式的区别

### 1）简单回顾一下内存

到目前我们会涉及到的内存会有三个：栈、堆、方法区

栈跟方法有关，当方法运行的时候进栈，方法中所有的代码执行完了要出站。

堆跟对象有关，只要是 `new` 出来的，都是在堆内存中。

方法区就是当代码要运行了，字节码文件（`.class` 文件），它会加载到方法区中，临时存储。

接下来要接触一块新的区域：`StringTable（串池）`，可以把它理解成字符串常量池，顾名思义，就是用来存字符串的。但是只有直接赋值的方法获取的字符串才存在这个串池中。

在JDK以前，这个池子是在方法区里面的。

<img src="./assets/image-20240407095748075.png" alt="image-20240407095748075" style="zoom:67%;" />

但是从JDK7开始，StringTable（串池）就从方法区挪到了堆内存。但是不管它在哪，它的运行机制是不会发生变化的。

![image-20240407100227532](./assets/image-20240407100227532.png)

----

### 2）直接赋值

假设现在有这么一串代码

~~~java
public class StringDemo {
    public static void main(String[] args) {
        String s1 = "abc";
        String s2 = "abc";
    }
}
~~~

首先程序启动，main方法进栈，然后开始从第一行来执行main方法中的每一行代码。

第一行代码是直接赋值的，所以在main方法中，它首先会创建一个变量 `s1`。等号的右边系统就会去观察串池有没有 `"abc"`，由于第一次是没有的，它就会创建一次新的 `"abc"`。

![image-20240407100530850](./assets/image-20240407100530850.png)

串池中创建的字符串也是有地址值的，然后就会将刚刚创建的 `"abc"` 的地址值赋值给 `s1`。

![image-20240407100711035](./assets/image-20240407100711035.png)

再来继续往下，当代码执行到第二行代码 `String s2 = "abc";` 的时候，在等号左边，还是在 `栈中的main方法` 中创建了一个变量。然后等号的右边也是直接赋值的，注意！——> 只要是直接赋值的，它就会去观察串池里面有没有 `"abc"` ，现在是有 `"abc"` 的，此时它就不会去创建一个新的 `"abc"` 了，而是会复用已经存在的  `"abc"` 。

![image-20240407101509868](./assets/image-20240407101509868.png)

总结：当使用双引号直接赋值时，系统会检查该字符串在串池中是否存在。不存在就创建新的，存在就复用。因此我们以后想要创建一个字符串，更多的还是使用这种直接赋值的，首先代码最简单，而且它还会节约内存。

----

### 3）手动 `new` 出来的内存图

我们以字符串数组为例

~~~java
public class StringDemo {
    public static void main(String[] args) {
        char[] chs = {'a', 'b', 'c'};
        String s1 = new String(chs);
        String s2 = new String(chs);
    }
}
~~~

首先也是main方法先进栈，先执行方法里面的第一行代码，此时在内存中就有了一个 `char` 类型的数组。数组有它的地址值，假设是 `0x0011`，再把地址值 `0x0011` 赋值给变量 `chs`。在数组里存的就是 `"abc"` 这样的三个字符。

![image-20240407101846002](./assets/image-20240407101846002.png)

再来执行第二行代码 `String s1 = new String(chs);`，要注意的是，等号的右边不是直接赋值的，而是 `new` 出来的。在以前我们曾经说过，只要是 `new` 出来的，那就是在堆里开辟一个新的小空间，现在也是一样的。

首先等号的左边是一个变量 `s1`，所以是在栈里面。等号的右边有 `new` 关键字，所以是在堆里面创建了一个小空间，这个空间里的内容就是字符数组的内容 `"abc"`，然后再把它的地址值 `"0x0022"` 再去赋值给 `s1`，`s1` 再通过 `0x0022` 就能找到我们创建出来的这个字符串了。

![image-20240407102207991](./assets/image-20240407102207991.png)

再来看第三行代码 `String s2 = new String(chs);`，这个代码就是将上面的过程再重复了一下。

等号的左边还是创建了一个变量 `s2`，等号的右边有 `new`，所以就是在堆里创建了一个新的小空间，假设这个空间的地址值是 `0x0033`，此时就会把 `0x0033` 赋值给 `s3`，`s3` 通过它就能找到第二个字符串对象。

![image-20240407102426891](./assets/image-20240407102426891.png)

由于每一次创建字符串都会 `new` 一个新的对象， `s1` 跟 `s2` 中存的地址值并不一样，所以这种方式并不会复用。如果相同的字符串比较多，它就会浪费内存空间。

----

### 4）总结

通过刚刚内存的学习我们知道了，以后在使用字符串的时候，尽量还是使用第一种直接赋值的方式。这种方式代码简单，而且还节约内存。



----

# 99.字符串的比较

## 一、引入

以前将字符串比较的时候我们都是使用 `==` 来比较的，如果是一样的，结果就是 `true`，如果不一样，结果就是 `False`。

![image-20240407103027211](./assets/image-20240407103027211.png)

那如果我们要比较的字符串，一个是 `new` 出来的，还有一个是直接赋值的，这个时候 `s1` 跟 `s2` 比较的结果是真还是假呢？

在这里我们就要来剖析一下 `==` 号比较的原理。

----

## 二、`==` 号比的到底是什么？

### 1）介绍

这个问题需要分情况讨论的。

如果比较的是左边的基本数据类型，它比较的就是具体的值。

如果是左边的引用数据类型，这个时候 `==` 号比较的是地址值。由于每一次 `new` 出来的都是新的小空间，因此 `s1` 和 `s2` 的地址值肯定不相同，所以这里的结果就是 `false`。

![image-20240407103358529](./assets/image-20240407103358529.png)

---

### 2）示例代码1

来看下面的代码，由于下面是直接赋值的，直接赋值的字符串是在串池中的。

所以在这里它会去检查串池中有没有 `'abc'`，第一次创建 `s1` 的时候肯定没有，所以它会在串池中创建一个新的 `"abc"`。

第二次创建 `s2` 的时候，也是直接赋值的，它同样也会去串池检查，但是这次已经有了 `"abc"`，这个时候它不会创建新的，而是会复用。所以在这个情况下，`s1` 跟 `s2` 记录的地址值是一样的，所以这里的结果就是 `true`。

~~~java
String s1 = "abc";
String s2 = "abc";
System.out.println(s1 == s2); // true
~~~

----

### 3）示例代码2

首先 `s1` 是 `new` 出来的，它就会在堆里开辟一个小空间。

而 `s2` 不是 `new` 的，它是直接赋值的，所以 `s2` 中的 `"abc"` 是在串池里面的。

因此上面的 `s1` 记录的是堆里面的地址，而下面的 `s2` 记录的是串池里面的地址。这两个记录的地址值所在的位置都不一样，结果肯定是 `false`

~~~java
String s1 = new String("abc");
String s2 = "abc";
System.out.println(s1 == s2); // false
~~~

---

## 三、字符串的比较

在字符串中，Java提供了两个比较方法。在调用方法的时候我们需要传入要比较的字符串，它会有一个布尔类型的结果，如果返回 `true`，就表示两个字符串是一致的；如果返回 `false`，就表示两个字符串是不一致的。

- `boolean equals方法(要比较的字符串)`             —— 完全一样结果才是 `true`，否则为 `false`

  例如当我们比较 `用户名和密码` 的时候，用户名和密码需要完全一模一样，这个时候我们就会使用 `equals` 进行比较

- `boolean equalsIgnoreCase(要比较的字符串)`  ——  忽略大小写的比较

  例如我们需要比较 `验证码` 的时候就可以忽略大小写，此时就可以使用 `equalsIgnoreCase` 。

**代码示例1**

~~~java
package com.itheima.stringdemo;

public class StringDemo2 {
    public static void main(String[] args) {
        //1.创建两个字符串对象
        String s1 = new String("abc");
        String s2 = "Abc";

        //2.==号比较
        //基本数据类型：比的是数据值
        //引用数据类型：比的是地址值
        System.out.println(s1 == s2);//false


        //3.比较字符串对象中的内容是否相等
        boolean result1 = s1.equals(s2);
        System.out.println(result1);

        //4.比较字符串对象中的内容是否相等，忽略大小写
        //忽略大小写只能是英文状态下的a A，涉及到英文就不行了，例如：1 一 壹 这不行
        boolean result2 = s1.equalsIgnoreCase(s2);
        System.out.println(result2);//true
    }
}
~~~

**代码示例2**

~~~java
package com.itheima.stringdemo;

import java.util.Scanner;

public class StringDemo3 {
    public static void main(String[] args) {
        //1.假设我现在键盘录入一个abc
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个字符串");
        String str1 = sc.next();//abc，键盘录入得到的这个字符串是 `new` 出来的！
        //2.代码中再定义一个字符串abc
        String str2 = "abc";
        //3.用==比较，这两者能一样吗？
        System.out.println(str1 == str2);//4.答案为false，一个是在堆中，一个是在串池中，肯定地址不一样！
    }
}
~~~



---

# 100.练习——登录

## 一、查看 `Scanner类中next()方法` 的原码

看源码前要知道，Java的原码写的非常非常的复杂，我们千万不要自己一个人去看，自己一个人去看会看抑郁的。

现在带着大家一点一点去找，找到 `next` 里的核心代码，后面随着我们学的东西渐渐深入，我们再一点一点加大难度。

选中 `next` 方法

![image-20240407191943779](./assets/image-20240407191943779.png)

<kbd>ctrl + b</kbd> 跟进源码，方法返回一个 `token`，这个 `token` 其实就是我们键盘录入的数据。

<img src="./assets/image-20240407192224233.png" alt="image-20240407192224233" style="zoom:80%;" />

这个数据是通过 `getCompleteTokenInBuffer()` 方法得到的，所以我们最终还是要看这个方法。选中它，<kbd>ctrl + b</kbd>。这个方法里的代码就非常非常多了，但是不用慌。

继续往下看，返回的是 `s`，而 `s` 又是通过这里的 `group()` 方法得到的。

![image-20240407192459832](./assets/image-20240407192459832.png)

<kbd>ctrl + b</kbd>进入 `group()`，所以要找这里的 `group`。

![image-20240407192633701](./assets/image-20240407192633701.png)

它又调用了 `group(0)`，继续<kbd>ctrl + b</kbd>。最终，它return的是下面选中的这一堆。

![image-20240407192737423](./assets/image-20240407192737423.png)

接下来我们选中 `getSubSequence()` 再来 <kbd>ctrl + b</kbd> ，

![image-20240407192815579](./assets/image-20240407192815579.png)

选中 `subSequence` 再来<kbd>ctrl + b</kbd>，进入 `subSequence` 方法后，发现这个方法没有方法体

![image-20240407192926592](./assets/image-20240407192926592.png)

此时我们需要回到上一步，选中 `ubSequence` ——> Go To ——> Implementation(s)，快捷键是<kbd>Ctrl + Alt + B</kbd>

![image-20240407193105588](./assets/image-20240407193105588.png)

然后选中一个有方法体的，例如我们可以选择 `String`。

![image-20240407193339658](./assets/image-20240407193339658.png)

然后再选择这里的 `substring`

![image-20240407193438803](./assets/image-20240407193438803.png)

此时我们需要找到这里的 `newString`，<kbd>ctrl + b</kbd>

![image-20240407193521592](./assets/image-20240407193521592.png)

此时我们就可以发现，通过刚刚一大堆洋洋洒洒的跟进，终于找到了它的核心代码。此时我们就会发现，它是 `new` 出来的！

因此关于刚刚找的过程其实并不重要，我们只需要知道一个核心点：键盘录入得到的这个字符串是 `new` 出来的！

**结论：以后只要想比较字符串的内容，就必须要用String里面的方法！**

----

## 二、用户登录

需求：已知正确的用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示。

快捷键：<kbd>ctrl + alt + T</kbd> 使用语句包裹，但是这个如果选择的是 `for`，出现的for语句就需要我们自己手动去补里面的语句。

![image-20240407194913495](./assets/image-20240407194913495.png)

因此在这里就可以直接输入 `3.fori` 然后回车，直接将需要放入的语句 <kbd>ctrl + X </kbd>、<kbd>ctrl + V</kbd> 粘贴过来。

~~~java
package com.itheima.stringdemo;

import java.util.Scanner;

public class StringDemo4 {
    public static void main(String[] args) {
        //读题拆解法

        //1.定义两个变量记录正确的用户名和密码
        String rightUsername = "zhangsan";
        String rightPassword = "123456";


        Scanner sc = new Scanner(System.in);
        //2.键盘录入用户名和密码
        for (int i = 0; i < 3; i++) {// 0 1 2，由于在这里，已经明确的知道了循环的此时，因此我们在这里需要使用 for循环
            System.out.println("请输入用户名");
            String username = sc.next();
            System.out.println("请输入密码");
            String password = sc.next();

            //3.比较
            if (username.equals(rightUsername) && password.equals(rightPassword)) {
                System.out.println("用户登录成功");
                break;
            } else {
                if(i == 2){
                    //最后一次机会也输入错误，此时要提示账号被锁定
                    System.out.println("账号" + username + "被锁定，请联系黑马程序员官方客服小姐姐:XXX-XXXXX");
                }else{
                    System.out.println("用户登录失败，用户名或密码有误,您还剩下" + (2 - i) + "次机会");//2 1 0
                }
            }
        }
    }
}
~~~



----

# 101.遍历字符串和统计字符个数

## 一、引入

在之前我们遍历过数组，所谓遍历就是将数组中每一个元素都给获取出来。

现在遍历字符串也是一样的，就是我们需要将字符串里的每一个字符都给拿出来。

----

## 二、涉及到的方法

- `public char charAt(int index)` ：根据索引返回对应的字符

字符串也是有索引的，例如`"钢门123吹小雪"` 为例，对应的索引分别为 `0 1 2 3 4 5 6 7`，可以发现，这个跟我们之前数组索引的规则一模一样！

- `public int length()`：返回此字符串的长度

区分 —— 数组的长度：`数组名.length`，数组的长度是一个属性，所以我们在调用的时候 `length` 后面是不加小括号的。而字符串的长度是一个方法，方法在调用的时候 `length` 是需要加小括号的。

**代码示例**

~~~java
package com.itheima.stringdemo;
import java.util.Scanner;

public class StringDemo5 {
    public static void main(String[] args) {
        //1.键盘录入一个字符串
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个字符串");
        String str = sc.next();
        //2.进行遍历
        for (int i = 0; i < str.length(); i++) {
            //i 依次表示字符串的每一个索引
            char c = str.charAt(i);
            System.out.println(c);
        }
    }
}
~~~

---

## 三、练习：统计字符串个数

需求：键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符，数字字符出现的次数（不考虑其他字符）

~~~java
package com.itheima.stringdemo;

import java.util.Scanner;

public class StringDemo6 {
    public static void main(String[] args) {
        //1.键盘录入一个字符串
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个字符串");
        String str = sc.next();
        //2.统计--- 计数器思想
        //定义三个计数器
        int bigCount = 0;
        int smallCount = 0;
        int numberCount = 0;
        // 如果还需要统计其他字符，只需要再加一个 otherCount 即可
        for (int i = 0; i < str.length(); i++) {
            //i 依次表示字符串中的每一个索引
            char c = str.charAt(i);
            if(c >= 'a' && c <= 'z'){
                //char类型的变量在参与计算的时候自动类型提升为int，在提升的时候就会自动查询ascii码表，变成对应的数字，然后再去进行比较
                smallCount++;
            }else if(c >= 'A' && c <= 'Z'){
                bigCount++;
            // 注：如果写成 "c >= 0 && c <= 9" 就会出问题，因为在ASCII码表中，字符 '0' 所对应的数字其实是 48 ，字符 '9' 所对应的数字其实是57。
            }else if(c >= '0' && c <= '9'){
                numberCount++;
            }
        }

        //3.输出打印
        System.out.println("小写字母有：" + smallCount + "个");
        System.out.println("大写字母有：" + bigCount + "个");
        System.out.println("数字字母有：" + numberCount + "个");
    }
}
~~~



----

# 102.练习：字符串拼接和反转

## 一、拼接字符串

定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，

并在控制台输出结果。例如，数组为 int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]

PS：不要忘记特判！

~~~java
package com.itheima.stringdemo;

public class StringDemo7 {
    public static void main(String[] args) {
        int[] arr = {1,2,3};

        String str = arrToString(arr);
        System.out.println(str);//[123
    }


    //1.我要干嘛？ --- 遍历数组并把数组拼接成一个字符串
    //2.我干这件事情需要什么才能完成？ --- 数组
    //3.我干完了是否要把结果返回给调用处 --- 返回一个拼接之后的字符串
    //如果调用处需要继续使用，那么必须返回
    //如果调用处不需要继续使用，那么可以返回也可以不返回
    public static String arrToString(int[] arr){
        if(arr == null){
            return "";
        }

        if(arr.length == 0){
            return "[]";
        }

        String result = "[";
        //当代码执行到这里表示什么？
        //表示数组不是null，也不是长度为0的
        for (int i = 0; i < arr.length; i++) {
            //i表示的是索引，arr[i]表示的是元素
            result = result + arr[i];
            if (i != arr.length - 1) {
                result += ", ";
            }
        }
        //此时拼接右括号
        result = result + "]";
        return result;
    }
}
~~~

----

## 二、练习：字符串反转

定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果。例如，键盘录入 abc，输出结果 cba

> IDEA快捷键：fori :正着遍历 ，forr：倒着遍历。但是倒叙遍历我们需要修改变量的名字，可以在出现for循环的时候直接修改，也可以按快捷键<kbd>shift + F6</kbd>批量修改，并且需要将 `length > 0` 改为 `length >= 0`'。
>
> ![image-20240407204804568](./assets/image-20240407204804568.png)

```java
public class Test6反转字符串 {
    public static void main(String[] args) {
        /*定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果
        例如，键盘录入 abc，输出结果 cba*/


        //1.定义一个字符串
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个字符串");
        String str = sc.next();
        //2.定义一个方法，反转字符串
        //abc  --->  cba
        //可以把字符串倒着遍历，再拼接
        String result = reverse(str);
        System.out.println(result);
    }

    //注释：方法的作用就是反转字符串
    //把传递进来的字符串进行反转
    public static String reverse(String str){//abc
        //核心思想：倒着遍历并进行拼接就可以了
        //IDEA快捷键：fori :正着遍历  forr：倒着遍历
        String s = "";
        for (int i = str.length() - 1; i >= 0; i--) {
            //i 依次表示字符串里面的每一个索引（倒着的）
            //我们就可以拿到里面的每一个字符并拼接
            s = s + str.charAt(i);
        }

        //把倒着拼接之后的结果返回即可
        return s;
    }
}
```



----

# 103.练习：金额转换

## 一、介绍

金额转换在不同的业务场景当中会有不同的逻辑，现在我们的业务场景是针对于发票上的金额转换，我们需要将左下角输入的整数转为大写的汉字。注意，这里的总长度它是7位的。

![image-20240407205254947](./assets/image-20240407205254947.png)

案例需求：把 `2135` 变成：`零佰零拾零万贰仟壹佰叁拾伍元`。把 `789` 变成：`零佰零拾零万零仟柒佰捌拾玖元`。

这个就需要用到我们之前说的：反向逆推法。反向逆推法需要从后往前推，我们可以将 `零佰零拾零万贰仟壹佰叁拾伍元` 先去掉单位变成 `零零零贰壹叁伍`，这样来看就稍微简单一些。然后我们可以再将前面的 `零` 去掉，变成 `贰壹叁伍`，然后再将大写的 `贰壹叁伍` 变成整数 `2135` 就是题目一开始的最初数据了。

<img src="./assets/image-20240407205622234.png" alt="image-20240407205622234" style="zoom:67%;" />

那么我们在写代码的时候将刚刚的思路反过来写，一步一步从上往下就好了。

<img src="./assets/image-20240407205655533.png" alt="image-20240407205655533" style="zoom:67%;" />

---

## 二、思路

### 1、将 `2135` 变成大写的 `贰壹叁伍`

一开始我们可以遍历 `2135` 获取到里面的每一个数字，得到数字之后我们再进行转换就可以了。

在转换的时候我们可以把大写的内容存到一个数组当中，让 `大写的中文` 跟 `索引` 去一一对应。然后我们就可以把金额里面的每一个数字当做索引去数组里面找大写的中文就可以了。例如我拿到数字 `2`，把 `2` 当做索引到数组中去找大写的 `贰` 就行。

这种思路就是我们变成思想中的 `查表法`，所谓 `表` 其实就是下面的这个数组，组数中把数据跟索引产生一个一一对应的关系。

![image-20240407212546779](./assets/image-20240407212546779.png)

这种思路在很多地方都能用到，例如 `星期跟数字`，`1` 对应 `星期一`，`2` 对应 `星期二`，`3` 对应 `星期三` 等等。

### 2、补零，补齐7位即可

### 3、在中间插入单位

----

## 三、代码

```java
package com.itheima.stringdemo;

import java.util.Scanner;

public class StringDemo9 {
    public static void main(String[] args) {
        //1.键盘录入一个金额
        Scanner sc = new Scanner(System.in);
        int money; // money需要定义在循环的外面，这个地方叫做定义
        while (true) {
            System.out.println("请录入一个金额");
            money = sc.nextInt(); // 这里就是给变量进行赋值
            if (money >= 0 && money <= 9999999) {
                break;
            } else {
                System.out.println("金额无效");
            }
        }

        //定义一个变量用来表示钱的大写
        String moneyStr = "";

        //2.得到money里面的每一位数字,再转成中文
        while (true) {//2135
            //从右往左获取数据，因为右侧是数据的个位
            int ge = money % 10;
            String capitalNumber = getCapitalNumber(ge);
            //把转换之后的大写拼接到moneyStr当中
            moneyStr = capitalNumber + moneyStr;
            //第一次循环 ： "伍" + "" = "伍"
            //第二次循环 ： "叁" + "伍" = "叁伍"
            //去掉刚刚获取的数据
            money = money / 10;

            //如果数字上的每一位全部获取到了，那么money记录的就是0，此时循环结束
            if (money == 0) {
                break;
            }
        }

        //3.在前面补0，补齐7位
        int count = 7 - moneyStr.length();
        for (int i = 0; i < count; i++) {
            moneyStr = "零" + moneyStr;
        }
        System.out.println(moneyStr);//零零零贰壹叁伍

        //4.插入单位
        //定义一个数组表示单位
        String[] arr = {"佰","拾","万","仟","佰","拾","元"};
        //               零    零   零   贰   壹   叁   伍

        //做法：遍历moneyStr，依次得到 零    零   零   贰   壹   叁   伍
        //然后把arr的单位插入进去

        String result = "";
        for (int i = 0; i < moneyStr.length(); i++) {
            char c = moneyStr.charAt(i);
            //把大写数字和单位拼接到result当中
            result = result + c + arr[i];
        }

        //5.打印最终结果
        System.out.println(result);
    }

    //定义一个方法把数字变成大写的中文
    //如果传进来的是 1 -- 就将大写的壹
    // Capital：大写字母
    public static String getCapitalNumber(int number) {
        //定义数组，让数字跟大写的中文产生一个对应关系
        String[] arr = {"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"};
        //返回结果
        return arr[number];
    }
}
```



---

# 104.练习：手机号屏蔽、身份证信息查看、敏感词替换

## 一、substring字符串截取

1、字符串截取：`String substring(int beginIndex, int endIndex)`，它可以从一个大的字符串中把字符串的一部分给截取出来。括号里面传递的就是索引，从 `beginIndex`（开始索引） 开始截取，截取到 `endIndex`（结束索引）。

> PS：
>
> 1、包头不包尾，包左不包右。
>
> 2、只有返回值才是截取的小串，它对原来的字符串是没有任何影响的，因为字符串本身是不能发生变化的。

2、`substring` 还有一个重载的方法，就是一个参数的，我们只需要传入一个 `beginIndex` ，默认截取到末尾。

----

## 二、手机号屏蔽

需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽，最终效果为：`131****9468`。

```java
package com.itheima.stringdemo;

public class StringDemo10 {
    public static void main(String[] args) {
        //1.获取一个手机号码
        String phoneNumber = "13112349468";

        //2.截取手机号码前面三位，注意 “phoneNumber.substring(0, 3)” 一定要复制给新的变量，原字符串是不改变的！
        String start = phoneNumber.substring(0, 3);

        //3.截取手机号码后面四位
        String end = phoneNumber.substring(7);

        //4.拼接
        String result = start + "****" + end;

        //5.打印
        System.out.println(result);
    }
}
```

----

## 三、身份证信息查看

身份证的每一位都是有固定的含义：

* 1、2位：省份 
* 3、4位：城市 
* 5、6位：区县 
* 7-14位：出生年、月、日 
* 15、16位：所在地派出所 
* 17位：性别（奇数男性，偶数女性）
* 18位：个人信息码（随机产生） 

要求打印内容方式如下：

​	人物信息为：

​	出生年月日：XXXX年X月X日

​	性别为：男/女

```java
package com.itheima.stringdemo;

public class StringDemo11 {
    public static void main(String[] args) {
        //1.定义一个字符串记录身份证号码
        String id = "321281202001011234";

        //2.获取出生年月日
        String year = id.substring(6, 10);
        String month = id.substring(10, 12);
        String day = id.substring(12, 14);


        System.out.println("人物信息为：");
        System.out.println("出生年月日:" + year + "年" + month + "月" + day + "日");

        //3.获取性别
        char gender = id.charAt(16);//'3'  ---> 3
        //利用ASCII码表进行转换
        //'0' --->  48
        //'1' --->  49
        //'2' --->  50
        //'3' --->  51
        //'4' --->  52
        //'5' --->  53
        //'6' --->  54
        //'7' --->  55
        //'8' --->  56
        //'9' --->  57

        // 如果忘记了'0'在ASCII码表中对应的数字，可以通过 System.out.println('0' + 0); 获得
        // 也可以直接 int num = gender - '0';
        int num = gender - 48;
        if(num % 2 == 0){
            System.out.println("性别为:女");
        }else{
            System.out.println("性别为:男");
        }
    }
}
```

----

## 四、replace替换

`String replace(旧值, 新值)` ——   替换。

旧值：你要把谁进行替换；新值：替换成的内容。

注意点：字符串本身是不能发生变化的，只有返回值才是替换之后的结果。

---

## 五、敏感词替换 

需求1：键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换 

```java
package com.itheima.stringdemo;

public class StringDemo12 {
    public static void main(String[] args) {
        //1.获取到说的话
        String talk = "你玩的真好，以后不要再玩了，TMD";

        //2.把里面的敏感词TMD替换为***
        String result = talk.replace("TMD", "***");

        //3.打印结果
        System.out.println(result); // 你玩的真好，以后不要再玩了，***
    }
}
```

需求2：如果要替换的敏感词比较多怎么办？

```java
public class Test10多个敏感词替换 {
    public static void main(String[] args) {
        //实际开发中，敏感词会有很多很多

        //1.先键盘录入要说的话
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入要说的话");
        String talk = sc.next();//后裔你玩什么啊，TMD,GDX,ctmd,ZZ

        //2.定义一个数组用来存多个敏感词
        String[] arr = {"TMD","GDX","ctmd","ZZ","lj","FW","nt"};

        //3.把说的话中所有的敏感词都替换为***

        for (int i = 0; i < arr.length; i++) {
            //i 索引
            //arr[i] 元素 --- 敏感词
            talk = talk.replace(arr[i],"***");
        }

        //4.打印结果
        System.out.println(talk);//后裔你玩什么啊，***,***,***,***
    }
}
```

----

## 六、查询String类帮助文档

String类 定义在 `java.lang` 包是Java的核心包。所以我们在使用 `String` 这个类的包是不需要导包的。

![](./assets/202404072323018.png)

再看下面对类的描述，Java 程序中的所有字符串字面值（如 `"abc"` ）都作为此类的实例实现，示例就是对象，在Java里面凡是有双引号的都是String这个类的对象。

字符串是常量：它们的值在创建之后不能更改。

![image-20240407232558523](./assets/image-20240407232558523.png)

关于它的版本，是 `JDK1.0` 出现的，因此在所有版本当中，都是可以使用的。

<img src="./assets/image-20240407232829661.png" alt="image-20240407232829661" style="zoom: 67%;" />

再往下，看它的构造

![image-20240407233032601](./assets/image-20240407233032601.png)

再往下，看它的成员方法，它的成员方法有很多很多，这些方法千万不要去背，以后用到了就到API文档来找就行了。

![image-20240407233146647](./assets/image-20240407233146647.png)

---

## 七、操作字符串其他的类

第一个类在这里拼接了1000000个字符串，右键运行。

它虽然说也能拼接，但是程序一直没有结果，需要等很久很久才能等到结果。

因此当数据量比较大的时候，一般是不会用字符串直接去拼接的。

~~~java
public class StringBuilderDemo1 {
    public static void main(String[] args) {
        String s = "";
        for (int i = 0; i < 1000000; i++) {
            s = s + "abc";
        }
        System.out.println(s);
    }
}
~~~

而是使用下列代码的方式，右键运行，‘刷’ 以下结果就出来了。

~~~java
public class StringBuilderDemo2 {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < 1000000; i++) {
            sb.append("abc");
        }
        System.out.println(sb);
    }
}
~~~



----

# 105.StringBuilder的基本操作

## 一、引入

如果我们用以前的方式去拼接 `10000万` 个字符串，代码也能写，但是拼起来之后速度非常非常慢。

但我想要的是速度非常非常快，所以就可以使用我们今天所学的 `StringBuilder` 开始拼接，这种方式 `刷` 一下就拼接完毕了。

![image-20240408150635616](./assets/image-20240408150635616.png)

StringBuilder 可以看成是一个容器，创建之后里面的内容是可变的。

**因此它的作用就是用来提高字符串的操作效率。它只是操作字符串的一个工具，并不是真的字符串。**

例如以下代码，`String s6 = s1 + s2 + s3 + s4 + s5;` 在拼接的过程中产生了很多没用的字符串，每一次通过 `+` 的拼接都会产生一个新的字符串，但这些东西非常影响内存和运行效率，这并不是我们想要的结果，我想要的是一种快捷的方式。

~~~java
String s1 = "aaa";
String s2 = "bbb";
String s3 = "ccc";
String s4 = "ddd";
String s5 = "eee";
String s6 = s1 + s2 + s3 + s4 + s5;
~~~

此时就可以使用 `StringBuilder` ，StringBuilder可以看做是一个容器，里面的内容是可以发生变化的，因此当 `s6` 在变化的时候都是在一个容器里发生变化的，并不会产生那么多没有用的字符串。

![image-20240408151407094](./assets/image-20240408151407094.png)

----

## 二、StringBuilder 的构造方法

`StringBuilder` 一共有两个构造。

| 方法名                             | 说明                                       |
| :--------------------------------- | :----------------------------------------- |
| `public StringBuilder()`           | 创建一个空白可变字符串对象，不包含任何内容 |
| `public StringBuilder(String str)` | 根据字符串的内容，来创建可变字符串对象     |

![image-20240408151734748](./assets/image-20240408151734748.png)

----

## 三、`StringBuilder` 常用方法

| 方法名                                  | 说明                                                    |
| --------------------------------------- | ------------------------------------------------------- |
| `public StringBuilder append(任意类型)` | 添加数据，并返回对象本身                                |
| `public StringBuilder reverse()`        | 反转容器中的内容                                        |
| `public int length()`                   | 返回长度（字符出现的个数）                              |
| `public String toString()`              | 通过 `toString()` 就可以把`StringBuilder`转换为`String` |

**代码示例**

PS：在Java中起名字的时候会有个小习惯，如果变量名不知道起什么，就可以用类型的首字母来做变量名。而 `StringBuilder` 类型是两个单词，第一个单词首字母是 `s`，第二个单词首字母是 `b`，所以合起来就是 `sb`。同样我们也可以通过查阅 `API帮助文档`，看看它上的示例命名是什么。

![image-20240408152453115](./assets/image-20240408152453115.png)

下述代码很奇怪，`sb` 是 `new` 出来的对象，我打印一个对象应该是地址值才对，为什么这里什么都没有。

这是因为 `StringBuilder` 不是我们写的，而是Java已经写好的一个类。Java在底层对它做了一些特殊处理：打印对象不是地址值，而是属性值。

~~~java
StringBuilder sb = new StringBuilder();
System.out.println(sb); // 结果是什么也没有
~~~

既然打印出来的是属性值，那下面代码打印结果就很好解释了。

~~~java
StringBuilder sb = new StringBuilder("abc");
System.out.println(sb); // abc
~~~

调用其方法

~~~java
package com.itheima.stringbuilderdemo;

public class StringBuilderDemo3 {
    public static void main(String[] args) {
        //1.创建对象
        StringBuilder sb = new StringBuilder("abc");

        //2.添加元素
        sb.append(1);
        sb.append(2.3);
        sb.append(true); // 将这些进行字符串拼接，只不过这种拼接是在单个容器内部的拼接，而不是产生新的字符串

        //3.反转
        // PS：它是在容器内部直接做了反转。它跟字符串不一样，字符串本身是不能变化的，只有返回值才是截取、替换之后的结果；而 StringBuilder容器 里的内容是可以发生变化的，一旦调用 reverse() 方法后，容器内的数据就直接被反转过来了。
        sb.reverse();

        //4.获取长度
        int len = sb.length();
        System.out.println(len);


        //打印
        //普及：
        //因为StringBuilder是Java已经写好的类
        //java在底层对他做了一些特殊处理。
        //打印对象不是地址值而是属性值。
        System.out.println(sb);
    }
}
~~~

使用 `toString()`

~~~java
package com.itheima.stringbuilderdemo;

public class StringBuilderDemo4 {
    public static void main(String[] args) {
        //1.创建对象
        StringBuilder sb = new StringBuilder();

        //2.添加字符串
        sb.append("aaa");
        sb.append("bbb");
        sb.append("ccc");
        sb.append("ddd");

        System.out.println(sb);//aaabbbcccddd，但是这个 sb 并不能直接被当做字符串，因为 sb 是StringBuilder类型的，这个 sb 只是一个容器，是来帮助我们操作字符串的工具。因此在我们拼接完后，还需要再把 StringBuilder 变回字符串才可以。

        //3.再把StringBuilder变回字符串
        String str = sb.toString();
        System.out.println(str);//aaabbbcccddd
    }
}
~~~

----

## 四、链式编程

链式编程：表示当我们在调用一个方法的时候，不需要用变量接收它的结果，可以继续调用其他方法。

```java
package com.itheima.stringbuilderdemo;

import java.util.Scanner;

public class StringBuilderDemo5 {
    public static void main(String[] args) {
        // getString() 得到的是一个字符串，我们就可以使用这个字符串去调用字符串中的 substring 方法。
        // substring 截取完后得到的又是一个新的字符串，此时我们还可以继续对这个新的字符串进行操作，例如 replace("A", "Q") ，将大写 A 替换成大写 Q 。
        // 替换完后再去调用 length() 获取它的长度，而 length() 方法获取的是一个整数，此时它就不能再去调用字符串的方法了。
        int len = getString().substring(1).replace("A", "Q").length();
        System.out.println(len);
    }

    public static String getString(){ // 获取键盘里的字符串，然后把字符串做一个返回
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个字符串");
        String str = sc.next();
        return str;
    }
}
```

学习完链式编程之后，我们就可以对刚刚的代码进行一个简化。

这是因为当我们调用 `append()` 方法之后它会返回一个 `StringBuilder` 对象，也就是所它把调用者的容器进行了一个返回，因此每一次的 `append()` 都会将容器进行返回，因此 `append()` 方法的结果还是 `StringBuilder` 对象，即这里的 `sb`。

![image-20240408154424595](./assets/image-20240408154424595.png)

~~~java
sb.append("aaa");
sb.append("bbb");
sb.append("ccc");
sb.append("ddd");

// 可直接写成
sb.append("aaa").append("bbb").append("ccc").append("ddd");
~~~

----

## 五、练习一：对称字符串 

需求：键盘接受一个字符串，程序判断出该字符串是否是对称字符串，并在控制台打印是或不是

例如：

  	对称字符串：123321、111
  	
  	非对称字符串：123123

代码示例：

```java
package com.itheima.stringbuilderdemo;

import java.util.Scanner;

public class StringBuilderDemo6 {
    //使用StringBuilder的场景：
    //1.字符串的拼接
    //2.字符串的反转

    public static void main(String[] args) {
        //1.键盘录入一个字符串
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个字符串");
        String str = sc.next();

        //2.反转键盘录入的字符串
        String result = new StringBuilder().append(str).reverse().toString();

        //3.比较
        if(str.equals(result)){
            System.out.println("当前字符串是对称字符串");
        }else{
            System.out.println("当前字符串不是对称字符串");
        }
    }
}
```

----

## 六、练习2：拼接字符串 

需求：定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回。

调用该方法，并在控制台输出结果。例如：数组为`int[] arr = {1,2,3}`; 。执行方法后的输出结果为：`[1, 2, 3]`。

代码示例:

```java
package com.itheima.stringbuilderdemo;

public class StringBuilderDemo7 {
    public static void main(String[] args) {
        //1.定义数组
        int[] arr = {1,2,3};

        //2.调用方法把数组变成字符串
        String str = arrToString(arr);

        System.out.println(str);

    }

    public static String arrToString(int[] arr){
        StringBuilder sb = new StringBuilder();
        sb.append("[");

        for (int i = 0; i < arr.length; i++) {
            if(i == arr.length - 1){
                sb.append(arr[i]);
            }else{
                sb.append(arr[i]).append(", ");
            }
        }
        sb.append("]");
        return sb.toString();
    }
}
```



----

# 106. StringJoiner

## 一、引入

在之前我们拼接 `1000000` 个字符串的时候，用的是字符串直接拼接的方式。这种拼接的方式速度太慢了，因此我们使用 `StringBuilder` 进行替代，提高了代码的运行速度。

![image-20240408155235714](./assets/image-20240408155235714.png)

但是 `StringBuilder` 书写的代码还是比较麻烦的，例如当我们想要将数组拼接成指定字符串的时候就有点慢了。

在循环的开始去拼接左括号，在循环的结束去拼接右括号。在循环的过程中，对中间的 `, `（逗号和空格）还需要做判断

![image-20240408155449146](./assets/image-20240408155449146.png)

但如果我们想偷个懒，这是程序员的品格，正是因为有这样的品格，程序员才会创造很多很多一劳永逸的方法去解决问题。

那有没有一种拼接速度快，代码又简单的方式呢？这正是我们现在要学习的 `StringJoiner`。

我们现在先来体验一下 `StringJoiner`。在创建对象的时候我们可以指定中间的间隔符号，用逗号分隔，可以指定开始的符号：左括号，还可以指定结束的符号：右括号，一旦指定完后，在添加元素的时候我们就不需要进行判断了。我们在下面代码遍历到的每一个数组里的元素，直接将它扔给 `StringJoiner` 就行了。

代码非常简单，最终打印的就是我们想要的效果，所以 `StringJoiner`，用起来真的是非常方便

![image-20240408160254884](./assets/image-20240408160254884.png)

----

## 二、`StringJoiner` 概述

* StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。

* 作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。 

  因为它是从JDK8才出现的。他们之前一直在用 `StringBuider` 用熟了就懒得改了。

----

## 三、构造方法

它的构造方法是没有空参的，它有两个带参的构造需要我们掌握。

| 方法名                                              | 说明                                                         |
| --------------------------------------------------- | ------------------------------------------------------------ |
| `public StringJoiner(间隔符号)`                     | 创建一个 `StringJoiner` 对象，指定拼接时的间隔符号           |
| `public StringJoiner(间隔符号, 开始符号, 结束符号)` | 创建一个 `StringJoiner` 对象，指定拼接时的间隔符号、开始符号、结束符号 |

 ![image-20240408160724430](./assets/image-20240408160724430.png)

----

## 四、成员方法

PS：`add` 目前为止只能添加字符串。

| 方法名                                  | 说明                                               |
| --------------------------------------- | -------------------------------------------------- |
| `public StringJoiner add(添加的字符串)` | 添加数据，并返回对象本身，因此这里可以使用链式编程 |
| `public int length()`                   | 返回长度（字符出现的个数）                         |
| `public String toString()`              | 返回一个字符串（改字符串就是拼接之后的结果）       |

----

## 五、代码示例

`public StringJoiner(间隔符号)`

~~~java
package com.itheima.stringjoinerdemo;

import java.util.StringJoiner;

public class StringJoinerDemo1 {
    public static void main(String[] args) {
        //1.创建一个对象，并指定中间的间隔符号
        StringJoiner sj = new StringJoiner("---");
        
        //2.添加元素
        sj.add("aaa").add("bbb").add("ccc");

        //3.打印结果
        System.out.println(sj);//aaa---bbb---ccc
    }
}
~~~

`public StringJoiner(间隔符号, 开始符号, 结束符号)`，可以通过快捷键 <kbd>ctrl + p</kbd> 查看所对应的参数。

`delimiter`：间隔符号。

`prefix`：开始符号。

`suffix`：结束符号。

![image-20240408162526748](./assets/image-20240408162526748.png)

或者你先随便写，然后打印运行拼接后的结果，可以就可以区分出来参数的顺序了。

~~~java
package com.itheima.stringjoinerdemo;

import java.util.StringJoiner;

public class StringJoinerDemo2 {
    public static void main(String[] args) {
        //1.创建对象
        StringJoiner sj = new StringJoiner(", ","[","]");

        //2.添加元素
        sj.add("aaa").add("bbb").add("ccc");

        int len = sj.length();
        System.out.println(len);//15，PS：sj.length() 求的是字符的个数，除了我们添加的内容以外，还有上面的间隔符号、开始标记、结束标记也是需要算进来的。

        //3.打印
        System.out.println(sj);//[aaa, bbb, ccc]

        String str = sj.toString();
        System.out.println(str);//[aaa, bbb, ccc]
    }
}
~~~

---

## 六、总结

1、String：表示字符串的类，定义了很多操作字符串的方法

2、StringBuilder：一个可变的操作字符串的容器。它可以帮助我们快速的去操作字符串。

我们一般会用它的两个功能：拼接字符串、将容器里面的内容进行反转

3、StringJoiner：JDK8出现的一个可变的操作字符串的容器，可以高效，方便的拼接字符串

所以在以后，你在拼接字符串的时候，如果你要指定开始标记、结束标记、中间的间隔符号，此时你可以使用 `StringBuilder`。但是 `StringBuilder` 代码写起来有点麻烦，此时就可以使用 `StringJoiner`。



----

# 107.字符串相关类的底层原理

## 一、需要学习的知识点

1、字符串存储的内存原理

2、`==` 号比较的到底是什么

3、字符串拼接的底层原理

4、`StringBuilder` 提高效率原理图

5、`StringBuilder` 提高效率原理图

----

## 二、回顾已学知识

### 1）字符串存储的内存原理

字符串在存储的时候会有两种情况：

- 直接赋值：会复用字符串常量池中的东西

  因此直接赋值的方式代码更简单，更节省空间

- new出来的：不会复用，而是开辟一个新空间

----

### 2）`==` 号比较的到底是什么？

- 基本类型：比较的是数据值是否相同
- 引用数据类型：比较的是地址值是否相同

因此，我们以后不管是比较字符串也好，还是比较其他的引用数据类型也好，都不会使用 `==` 号，而是使用 `equals` 方法来进行比较。

---

## 三、`StringBuilder` 的 `toString()` 方法的源码分析

快捷键<kbd>ctrl + N</kbd> ，就会出现一个搜索的界面

![image-20240408172336795](./assets/image-20240408172336795.png)

然后输入 `StringBuilder`，点开右上角的 `Project Files` 默认情况下会选择 `Project Files` ，表示是在你当前项目中去找 `StringBuilder`，但我当前项目肯定没有，`StringBuilder` 是Java提供的。

![image-20240408172514999](./assets/image-20240408172514999.png)

因此我们需要将右上角选择成 `All Places`，表示在所有的地方都进行查询。

此时在下面就会出现 `StringBuilder` 相关所出现的所有的类。我们需要找到 `java.lang` 包下的 `StringBuilder`，用鼠标点击一下就可以了。

![image-20240408172834709](./assets/image-20240408172834709.png)

然后按快捷键 <kbd>ctrl + F12</kbd>，我们需要来找一个 `toString()` 方法，直接输入 `toString`，然后回车即可。

![image-20240408173002318](./assets/image-20240408173002318.png)

此时我们就可以可以通过这个方法查看 `StringBuilder` 是怎么变成一个字符串的。

这里它会调用一个 `newString()` 的方法。

![image-20240408173206400](./assets/image-20240408173206400.png)

选中它，然后 <kbd>ctrl + B</kbd> 跟进。

此时就知道了，它在底层变回字符串的时候，它是 `new` 出来的。

![image-20240408173247520](./assets/image-20240408173247520.png)

通过刚刚的源码分析，我们就可以得出一个结论：字符串和变量一次性加，在内存当中至少会有两个对象。一个是 `StringBuilder` 对象，还有一个是 `string` 字符串对象。

---

## 四、字符串拼接的底层原理

这个拼接是怎么拼接的，直接 `+` 就可以了吗，其实不是这样的。它会有两种情况

左边的情况：等号的右边没有变量参与。

右边的情况：等号的右边有变量参与。

![image-20240408170024508](./assets/image-20240408170024508.png)

---

### 1）情况一：等号的右边没有变量参与

例如以下代码

~~~java
String s = "a" + "b" + "c";
System.out.println(s); // "abc"
~~~

等号右边没有变量参与，都是字符串。这种情况相对来讲比较简单，它会触发字符串的一个优化机制，在编译的时候就已经是最终的结果了。

在书写代码的时候肯定要先书写Java文件，这个文件是我们自己书写的。然后我们可以通过 `javac` 命令把它编译成 `.class` 文件，也就是字节码文件。在编译的时候Java会做一个检查，检查在拼接的时候是否有变量参与。如果没有，在编译的时候就已经是拼接完之后的结果了，这个时候代码都没运行！

![image-20240408170600363](./assets/image-20240408170600363.png)

因此，当我们在用Java命令去编译的时候， `String s = "a" + "b" + "c"` 跟我们之前直接赋值的写法是完全一模一样的，也是串池中管理的地址！

----

### 2）情况二：如果在拼接的时候有变量参与

#### ① 在JDK8以前，会使用 `StringBuilder` 来进行拼接

例如下面代码，`s2`、`s3` 在拼接的时候都有变量参与了，接下来就看看拼接的时候的内存图。

![image-20240408170840298](./assets/image-20240408170840298.png)

首先main方法先进栈，因为虚拟机在运行的时候会自动调用main方法。

然后执行main方法中的第一行代码 `String s1 = "a";`，这种方式是直接赋值的，所以在栈中它有个变量叫 `s1`，因此会在栈中的main方法中定一个 `s1`，并且在右边的串池中会生成一个 `"a"`。

现在 `s1` 记录的就是字符串 `"a"` 的地址值。

![image-20240408171217106](./assets/image-20240408171217106.png)

再来看第二行代码 `String s2 = s1 + "b";`。这个 `"b"` 也会在串池中生成，然后重点来了。

它在拼接的时候有变量参与，在内存中，它首先会创建一个 `StringBuilder` 对象，然后通过 `append()` 方法把 `s1` 的内容和 `"b"` 都放到 `StringBuilder` 当中，但它现在仅仅只是一个 `StringBuilder` 而已，它还不是个字符串。

因此在底层它还会通过 `tostring()` 方法将它变回字符串，因此在这个字符串里的内容就是 `"ab"` 了。

所以第二行 `String s2 = s1 + "b";` 相当于 `new StringBuilder().append(s1).append("b").toString();` 这行代码。

而通过上面 `StringBuilder` 的 `toString()` 方法的源码分析 可知，字符串和变量一次性加，在内存当中至少会有两个对象。一个是 `StringBuilder` 对象，还有一个是 `string` 字符串对象。

![image-20240408171840862](./assets/image-20240408171840862.png)

再来看第三行代码 `String s3 = s2 + "c";`，这行代码其实跟刚刚的过程是一样的，在内存中它还会创建一个新的 `StringBuilder` 对象，注意，这是第二个 `StringBuilder` 对象，然后把 `s2` 的内容还有`"C"` 全部放进去，最后通过 `toString` 再创建一个新的字符串对象，最终 `s3` 中装的就是 `"abc"`。

![image-20240408174015920](./assets/image-20240408174015920.png)

通过刚刚的图解我们知道了，在JDK8以前，如果我们直接使用变量跟字符串进行拼接：一个加号，在堆内存中之上会有两个对象。

所以说非常的浪费性能，而且速度也非常的慢。

说到这里，有部分同学思考：这里不是也是用 `StringBuilder` 来拼接的吗，`StringBuilder` 不是可以用来提高效率吗？

能想到这个问题代表你思考了，但是你的格局要大，你不能光看一行代码，而是看两行。

例如这个案例的代码，每一行代码都创建了一个新的 `StringBuilder` 对象，所以说它的效率会比较慢；而我们只能说 `StringBuilder` 能提高效率，是因为我们在内存中只有一个 `StringBuilder` 对象，所有的字符串都往同一个 `StringBuilder` 对象里面放，这样才不会反复创建新的。

----

#### ② JDK8以后

随着JDK版本不断升高，到了JDK8的时候，它对字符串的拼接做了一个优化。

代码还是上一个案例的代码。在JDK8的时候，它做了一个优化，在拼接的时候有很多方案，但是默认是我们现在所说的这个方案。

首先它会先去预估这个字符串所需要的长度，并创建一个数组。因为现在 `s1`、`s2`、`s3` 的长度都是 1，所以它预估的总长度就是3，然后就创建一个长度为3的数组，把数组村上了 `["a", "b", "c"]`，最后再把这一个整体变成一个字符串，这个就是JDK8以后字符串的拼接方式。

![image-20240408174910506](./assets/image-20240408174910506.png)

如果我是在用JDK7包括7以前的版本去进行拼接，这里的 `s1 + s2 + s3` 至少会创建4个对象。

首先它在拼接的时候肯定是先拼 `s1 + s2`，首先需要创建一个 `StringBuilder`，然后把 `s1` 放进去，再把 `s2` 放进去，最后再 `toString()` 创建一个 `String` 对象，因此，这一步至少会有两个对象。

然后拿着拼接之后的结果，再去跟 `s3` 进行拼接，它又创建了一个 `StringBuilder`，然后把前面的结果放到新的 `StringBuilder` 对象中，最后再把 `s3` 放进去，拼接完毕后，再调用`toString()` 创建一个 `String` 对象，因此这一步又会创建两个新对象。

但是在JDK8的时候，它做了一个预估，这一行拼接的代码只需要一个数组，然后再去创建字符串对象就可以了。

但是话又说回来，这里的预估也是需要时间的，而且我有多行代码都要进行字符串跟变量的拼接的话，每一行就都要进行预估，然后再创建数组，再变成字符串。因此就算JDK优化了，还是一样的浪费空间浪费时间。

结论：如果很多字符串变量拼接，不要直接 `+` ，在底层会创建多个对象，浪费时间，浪费性能。用 `StringBuilder`、`StringJoiner` 都行。

---

## 五、`StringBuilder` 提高效率原理图

一开始main方法先进栈，第一行代码 `StringBuilder sb = new StringBuilder();` 是创建了一个 `StringBuilder` 对象，右边就是在栈中的main方法中定义了一个 `StringBuilder` 的 `sb` 变量，左边因为有 `new` 关键字，所以是在堆内存中开辟了一个空间，空间的地址值是 `0x0011`，接着就会把这个空间的地址值赋值给左边的 `sb`。

然后就是调用 `append` 方法，将 `"a"` 、`"b"`、`"c"` 分别添加到 `StringBuilder` 当中。

![image-20240408214552735](./assets/image-20240408214552735.png)

这里我们要注意的是 `StringBuilder` 是一个内存可变的容器，我们是把所有的数据都往同一个 `StringBuilder` 里放的，因此它的效率会很高。

说到这里，有的同学会有疑问：这个 `StringBuilder` 会撑爆吗？答案是不会的。

----

## 六、面试水体

之所以说它是水体是因为很简单。

### 1）问题：下列代码的运行结果是？

~~~java
public class Test3 {
    public static void main(String[] args) {
        String s1 = "abc"; // 由于是直接赋值的，它记录的的"abc"是串池中的地址值
        String s2 = "ab";
        String s3 = s2 + "c"; 
        System.out.println(s1 == s3); // false，堆里的和串池中的地址值肯定不一样
    }
}
~~~

字符串拼接的时候，如果有变量：

JDK8以前：系统底层会自动创建一个 `StringBuilder` 对象，然后再调用其append方法完成拼接。拼接后，再调用其toString方法转换为String类型，而toString方法的底层是直接new了一个字符串对象。

JDK8版本：系统会预估字符串拼接之后的总大小，把要拼接的内容都放在数组中，此时也是产生一个新的字符串。

因此只要有变量参与了，在底层就是创建一个新的字符串。

---

### 2）问题：下列代码的运行结果是？

~~~java
public class Test4 {
    public static void main(String[] args) {
        String s1 = "abc";
        String s2 = "a" + "b" + "c"; // 由于没有变量参与，在底层就会触发字符串的优化机制
        System.out.println(s1 == s3); // true，两个都是串池中的地址
    }
}
~~~

----

## 七、字符串原理小结

### 1）字符串拼接的底层原理

- 如果没有变量参与，都是字符串直接相加，编译成class文件之后就已经是拼接之后的结果，会复用串池中的字符串。
- 如果有变量参与，每一行拼接的代码都会在内存中创建新的字符串，浪费内存。

### 2）`StringBuilder` 提高效率原理图

- 所有要拼接的内容都会往 `StringBuilder` 中放，不会创建很多无用的内存，节约内存。

接下来就是要看 `StringBuilder` 的源码了。

---

## 八、`StringBuilder` 整体设计

### 1）分析

由于我们直接看源码会非常恶心，所以我们先看 `StringBuilder` 整体的设计，给大家过一下，然后再去看源码。

`StringBuilder` 在开始设计的时候，底层会创建一个字节数组，默认的容量是为 `16`。这不是长度，是容量。

容量表示最多能装多少，而长度表示我们实际装了多少。

![](./assets/202404091052532.png)

当我们现在把 `"abc"` 添加到 `StringBuilder` 当中的时候，实际上存的是 `"abc"` 在  ASCII码表上所对应的值，其他没有存的地方还是默认为0。此时它的容量还是 16，但是长度就已经变成了 3。

![image-20240409132002351](./assets/image-20240409132002351.png)

但如果我现在添加的元素比较多，超过了 16怎么办，例如我现在要添加的是 `a ~ z`，一共26个英文字母，此时 16 容量就不够了。

`StringBuilder` 会扩容，它会创建一个新的数组 `新数组容量 = 老容量 * 2 + 2`，原来的容量是 16，乘2再加2就是34，因此就会创建一个这样长度为34的数组。但实际的长度是24，后面还有8个空余。

![image-20240409132333426](./assets/image-20240409132333426.png)

如果一次性添加的数据比34还多，例如这次添加的元素为 `a ~ z、0 ~ 9`，此时就有 36 个了。

如果添加的数据已经超出了默认扩容的机制，这个时候它就会创建一个长度为 36 的数组再添加数据。

此时 `StringBuilder` 的容量是 36，长度也是 36。

前面的 26 个存 `0~z`，后面的 10 个存 `0 ~ 9`。

![image-20240409132700142](./assets/image-20240409132700142.png)

---

### 2）总结

- 默认创建一个长度为16的字节数组
- 添加的内容长度小于16，直接存
- 添加的内容大于16会扩容（扩容机制为：原来容量 * 2 + 2）
- 如果扩容之后还不够，以实际长度为准

添加的内容长度小于16，直接存

~~~java
public class Test4 {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        // 容量：最多装多少
        // 长度：已经装了多少
        System.out.println(sb.capacity()); // 16
        System.out.println(sb.length()); // 0

        sb.append('abc');
        System.out.println(sb.capacity()); // 16
        System.out.println(sb.length()); // 3
    }
}
~~~

添加的内容大于16会扩容（扩容机制为：原来容量 * 2 + 2）

~~~java
public class Test4 {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        // 容量：最多装多少
        // 长度：已经装了多少
        System.out.println(sb.capacity()); // 16
        System.out.println(sb.length()); // 0

        sb.append('abcdefghizklmnopqrstuvwsyz'); // 26 个英文字母
        System.out.println(sb.capacity()); // 34
        System.out.println(sb.length()); // 26
    }
}
~~~

如果扩容之后还不够，以实际长度为准

~~~java
public class Test4 {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        // 容量：最多装多少
        // 长度：已经装了多少
        System.out.println(sb.capacity()); // 16
        System.out.println(sb.length()); // 0

        sb.append("abcdefghizklmnopqrstuvwsyz0123456789"); // 26 个英文字母
        System.out.println(sb.capacity()); // 36
        System.out.println(sb.length()); // 36
    }
}
~~~

---

## 九、`StringBuilder` 的扩容机制

### 1）空参构造

首先选中 `StringBuilder` ，按住 <kbd>ctrl</kbd> 不松 ，然后用鼠标左键点一下

![image-20240409134235368](./assets/image-20240409134235368.png)

在这里，你看见了一个空参构造，括号里的参数就是 capacity，因此我们使用空参构造的时候，它会创建一个长度为16的字节数组。

![image-20240409134245472](./assets/image-20240409134245472.png)

继续按住 <kbd>ctrl</kbd> 不松 ，然后用鼠标左键点一下

![image-20240409134557698](./assets/image-20240409134557698.png)

`value = new byte[capacity];` 就是创建字节数组的代码，容量是 `capacity` ，也就是刚刚传进来的 16。

![image-20240409134620511](./assets/image-20240409134620511.png)

----

### 2）append的方法原码分析

选中 `StringBuilder.java` 这个类，然后按 <kbd>ctrl + F12</kbd> 找一下这里的 `append` 方法，`append` 方法它有很多重载的，我们来看一下 `append(string):StringBuilder` 这个（添加字符串的）。

![image-20240409135048790](./assets/image-20240409135048790.png)

这个方法里面它会调用其他的 `append` 方法，按住鼠标不动，然后左键点一下

![image-20240409135206499](./assets/image-20240409135206499.png)

它首先会对传入进来的 `str` 参数进行非空判断，如果说你要添加的是 null，此时它会调用一个 `appendNull()` 的方法，再点进去。

![image-20240409135334930](./assets/image-20240409135334930.png)

这个方法是往数组中添加 `n`、`u`、`l`、`l`，`count` 就表示当前已经存了多少字符。

一开始我们什么都没存，`count` 就是 0 ，n会放到数组的0索引位置上，存完了之后，`count++`。`u`会放到数组的1索引位置上，存完了之后，`count++`。以此类推。

![image-20240409135648640](./assets/image-20240409135648640.png)

<kbd>Ctrl + alt + ←</kbd> 回到上一步，如果你要添加的元素不是 `null` 就会继续走下面一段。 

第 `581` 行，先获取到你现在添加的字符串的长度。

`count + len` 中的 `count` 其实就是长度。验证：<kbd>ctrl + F12</kbd>，搜索 `length()` 方法，它就是将 `count` 给返回，因此这里的 `count` 就是 `length` （长度）。

`count + len` 就表示 `minimumCapacity`，意思就是现在要的最小的容量。

![image-20240409143333415](./assets/image-20240409143333415.png)

点进 `ensureCapacity` ，在 `ensureCapacity` 方法里会做很多判断。

如果 `minimumCapacity - oldCapacity` 小于等于 0 ，即老容量还够放，就不走大括号，这个方法就会直接结束。

大括号里的代码其实就是扩容。

如果 `minimumCapacity - oldCapacity` 大于 0，它就会满足它的扩容机制。

假设这次我将 `a ~ z` 长度为26的字符串添加进去。此时传进`ensureCapacity` 方法中的  `minimumCapacity` 最小容量就是 26。

扩容的时候调用了 `newCapacity` 方法，在扩容的时候将 `minimumCapacity` 最小容量 26 传递了过去。

![image-20240409144157743](./assets/image-20240409144157743.png)

点进 `newCapacity`，这个 `coder` 如果是 0 ，`2 << coder` 相当于不左移，因此它还是2，因此 `ArraysSupport.newLength` 传递的参数实际是：`oldLength, grouth, oldLength + 2`。

![image-20240409144352321](./assets/image-20240409144352321.png)

点进 `newLength` 方法。637 行中，`minGrowth, prefGrowth` 是拿着最小新增的，和老的 + 2，做一个比较。一个是 (26 - 16)，另一个是 18 。

`Math.max()` 点进去后，其实就是一个三元运算符。 <img src="./assets/image-20240409144728729.png" alt="image-20240409144728729" style="zoom:67%;" />

因此那肯定是 18 比较大，这里就是拿着18去加上前面的16，那就是相当于：`老容量 * 2 + 2`，即：34 。

此时将`老容量 * 2 + 2` 的结果赋值给前面的变量 `prefLength`，这个变量就表示我们现在要新建的数组的长度。

再来看 `第637行` 中：`int prefLength = oldLength + Math.max(minGrowth, prefGrowth);`

如果 新增的（minGrowth） 要比默认添加的（prefGrowth） 方式更大，就以我们现在新增的这个为准。

![image-20240409144612622](./assets/image-20240409144612622.png)

再回到上一步，现在我们知道了，通过 `257行代码`，就已经能计算出要创建的数组的长度了。

在下面它还做了一个判断 `if (length == Integer.MAX_VALUE)`，`Integer.MAX_VALUE` 是 `int` 的最大值。将鼠标放到上面，它会显示这个数值为多少。因此通过这一行代码也就知道了，它的容量是有上线的，最大也就是到 `Integer.MAX_VALUE`

![image-20240409152311797](./assets/image-20240409152311797.png)

如果长度小于 `Integer.MAX_VALUE` ，它就会将新增的长度返回。

![image-20240409152120226](./assets/image-20240409152120226.png)

再回到上一步，完事后，`ensureCapacityInternal` 方法调了一个 `copyOf` 的方法

![image-20240409152448041](./assets/image-20240409152448041.png)

点进 `copyof` 方法，此时它就会根据新的长度创建一个新的字节数组，然后通过 `System.arraycopy` ，这个方法是将原来数组里的东西拷贝到新数组中

![image-20240409152537559](./assets/image-20240409152537559.png)

再回到上两步，`ensureCapacityInternal(count + len);` 就相当于是对 `StringBuilder` 来做了一个扩容。

![image-20240409152730285](./assets/image-20240409152730285.png)

扩容完毕后，调用 `putStringAt` 方法，将我现在要添加的字符串添加到 `StringBuilder` 容器中，添加完毕后修改一下 `StringBuilder` 中常用的单位。

---

### 3）总结

看源码是我们作为程序员所必备的技能。

----

## 十、字符串原理小结

**1、字符串存储的内存原理**

- 直接赋值：会复用字符串常量池中的
- new出来的：是不会复用的，而是开辟了一个新的小空间

**2、`==` 号比的到底是什么？**

- 基本数据类型：比较的是真实的数据值
- 引用数据类型：比较的是地址值

**3、字符串拼接的底层原理**

- 如果没有变量参与，都是字符串直接相加，编译成class文件之后就已经是拼接之后的结果，会复用串池中的字符串。
- 如果有变量参与，每一行拼接的代码都会在内存中创建新的字符串，浪费内存。

因此如果已经想要对字符串进行拼接，不要直接 `+` ，用 `StringBuilder` /  `StringJoiner` 就可以了。

**4、`StringBuilder ` 提高效率原理图**

- 所有要拼接的内容都会往 `StringBuilder` 中放，不会创建很多无用的空间，节约内存。

**5、`StringBuilder` 的扩容机制**

- 默认创建一个长度为16的字节数组
- 添加内容长度小于16，直接存，不会扩容
- 添加的内容大于16就会扩容，扩容到：原来的容量 * 2 + 2
- 但如果我们添加的内容太多，已经超出了它默认的扩容容量了，此时它就会以实际的长度为准。



---

# 108.练习：罗马数字的两种写法

键盘录入一个字符串

要求1：长度为小于等于9

要求2：只能是数字，将内容变成罗马数字

下面是阿拉伯数字跟罗马数字的对比关系：

Ⅰ－1、Ⅱ－2、Ⅲ－3、Ⅳ－4、Ⅴ－5、Ⅵ－6、Ⅶ－7、Ⅷ－8、Ⅸ－9
        注意点：
        罗马数字里面是没有0的
        如果键盘录入的数字包含0，可以变成""(长度为0的字符串)

快捷方式，将光标放到等号两边的任意一边，然后 <kbd>alt + 回车</kbd> 就可以将语句进行分隔

![image-20240409170940050](./assets/image-20240409170940050.png)

然后 <kbd>shift + alt + 回车</kbd> 就可以将分隔出来的代码进行上下移动了

## 解法一

~~~java
package com.itheima.test;

import java.util.Scanner;

public class Test1Case1 {
    public static void main(String[] args) {
        //1.键盘录入一个字符串
        //书写Scanner的代码
        Scanner sc = new Scanner(System.in);
        String str;
        while (true) {
            System.out.println("请输入一个字符串");
            str = sc.next();
            //2.校验字符串是否满足规则
            boolean flag = checkStr(str);
            if (flag) {
                break;
            } else {
                System.out.println("当前的字符串不符合规则，请重新输入");
                continue;
            }
        }

        //将内容变成罗马数字
        //下面是阿拉伯数字跟罗马数字的对比关系：
        //Ⅰ－1、Ⅱ－2、Ⅲ－3、Ⅳ－4、Ⅴ－5、Ⅵ－6、Ⅶ－7、Ⅷ－8、Ⅸ－9
        //查表法：数字跟数据产生一个对应关系
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            int number = c - 48; // 1 2 3 4 5
            String s = changeLuoMa(number);
            sb.append(s);
        }

        System.out.println(sb);

    }

    public static String changeLuoMa(int number) {
        //定义一个数组，让索引跟罗马数字产生一个对应关系
        String[] arr = {"", "Ⅰ", "Ⅱ", "Ⅲ", "Ⅳ", "Ⅴ", "Ⅵ", "Ⅶ", "Ⅷ", "Ⅸ"};
        return arr[number];

    }


    public static boolean checkStr(String str) {//123456
        //要求1：长度为小于等于9
        if (str.length() > 9) {
            return false;
        }

        //要求2：只能是数字
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);//0~9
            if (c < '0' || c > '9') {
                return false;
            }
        }

        //只有当字符串里面所有的字符全都判断完毕了，我才能认为当前的字符串是符合规则
        return true;
    }
}
~~~

----

## 解法二

快捷键 <kbd>ctrl + d</kbd> ：向下复制一行

~~~java
package com.itheima.test;

import java.util.Scanner;

public class Test1Case2 {
    public static void main(String[] args) {
        //1.键盘录入一个字符串
        //书写Scanner的代码
        Scanner sc = new Scanner(System.in);
        String str;
        while (true) {
            System.out.println("请输入一个字符串");
            str = sc.next();
            //2.校验字符串是否满足规则
            boolean flag = checkStr(str);
            if (flag) {
                break;
            } else {
                System.out.println("当前的字符串不符合规则，请重新输入");
                continue;
            }
        }

        //将内容变成罗马数字
        //下面是阿拉伯数字跟罗马数字的对比关系：
        //Ⅰ－1、Ⅱ－2、Ⅲ－3、Ⅳ－4、Ⅴ－5、Ⅵ－6、Ⅶ－7、Ⅷ－8、Ⅸ－9
        //查表法：数字跟数据产生一个对应关系
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            String s = changeLuoMa(c);
            sb.append(s);
        }

        System.out.println(sb);

    }

    //利用switch进行匹配
    public static String changeLuoMa(char number) {
        String str = switch (number) {
            case '0' -> "";
            case '1' -> "Ⅰ";
            case '2' -> "Ⅱ";
            case '3' -> "Ⅲ";
            case '4' -> "Ⅳ";
            case '5' -> "Ⅴ";
            case '6' -> "Ⅵ";
            case '7' -> "Ⅶ";
            case '8' -> "Ⅷ";
            case '9' -> "Ⅸ";
            default -> str = "";
        };
        return str;
    }


    public static boolean checkStr(String str) {//123456
        //要求1：长度为小于等于9
        if (str.length() > 9) {
            return false;
        }

        //要求2：只能是数字
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);//0~9
            if (c < '0' || c > '9') {
                return false;
            }
        }

        //只有当字符串里面所有的字符全都判断完毕了，我才能认为当前的字符串是符合规则
        return true;
    }
}
~~~



----

# 109.练习：调整字符串的内容并比较

给定两个字符串, A和B。
        A的旋转操作就是将A 最左边的字符移动到最右边。
        例如, 若A = 'abcde'，在移动一次之后结果就是'bcdea'
        如果在若干次调整操作之后，A能变成B，那么返回True。
        如果不能匹配成功，则返回false

## 解法一

~~~java
package com.itheima.test;

public class Test2Case1 {
    public static void main(String[] args) {
        //1.定义两个字符串
        String strA = "abcde";
        String strB = "ABC";


        //2.调用方法进行比较
        boolean result = check(strA, strB);

        //3.输出
        System.out.println(result);


    }

    public static boolean check(String strA, String strB) {
        for (int i = 0; i < strA.length(); i++) {
            strA = rotate(strA);
            if(strA.equals(strB)){
                return true;
            }
        }
        //所有的情况都比较完毕了，还不一样那么直接返回false
        return false;
    }


    //作用：旋转字符串，把左侧的字符移动到右侧去
    //形参：旋转前的字符串
    //返回值：旋转后的字符串
    public static String rotate(String str) {
        //套路：
        //如果我们看到要修改字符串的内容
        //可以有两个办法：
        //1.用subString进行截取，把左边的字符截取出来拼接到右侧去
        //2.可以把字符串先变成一个字符数组，然后调整字符数组里面数据，最后再把字符数组变成字符串。


        //截取思路
        //获取最左侧那个字符
        char first = str.charAt(0);
        //获取剩余的字符
        String end = str.substring(1);

        return end + first;
    }
}
~~~

---

## 解法二

`toCharArray()` 方法将字符串变成字符数组

~~~java
package com.itheima.test;

public class Test2Case2 {
    public static void main(String[] args) {
       /* 给定两个字符串, A和B。
        A的旋转操作就是将A 最左边的字符移动到最右边。
        例如, 若A = 'abcde'，在移动一次之后结果就是'bcdea'
        如果在若干次调整操作之后，A能变成B，那么返回True。
        如果不能匹配成功，则返回false*/

        //1.定义两个字符串
        String strA = "abcde";
        String strB = "ABC";


        //2.调用方法进行比较
        boolean result = check(strA, strB);

        //3.输出
        System.out.println(result);
    }

    public static boolean check(String strA, String strB) {
        for (int i = 0; i < strA.length(); i++) {
            strA = rotate(strA);
            if (strA.equals(strB)) {
                return true;
            }
        }
        //所有的情况都比较完毕了，还不一样那么直接返回false
        return false;
    }


    //作用：旋转字符串，把左侧的字符移动到右侧去
    //形参：旋转前的字符串        
    //返回值：旋转后的字符串
    public static String rotate(String str) {
        //套路：
        //如果我们看到要修改字符串的内容
        //可以有两个办法：
        //1.用subString进行截取，把左边的字符截取出来拼接到右侧去
        //2.可以把字符串先变成一个字符数组，然后调整字符数组里面数据，最后再把字符数组变成字符串。

        //可以把字符串先变成一个字符数组，然后调整字符数组里面数据，最后再把字符数组变成字符串。


        //"ABC"   ['A','B','C']  ['B','C','A']   new String(字符数组);
        char[] arr = str.toCharArray();
        //拿到0索引上的字符
        char first = arr[0];
        //把剩余的字符依次往前挪一个位置
        for (int i = 1; i < arr.length; i++) {
            arr[i - 1] = arr[i];
        }
        //把原来0索引上的字符放到最后一个索引
        arr[arr.length - 1] = first;

        //利用字符数组创建一个字符串对象
        String result = new String(arr);
        return result;
    }
}
~~~



---

# 110.四道字符串练习题思路

## 练习一：键盘输入任意字符串，打乱里面的内容

**思路**

~~~java
package com.itheima.test;

public class Test3 {
    public static void main(String[] args) {
        //键盘输入任意字符串，打乱里面的内容

        //1.键盘输入任意字符串
        String str = "abcdefg";


        //2.打乱里面的内容
        //修改字符串里面的内容：
        //1.subString
        //2.变成字符数组
        char[] arr = str.toCharArray();//['a','b','c','d','e','f','g']

        //3.打乱数组里面的内容
        //从0索引开始，跟一个随机索引进行位置的交换
        //当数组里面的每一个元素都跟一个随机索引进行交换完毕之后，那么内容就打乱了

        //4.把字符数组再变回字符串
        String result = new String(arr);

        System.out.println(result);
    }
}

~~~

---

## 练习二：生成验证码

生成验证码
内容：可以是小写字母，也可以是大写字母，还可以是数字
规则：
长度为5
内容中是四位字母，1位数字。
其中数字只有1位，但是可以出现在任意的位置。

**思路**

~~~java
package com.itheima.test;

public class Test4 {
    public static void main(String[] args) {
        //1.可以把所有的大写字母，小写字母都放到一个数组当中
        char[] arr = new char[52];
        //a-z  A-Z

        //2.从数组中随机获取4次

        //3.生成一个0~9之间的随机数拼接到最后
        //例如ACFG7
        //思考，我们把7放到前面，修改了字符串的内容
        //把生成的验证码先变成一个字符数组
        //再让最后一个元素跟前面的随机位置的元素进行交换
        //交换完毕之后再变成字符串就可以了。
    }
}
~~~

----

## 练习三：字符串相乘

给定两个以字符串形式表示的非负整数num1和num2，返回num1和num2的乘积，它们的乘积也表示为字符串形式。
注意：需要用已有的知识完成。

~~~java
package com.itheima.test;

public class Test5 {
    public static void main(String[] args) {
        //PS：不需要考虑乘积过大之后的结果，就认为乘积一定是小于int的最大值的


        String num1 = "123456789";
        String num2 = "12345";

        //1.把num1和num2变成对应的整数才可以
        //"123456789"
        //先遍历字符串依次得到每一个字符 '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'
        //再把字符变成对应的数字即可     1    2    3     4    5    6    7    8    9
        //把每一个数字组合到一起 123456789

        //2.利用整数进行相乘


        //3.可以把整数变成字符串
        //+ ""
    }
}
~~~

---

练习四：

给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。
        返回字符串中最后一个单词的长度。
        单词是指仅由字母组成、不包含任何空格字符的最大子字符串。

​    示例 1：输入：s = "Hello World“	输出：5
​    解释：最后一个单词是“World”，长度为5。

​    示例 2：输入：s = "   fly me   to   the moon"	输出：4
​    解释：最后一个单词是“moon”，长度为4。

​    示例 3：输入：s = "luffy is still joyboy"	输出：6
​    解释：最后一个单词是长度为6的“joyboy”。

~~~java
package com.itheima.test;

public class Test6 {
    public static void main(String[] args) {
        //倒着遍历
        //直到遇到空格为止
        //那么遍历的次数就是单词的长度
    }
}
~~~



----

# ------------------------------------

# Day 11 集合

# 111.集合的基本使用

## 一、为什么要有集合？

如果我现在想同时存储多个元素，我们该怎么办？

数组就可以干这件事情，但是数组有弊端。

数组的长度是固定的，一旦创建完毕后，长度就不能发生变化了。那能不能有一个容器它的长度是可变的呢？当然有，这个容器就是我们今天要学习的集合。

集合是一个容器，它也是可以来存储多个数据，只不过它的长度是可以发生变化的。

当我们在创建一个集合对象的时候，因为一开始还没有添加元素，因此集合的长度一开始是为0。然后添加了第一个元素，集合的长度会自动扩容变成1，不需要我们管，集合底层自动实现的，我们只需要把元素添加进去就可以了。当添加第二个元素进去的时候，集合的长度会再次扩容变成2。添加第三个元素，它的长度会再次扩容变成3.............**在这个过程中，最为重要的四个字：自动扩容**

----

## 二、集合存储数据类型的特点

除此之外，集合跟数组在存储元素之外还有第二个区别。

数组是可以存储基本数据类型的，例如 `int[] arr1 = new int[3];`

数组也是可以存储引用数据类型的，例如 `User[] userArr = new User[2];`

但是集合只可以存引用数据类型。

![image-20240409193940915](./assets/image-20240409193940915.png)

但如果我们就是想存 `1~9` 这样的整数，或者是小数，或者是字符怎么办，就需要将它们变成其对应的包装类。

----

## 三、集合和数组的对比

### 1）长度的区别

数组的长度是固定的，集合的长度是可变的，当我们往集合中添加了一个元素后，集合的长度自动加1，删除一个元素，集合的长度自动减一。如果我们添加了两个元素，集合的长度自动加二，删除两个元素，集合的长度自动减二。非常的灵活，用八个字去形容：自动伸缩，可长可短。

### 2）存储类型的区别

数组是可以存储基本数据类型的，例如整数、小数、字符、布尔.....

数组还可以存引用数据类型。

但是集合只能存引用数据类型，如果需要存基本数据类型，需要把它们变成其对应的包装类才可以。

![image-20240409194447665](./assets/image-20240409194447665.png)

----

## 四、集合

在Java中其实规定了很多很多种结合，每种集合都有其各自的特点。

![image-20240409194853313](./assets/image-20240409194853313.png)

现在我们先来学习以后用的最多的 `ArrayList` 集合。

-----

## 五、ArrayList集合

想要学习这个类，肯定要来看它的构造和成员方法，因此我们先打开API帮助文档先查阅一下。

`ArrayList` 是定义在 `java.util` 包下的，因此我们一会在使用的时候需要导包。

![image-20240409195041604](./assets/image-20240409195041604.png)

在类名的右侧有个 `<E>`，这个 `<E>` 就是泛型，我们在创建对象的时候，`ArrayList` 后面也要写这样的 `<>`，`<>` 里面写存储的数据类型就可以了。

![image-20240409195244793](./assets/image-20240409195244793.png)

再往下看的就是构造方法，构造是一个空参的，我们就用它就行。

![image-20240409195345908](./assets/image-20240409195345908.png)

创建完对象后，我们就可以成员方法对集合里的数据进行添加、删除、查找等等。

~~~java
package com.itheima.listdemo;

import java.util.ArrayList;

public class ArrayListDemo1 {
    public static void main(String[] args) {
        //1.创建集合的对象，集合的对象创建完毕后，就好比存储数据的容器就有了
        // 但是这么写会有个小问题，集合也是个容器，也可以用来存储数据，但这里容器中的数据类型没发限定
        ArrayList list = new ArrayList();
        //此时我们就需要引入一个概念 —— 泛型，泛型的作用：限定集合中存储数据的类型
        // 如果在里面写了int，就会报错，因为集合里面不能直接存基本数据类型
        ArrayList<int> list = new ArrayList();
        // 但我们可以写字符串，因为在字符串是引用数据类型，前面写了，后面也需要写，即在类名的后面都需要写上
        // 这句话的意思就是：我们创建了一个集合用来存储数据，集合以后只能存储String这样的字符串
        ArrayList<String> list = new ArrayList<String>();
        // 但是这种写法是JDK7以前的写法，到了JDK7以后，它觉得，我前面写过了，那后面还要再写一遍，太麻烦了，因此后面的String可以省略不写，但是<>一定要留着
        ArrayList<String> list = new ArrayList<String>();

        //解释[]：
        //此时我们创建的是ArrayList的对象，而ArrayList是java已经写好的一个类
        //这个类在底层做了一些处理
        //1.打印对象不是地址值，而是集合中存储数据内容
        //2.在展示的时候会拿[]把所有的数据进行包裹
        //如果[]中间什么也没有，就表示集合现在是空的，它的长度为0，里面是没有内容的
        ArrayList<String> list = new ArrayList<>();
        System.out.println(list);
    }
}
~~~

----

## 六、`ArrayList` 成员方法

虽然方法很多，但是我们可以总结为四个字：增、删、改、查。

查的时候我们可以查询单个的，也可以查询集合中所有的元素。

所以说我们以后在学习这种容器类的知识点的时候，抓住 增、删、改、查 这四个字就可以了。

| 方法名                                  | 说明                                   |
| :-------------------------------------- | -------------------------------------- |
| `public boolean add(要添加的元素)`      | 将指定的元素追加到此集合的末尾         |
| `public boolean remove(要删除的元素)`   | 删除指定元素,返回值表示是否删除成功    |
| `public E  remove(int   index)`         | 删除指定索引处的元素，返回被删除的元素 |
| `public E   set(int index,E   element)` | 修改指定索引处的元素，返回被修改的元素 |
| `public E   get(int   index)`           | 返回指定索引处的元素                   |
| `public int   size()`                   | 返回集合中的元素的个数                 |

----

### 1）`boolean add(E e)`

`list.add("aaa");` 代码中，调用 `add` 方法时候，括号里面的 `e` 就表示 element，即添加元素的意思。

这里的 `e` 的类型是 `String`，就表示现在可以往里面添加字符串。

方法的返回值是布尔类型的，表示当前的元素是否添加成功。

![image-20240409201733732](./assets/image-20240409201733732.png)

`ArrayList` 集合有一个特点，就是不管添加什么，它都是可以添加成功的，因此这个方法永远返回一个 `true`。

我们可以来看看 `add` 的源码，选中 `add`，然后<kbd>ctrl + b</kbd>。

![image-20240409202500042](./assets/image-20240409202500042.png)

虽然中间这两行我们暂时看不懂，没关系，我们直接看最后一句话。在添加完毕后，它直接 return 一个 `true`。

![image-20240409202408025](./assets/image-20240409202408025.png)

由于因为不管添加什么，都会返回一个`true`，因此我们在添加的时候一般是不会去管它的返回值的，也就是说我们直接调用方法，直接使用方法本身的添加功能就可以了：`list.add("aaa");`

~~~java
//1.创建一个集合
ArrayList<String> list = new ArrayList<>();

//2.添加元素
list.add("aaa");
list.add("aaa");
list.add("bbb");
list.add("ccc");
~~~

---

### 2）`boolean remove(E e)`

元素删除成功，返回一个 `true`；如果删除失败，返回 `false`

~~~java
boolean result1 = list.remove("aaa");
System.out.println(result1); // true

boolean result2 = list.remove("ddd");
System.out.println(result2); // 当你要删除的元素不存在的时候，就会返回false
~~~

----

### 3）`E remove(int index)`

根据索引删除，看到这个方法就知道，`ArrayList集合` 还有索引，它的索引规则跟数组、字符串的规则都是一样的，都是从0开始，逐一增长，中间不间断的。

如果是通过索引删除的，它就会把被删除的元素返回。

~~~java
String str = list.remove(2);
System.out.println(str); // "aaa"
~~~

----

### 3）`E set(int index,E e)` 

把被覆盖的元素，也就是原来的旧值返回。

~~~java
String result = list.set(1, "ddd"); // 将 1 索引上的元素变成 "ddd"
System.out.println(result); // 接收到的是 "aaa"，即被覆盖的字符串
~~~

----

### 4）`E get(int index)`

根据制定的索引来查询到对应的元素。

~~~java
String s = list.get(0);
System.out.println(s); // "aaa"
~~~

----

### 5）`int size()`

获取集合的长度，要注意的是，集合的长度不叫做 `length()` 了，而是 `size()`，而且它也是个方法，在调用的时候需要加一个 `()`。

方法就会将集合的长度做一个返回。

`get()` 方法与 `size()` 方法结合起来就可以做一个变量，遍历同样不需要我们手写，使用IDEA快捷方式自动生成就可以了：<kbd>list.fori</kbd> 。

![image-20240409204619829](./assets/image-20240409204619829.png)

~~~java
//遍历
for (int i = 0; i < list.size(); i++) {
    //i 索引
    //list.get(i) 元素
    String str = list.get(i);
    System.out.println(str);
}
~~~

----

# 112.练习：添加字符串和整数 并遍历

## 一、练习：集合的遍历方式

需求：定义一个集合，添加字符串，并进行遍历。

遍历格式按照：`[元素1, 元素2, 元素3]`

~~~java
package com.itheima.test;

import java.util.ArrayList;

public class Test1 {
    public static void main(String[] args) {
        //1.创建集合
        ArrayList<String> list = new ArrayList<>();

        //2.添加元素
        list.add("点赞了吗？");
        list.add("收藏了吗？");
        list.add("投币了吗？");
        list.add("转发了吗？");

        //3.遍历
        System.out.print("[");
        for (int i = 0; i < list.size(); i++) {
            if(i == list.size() - 1){
                System.out.print(list.get(i));
            }else{
                System.out.print(list.get(i) + ", ");
            }
        }
        System.out.println("]");
    }
}
~~~

----

## 二、基本数据类型对应的包装类

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| byte         | Byte      |
| short        | Short     |
| char         | Character |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |
| boolean      | Boolean   |

在这些当中，其实我们只需要记住 `char ——> Character`、`int ——> Integer` 就可以了。

并且这些都不需要我们去背，使用IDEA就可以关联出来了。

----

## 三、练习：添加数字并遍历

需求：定义一个集合，添加数字，并进行遍历。

集合中是不能添加基本数据类型的，如果一定要添加，就需要将它变成对应的包装类。

PS：在写 `ArrayList` 的泛型的时候，我们不能直接写 `int`，而是需要写 `Integer`。

~~~java
package com.itheima.test;

import java.util.ArrayList;

public class Test2 {
    public static void main(String[] args) {
        //1.创建集合
        ArrayList<Integer> list = new ArrayList<>();

        //2.添加元素
        //jdk5以后 int 和 Integer 之间是可以互相转化的
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        list.add(5);

        //3.遍历集合
        System.out.print("[");
        for (int i = 0; i < list.size(); i++) {
            if(i == list.size() - 1){
                System.out.print(list.get(i));
            }else{
                System.out.print(list.get(i) + ", ");
            }
        }
        System.out.println("]");
    }
}
~~~

----

## 四、练习：添加字符

需求：定义一个集合，添加字符。

此时创建 `ArrayList对象` 的时候泛型不能写 `char`，而需要写 `Character` 即可。

~~~java
package com.itheima.test;

import java.util.ArrayList;

public class Test3 {
    public static void main(String[] args) {
        ArrayList<Character> list = new ArrayList<>();

        list.add('a');
        list.add('b');
        list.add('c');

        System.out.println(list);
    }
}
~~~



----

# 113.练习：添加学生对象并遍历的两个练习

## 一、添加学生对象并遍历 —— 一

需求：定义一个集合，添加一些学生对象，并进行遍历。

学生类的属性为：姓名、年龄。

**Student.java**

~~~java
package com.itheima.test;

public class Student {
    //标准JavaBean：
    //1.私有化成员变量
    //2.空参构造方法
    //3.带全部参数的构造方法
    //4.get/set方法

    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
~~~

**Test4.java**

这里 `ArrayList` 的泛型写什么？泛型写什么应该看元素的类型，而我现在的元素是学生对象，因此这里的泛型应该写 `Student`。

由于我们的泛型是 `Student`，因此我们只能往里面添加 `Student` 类型的对象。

![image-20240409211412197](./assets/image-20240409211412197.png)

~~~java
package com.itheima.test;

import java.util.ArrayList;

public class Test4 {
    public static void main(String[] args) {
        //1.创建集合
        ArrayList<Student> list = new ArrayList<>();

        //2.创建学生对象
        Student s1 = new Student("zhangsan",23);
        Student s2 = new Student("lisi",24);
        Student s3 = new Student("wangwu",25);

        //3.添加元素
        list.add(s1);
        list.add(s2);
        list.add(s3);

        //4.遍历集合
        for (int i = 0; i < list.size(); i++) {
            //i 索引 list.get(i) 元素/学生对象
            Student stu = list.get(i);
            // 由于直接打印 stu 的时候都是地址值，地址值对我来讲没有用，因此需要将里面的属性给 get 出来才行
            System.out.println(stu.getName() + ", " + stu.getAge());
        }
    }
}
~~~

----

## 二、练习二：添加学生对象并遍历 —— 二

需求：定义一个集合，添加一些学生对象，并进行遍历。

学生类的属性为：姓名、年龄。

要求：对象的数据来自键盘录入。

~~~java
package com.itheima.test;

import java.util.ArrayList;
import java.util.Scanner;

public class Test5 {
    public static void main(String[] args) {
        //1.创建集合
        ArrayList<Student> list = new ArrayList<>();
        //长度为0
        //2.键盘录入学生的信息并添加到集合当中
        Scanner sc = new Scanner(System.in);
        for (int i = 0; i < 3; i++) {
            Student s = new Student(); // 创建对象只能写在循环里面！
            System.out.println("请输入学生的姓名");
            String name = sc.next();
            System.out.println("请输入学生的年龄");
            int age = sc.nextInt();

            //把name和age赋值给学生对象
            s.setName(name);
            s.setAge(age);

            //把学生对象添加到集合当中
            list.add(s);
        }
        //3.遍历
        for (int i = 0; i < list.size(); i++) {
            //i 索引 list.get(i) 元素/学生对象
            Student stu = list.get(i);
            System.out.println(stu.getName() + ", " + stu.getAge());
        }
    }
}
~~~



----

# 114.练习：查找用户是否存在

## 一、查找用户是否存在

需求： 

1、main方法中定义一个集合，存入三个用户对象。 

   用户属性为：id，username，password    

2、要求：定义一个方法，根据id查找对应的学生信息。

   如果存在，返回 `true`

   如果不存在，返回 `false`

User.java

~~~java
package com.itheima.test;

public class User {
    private String id;
    private String username;
    private String password;


    public User() {
    }

    public User(String id, String username, String password) {
        this.id = id;
        this.username = username;
        this.password = password;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
~~~

Test6.test —— 1

~~~java
package com.itheima.test;

import java.util.ArrayList;

public class Test6 {
    public static void main(String[] args) {
        //1.创建集合
        ArrayList<User> list = new ArrayList<>();

        //2.创建三个用户对象
        User u1 = new User("heima001","zhangsan","123456");
        User u2 = new User("heima002","lisi","12345678");
        User u3 = new User("heima003","wangwu","1234qwer");

        //3.把用户对象添加到集合当中
        list.add(u1);
        list.add(u2);
        list.add(u3);

        //4.调用方法查看id是否存在
        boolean flag = contains(list, "heima0010");

        //5.打印结果
        System.out.println(flag);

    }

    //1.我要干嘛？   根据id查找用户
    //2.我干这件事需要什么才能完成？   list  id
    //3.调用处是否需要使用方法的结果？ 返回
    public static boolean contains(ArrayList<User> list, String id){
        for (int i = 0; i < list.size(); i++) {
            User u = list.get(i);
            String uid = u.getId();
            if(uid.equals(id)){
                //如果找到了直接返回true
                return true;
            }
        }
        //当循环结束表示集合里面所有的元素都已经比较完毕，还没有一样的，那么返回false就可以了
        return false;
    }
}
~~~

---

## 二、变形题1

Test6.test —— 2

~~~java
package com.itheima.test;

import java.util.ArrayList;

/*需求：
1，main方法中定义一个集合，存入三个用户对象。
      用户属性为：id，username，password
2，要求：定义一个方法，根据id查找对应的用户信息。
      如果存在，返回索引
      如果不存在，返回-1
*/
public class Test7 {
    public static void main(String[] args) {
        //1.创建集合
        ArrayList<User> list = new ArrayList<>();

        //2.创建三个用户对象
        User u1 = new User("heima001", "zhangsan", "123456");
        User u2 = new User("heima002", "lisi", "12345678");
        User u3 = new User("heima003", "wangwu", "1234qwer");

        //3.把用户对象添加到集合当中
        list.add(u1);
        list.add(u2);
        list.add(u3);

        //4.查找索引
        int index = getIndex(list, "heima004");

        //5.打印
        System.out.println(index);
    }


    public static int getIndex(ArrayList<User> list, String id) {
        for (int i = 0; i < list.size(); i++) {
            User u = list.get(i);
            String uid = u.getId();
            if(uid.equals(id)){
                return i;
            }
        }

        return -1;
    }
}
~~~

---

## 三、变形题2

如果题目即要我返回 `true` 跟 `false`，还要返回索引。此时我们就可以把刚刚的两个练习进行合并。

就不需要将两个方法完全写完，在写 `contains` 方法的时候可以调用 `getIndex` 方法，相当于一个偷懒。偷懒是程序员的一个美德，一定要把这个美德发展下去。

~~~java
package com.itheima.test;

import java.util.ArrayList;
public class Test6 {
    public static void main(String[] args) {
        //1.创建集合
        ArrayList<User> list = new ArrayList<>();

        //2.创建三个用户对象
        User u1 = new User("heima001","zhangsan","123456");
        User u2 = new User("heima002","lisi","12345678");
        User u3 = new User("heima003","wangwu","1234qwer");

        //3.把用户对象添加到集合当中
        list.add(u1);
        list.add(u2);
        list.add(u3);

        //4.调用方法查看id是否存在
        boolean flag = contains(list, "heima0010");

        //5.打印结果
        System.out.println(flag);

    }

    //1.我要干嘛？   根据id查找用户
    //2.我干这件事需要什么才能完成？   list  id
    //3.调用处是否需要使用方法的结果？ 返回
    public static boolean contains(ArrayList<User> list, String id){
       /* for (int i = 0; i < list.size(); i++) {
            User u = list.get(i);
            String uid = u.getId();
            if(uid.equals(id)){
                //如果找到了直接返回true
                return true;
            }
        }
        //当循环结束表示集合里面所有的元素都已经比较完毕，还没有一样的，那么返回false就可以了
        return false;*/

       return getIndex(list,id) >= 0;

    }


    public static int getIndex(ArrayList<User> list, String id) {
        for (int i = 0; i < list.size(); i++) {
            User u = list.get(i);
            String uid = u.getId();
            if(uid.equals(id)){
                return i;
            }
        }

        return -1;
    }
}
~~~



----

# 115.练习：返回多个数据

需求：
定义Javabean类：Phone
Phone属性：品牌，价格。
main方法中定义一个集合，存入三个手机对象。
分别为：小米，1000。苹果，8000。锤子 2999。
定义一个方法，将价格低于3000的手机信息返回。

Phone.java

~~~java
package com.itheima.test;

public class Phone {
    //Phone属性：品牌，价格。
    private String brand;
    private int price;

    public Phone() {
    }


    public Phone(String brand, int price) {
        this.brand = brand;
        this.price = price;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }
}
~~~

Test8.test

~~~java
package com.itheima.test;
import java.util.ArrayList;

public class Test8 {
    public static void main(String[] args) {

        //1.创建集合对象
        ArrayList<Phone> list = new ArrayList<>();

        //2.创建手机的对象
        Phone p1 = new Phone("小米",1000);
        Phone p2 = new Phone("苹果",8000);
        Phone p3 = new Phone("锤子",2999);

        //3.添加数据
        list.add(p1);
        list.add(p2);
        list.add(p3);

        //4.调用方法
        ArrayList<Phone> phoneInfoList = getPhoneInfo(list);

        //5.遍历集合
        for (int i = 0; i < phoneInfoList.size(); i++) {
            Phone phone = phoneInfoList.get(i);
            System.out.println(phone.getBrand() + ", " + phone.getPrice());
        }

    }


    //1.我要干嘛？ 查询手机信息
    //2.我干这件事情，需要什么才能完成？  集合
    //3.我干完了，方法的调用处是否需要继续使用结果？  返回

    //技巧：
    //如果我们要返回多个数据，可以把这些数据先放到一个容器当中，再把容器返回
    //集合 数组
    public static ArrayList<Phone> getPhoneInfo(ArrayList<Phone> list){
        //定义一个集合用于存储价格低于3000的手机对象
        ArrayList<Phone> resultList = new ArrayList<>();
        //遍历集合
        for (int i = 0; i < list.size(); i++) {
            Phone p = list.get(i);
            int price = p.getPrice();
            //如果当前手机的价格低于3000，那么就把手机对象添加到resultList中
            if(price < 3000){
                resultList.add(p);
            }
        }
        //返回resultList
        return resultList;
    }
}
~~~



----

# 116.学生管理系统 —— 业务分析并搭建主菜单

以后工作中一般都会给一个需求文档，这个文档就写了当前项目中所有的业务操作，我们作为开发者需要学会阅读需求文档，从文档当中找出业务流程再去书写代码。

## 一、需求文档

----

学生管理系统

**需求**：

​	采取控制台的方式去书写学生管理系统。

> 控制台：所有的操作，所有的展示都是在控制台里面进行的。
>
> 等我们以后学习完在浏览器中展示数据的方式之后，我们也可以把它移植到浏览器当中。

一开始会有个分析，它告诉你这个项目中所有的流程。

**分析**：

**初始菜单**：

```java
"-------------欢迎来到黑马学生管理系统----------------"
"1：添加学生"
"2：删除学生"
"3：修改学生"
"4：查询学生"
"5：退出"
"请输入您的选择:"
```

**学生类**：

属性：id、姓名、年龄、家庭住址

**添加功能**：

键盘录入每一个学生信息并添加，需要满足以下要求：id唯一

**删除功能**：

键盘录入要删除的学生id，需要满足以下要求：

* id存在删除
* id不存在，需要提示不存在，并回到初始菜单

**修改功能**：

键盘录入要修改的学生id，需要满足以下要求

* id存在，继续录入其他信息
* id不存在，需要提示不存在，并回到初始菜单

**查询功能**：

打印所有的学生信息，需要满足以下要求

* 如果没有学生信息，提示：当前无学生信息，请添加后再查询
* 如果有学生信息，需要按照以下格式输出。（不用过于纠结对齐的问题）

```java
id			姓名		年龄		家庭住址
heima001	张三		23		 南京
heima002	李四		24		 北京
heima003	王五		25		 广州
heima004	赵六	 	26		 深圳
```

---

## 二、学生类的定义

```java
package com.itheima.studentsystem;

public class Student {
    //id name age address
    private String id;
    private String name;
    private int age;
    private String address;

    public Student() {
    }

    public Student(String id, String name, int age, String address) {
        this.id = id;
        this.name = name;
        this.age = age;
        this.address = address;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
```

----

## 三、测试类的定义

当我们点击IDEA右上角的 `×`，也相当于执行了 `System.exit(0);`，让虚拟机停止运行。

![image-20240410093244747](./assets/image-20240410093244747.png)

如果代码写的太多，可以点击旁边的收起来的按钮。

![image-20240410093517261](./assets/image-20240410093517261.png)

```java
package com.itheima.studentsystem;

import java.util.ArrayList;
import java.util.Scanner;

public class StudentSystem {
    public static void main(String[] args) {
        ArrayList<Student> list = new ArrayList<>();
        // 如果想从 switch 语句中直接结束循环，可以用一个标号在这里，相当于就是给外面的这个循环起个名字，起什么都可以，只要符合标识符的命名规范就行。起"abc"都可以，但是 "abc" 没有什么实际的意义。
        // 我给它起个名字：loop，表示循环的意思
        loop:
        while (true) {
            System.out.println("-----------------欢迎来到黑马学生管理系统-------------------");
            System.out.println("1:添加学生");
            System.out.println("2:删除学生");
            System.out.println("3:修改学生");
            System.out.println("4:查询学生");
            System.out.println("5:退出");
            System.out.println("请输入您的选择：");
            Scanner sc = new Scanner(System.in);
            String choose = sc.next(); // 推荐使用 next()，因为用户可能会输入字符串等，如果输入了字符串，nextInt() 就会报错，但是 next() 不会。等用户录进来后将这种不可取的情况写在 switch 的 default当中，因此这种写法容错率更高一点。
            switch (choose) {
                // 注意 case 后面的字面量需要与上面choose的类型保持一致，上面是字符串，下面也必须要是字符串，否则会报错，因为两个类型不一样肯定匹配不上。
                case "1" -> addStudent(list);
                case "2" -> deleteStudent(list);
                case "3" -> updateStudent(list);
                case "4" -> queryStudent(list);
                case "5" -> {
                    System.out.println("退出");
                    // 跳出外圈循环写法1：
                    //break loop; // 表示我要跳出 loop 这个循环
                    // 跳出外圈循环写法2：
                    System.exit(0);//停止虚拟机运行
                }
                default -> System.out.println("没有这个选项");
            }
        }
    }

    //添加学生
    public static void addStudent() {
        System.out.println("添加学生");
    }

    //删除学生
    public static void deleteStudent() {
        System.out.println("删除学生");
    }

    //修改学生
    public static void updateStudent() {
        System.out.println("修改学生");
    }


    //查询学生
    public static void queryStudent(ArrayList<Student> list) {
        System.out.println("查询学生");
    }
}
```

---

## 四、学习方法

1、我们在写项目的时候，不要靠着脑子想，一定要对照结构图去写。

![image-20240410094225396](./assets/image-20240410094225396.png)

2、写的时候千万不要照着代码看一行写一行，这叫抄作业，没有用。你一定要首先，先去读需求文档，根据需求文档自己画出项目的结构图，根据结构图再去把代码写全，这样才能学到真正的知识。



---

# 117.学生管理系统 —— 查询和添加

~~~java
//添加学生
public static void addStudent(ArrayList<Student> list) {
    //利用空参构造先创建学生对象
    Student s = new Student();

    Scanner sc = new Scanner(System.in);
    String id = null;
    while (true) {
        System.out.println("请输入学生的id");
        id = sc.next();
        boolean flag = contains(list, id);
        if(flag){
            //表示id已经存在，需要重新录入
            System.out.println("id已经存在，请重新录入");
        }else{
            //表示id不存在，表示可以使用
            s.setId(id);
            break;
        }
    }

    System.out.println("请输入学生的姓名");
    String name = sc.next();
    s.setName(name);

    System.out.println("请输入学生的年龄");
    int age = sc.nextInt();
    s.setAge(age);

    System.out.println("请输入学生的家庭住址");
    String address = sc.next();
    s.setAddress(address);


    //把学生对象添加到集合当中
    list.add(s);

    //提示一下用户。由于现在使用的是 ArrayList，ArrayList有个特点，就是它不管添加什么，结果都是添加成功，因此执行到这里的代码一定添加成功。 
    System.out.println("学生信息添加成功");
}

//查询学生
public static void queryStudent(ArrayList<Student> list) {
    if (list.size() == 0) {
        System.out.println("当前无学生信息，请添加后再查询");
        //结束方法
        return;
    }

    //打印表头信息
    System.out.println("id\t\t姓名\t年龄\t家庭住址");
    //当代码执行到这里，表示集合中是有数据的
    for (int i = 0; i < list.size(); i++) {
        Student stu = list.get(i);
        System.out.println(stu.getId() + "\t" + stu.getName() + "\t" + stu.getAge() + "\t" + stu.getAddress());
    }
}


//判断id在集合中是否存在
public static boolean contains(ArrayList<Student> list, String id) {
    //循环遍历集合得到里面的每一个学生对象
    for (int i = 0; i < list.size(); i++) {
        //拿到学生对象后，获取id并进行判断
        Student stu = list.get(i);
        String sid = stu.getId();
        if(sid.equals(id)){
            //存在，true
            return true;
        }
    }
    // 不存在false
    return false;
}
~~~



----

# 118.学生管理系统 —— 删除和修改

~~~java
//删除学生
public static void deleteStudent(ArrayList<Student> list) {
    Scanner sc = new Scanner(System.in);
    System.out.println("请输入要删除的id");
    String id = sc.next();
    //查询id在集合中的索引
    int index = getIndex(list, id);
    //对index进行判断
    //如果-1，就表示不存在，结束方法，回到初始菜单
    if(index >= 0){
        //如果大于等于0的，表示存在，直接删除
        list.remove(index);
        System.out.println("id为：" + id + "的学生删除成功");
    }else{
        System.out.println("id不存在，删除失败");
    }
}

//修改学生
public static void updateStudent(ArrayList<Student> list) {
    Scanner sc = new Scanner(System.in);
    System.out.println("请输入要修改学生的id");
    String id = sc.next();

    // 这里不用contains方法，而是使用 getIndex 方法更好，因为这样不仅可以判断它存不存在，而且还可以返回索引，我们就可以根据这个索引获取到学生对象，然后对它进行修改了。
    int index = getIndex(list, id);

    if(index == -1){
        System.out.println("要修改的id" + id + "不存在，请重新输入");
        return;
    }

    //当代码执行到这里，表示什么？表示当前id是存在的。
    //获取要修改的学生对象
    Student stu = list.get(index);

    //输入其他的信息并修改
    System.out.println("请输入要修改的学生姓名");
    String newName = sc.next();
    stu.setName(newName);

    System.out.println("请输入要修改的学生年龄");
    int newAge = sc.nextInt();
    stu.setAge(newAge);

    System.out.println("请输入要修改的学生家庭住址");
    String newAddress = sc.next();
    stu.setAddress(newAddress);

    System.out.println("学生信息修改成功");
}

//判断id在集合中是否存在
public static boolean contains(ArrayList<Student> list, String id) {
    // 法1：
    //循环遍历集合得到里面的每一个学生对象
    /*for (int i = 0; i < list.size(); i++) {
            //拿到学生对象后，获取id并进行判断
            Student stu = list.get(i);
            String sid = stu.getId();
            if(sid.equals(id)){
                //存在，true
                return true;
            }
        }
        // 不存在false
        return false;*/
    // 法2：重新写一个getIndex方法
    return getIndex
getIndex(list,id) >= 0;
}

//通过id获取索引的方法
public static int getIndex(ArrayList<Student> list, String id){
    //遍历集合
    for (int i = 0; i < list.size(); i++) {
        //得到每一个学生对象
        Student stu = list.get(i);
        //得到每一个学生对象的id
        String sid = stu.getId();
        //拿着集合中的学生id跟要查询的id进行比较
        if(sid.equals(id)){
            //如果一样，那么就返回索引
            return i;
        }
    }
    //当循环结束之后还没有找到，就表示不存在，返回-1.
    return -1;
}
~~~



---

# 119.学生管理系统升级 —— 思路分析

## 一、需求文档

---

**学生管理系统升级版**

**需求**：

​	为学生管理系统书写一个登陆、注册、忘记密码的功能。

​	只有用户登录成功之后，才能进入到学生管理系统中进行增删改查操作。

**分析**：

**登录界面**：

```java
System.out.println("欢迎来到学生管理系统");
System.out.println("请选择操作1登录 2注册 3忘记密码");
```

**用户类**：

​	属性：用户名、密码、身份证号码、手机号码

**注册功能**：

​	1，用户名需要满足以下要求：

​		验证要求：

​			用户名唯一

​			用户名长度必须在3~15位之间 

​			只能是字母加数字的组合，但是不能是纯数字

​	2，密码键盘输入两次，两次一致才可以进行注册。

​	3，身份证号码需要验证。

​		验证要求：

​			长度为18位

​			不能以0为开头

​			前17位，必须都是数字

​			最为一位可以是数字，也可以是大写X或小写x

​	4，手机号验证。

​		验证要求：

​			长度为11位

​			不能以0为开头

​			必须都是数字

**登录功能**：

​	1，键盘录入用户名

​	2，键盘录入密码

​	3，键盘录入验证码

验证要求：

​		用户名如果未注册，直接结束方法，并提示：用户名未注册，请先注册

​		判断验证码是否正确，如不正确，重新输入

​		再判断用户名和密码是否正确，有3次机会

**忘记密码**：

​       1，键盘录入用户名，判断当前用户名是否存在，如不存在，直接结束方法，并提示：未注册

​	2，键盘录入身份证号码和手机号码

​	3，判断当前用户的身份证号码和手机号码是否一致，

​			如果一致，则提示输入密码，进行修改。

​			如果不一致，则提示：账号信息不匹配，修改失败。

**验证码规则**：

​	长度为5

​	由4位大写或者小写字母和1位数字组成，同一个字母可重复

​	数字可以出现在任意位置

比如：

​	aQa1K

----

## 二、画图

### 1）整体代码分析

注册肯定是第一个做的，因为我们只有注册完了才能登录，才能忘记密码。

![image-20240410102804694](./assets/image-20240410102804694.png)

### 2）注册业务分析

![image-20240410102907434](./assets/image-20240410102907434.png)

### 3）登录业务分析

![image-20240410104011727](./assets/image-20240410104011727.png)

### 4）忘记密码业务分析

![image-20240410104041348](./assets/image-20240410104041348.png)



---

# 120.学生管理系统升级

## 一、App.java

IDEA快捷键 <kbd>alt + 回车</kbd>，选择 `create method 'login' in 'App'`，它相当于我们利用IDEA帮我们生成一个方法。

![image-20240410105245701](./assets/image-20240410105245701.png)

~~~java
package com.itheima.studentsystem;

import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

public class App {
    public static void main(String[] args) {
        ArrayList<User> list = new ArrayList<>();
        Scanner sc = new Scanner(System.in);
        while (true) {
            System.out.println("欢迎来到学生管理系统");
            System.out.println("请选择操作：1登录 2注册 3忘记密码");
            String choose = sc.next();
            switch (choose) {
                case "1" -> login(list);
                case "2" -> register(list);
                case "3" -> forgetPassword(list);
                case "4" -> {
                    System.out.println("谢谢使用，再见");
                    System.exit(0);
                }
                default -> System.out.println("没有这个选项");
            }
        }
    }

    private static void login(ArrayList<User> list) {
        Scanner sc = new Scanner(System.in);
        for (int i = 0; i < 3; i++) {
            System.out.println("请输入用户名");
            String username = sc.next();
            //判断用户名是否存在
            boolean flag = contains(list, username);
            if (!flag) {
                System.out.println("用户名" + username + "未注册，请先注册再登录");
                return;
            }

            System.out.println("请输入密码");
            String password = sc.next();


            while (true) {
                String rightCode = getCode();
                System.out.println("当前正确的验证码为：" + rightCode);
                System.out.println("请输入验证码");
                String code = sc.next();
                if (code.equalsIgnoreCase(rightCode)) {
                    System.out.println("验证码正确");
                    break;
                } else {
                    System.out.println("验证码错误");
                    continue;
                }
            }

            //验证用户名和密码是否正确
            //集合中是否包含用户名和密码
            //定义一个方法验证用户名和密码是否正确
            //封装思想的应用：
            //我们可以把一些零散的数据，封装成一个对象
            //以后传递参数的时候，只要传递一个整体就可以了，不需要管这些零散的数据。
            User useInfo = new User(username, password, null, null);
            boolean result = checkUserInfo(list, useInfo);
            if (result) {
                System.out.println("登录成功，可以开始使用学生管理系统了");
                //创建对象调用方法，启动学生管理系统
                StudentSystem ss = new StudentSystem();
                ss.startStudentSystem();
                break;
            } else {
                System.out.println("登录失败，用户名或密码错误");
                if (i == 2) {
                    System.out.println("当前账号" + username + "被锁定，请联系黑马程序员客服：XXX-XXXXX");
                    //当前账号锁定之后，直接结束方法即可
                    return;
                } else {
                    System.out.println("用户名或密码错误，还剩下" + (2 - i) + "次机会");
                }
            }

        }

    }

    private static boolean checkUserInfo(ArrayList<User> list, User useInfo) {
        //遍历集合，判断用户是否存在，如果存在登录成功，如果不存在登录失败
        for (int i = 0; i < list.size(); i++) {
            User user = list.get(i);
            if (user.getUsername().equals(useInfo.getUsername()) && user.getPassword().equals(useInfo.getPassword())) {
                return true;
            } 
        }
        return false;
    }

    private static void forgetPassword(ArrayList<User> list) {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入用户名");
        String username = sc.next();
        boolean flag = contains(list, username);
        if (!flag) {
            System.out.println("当前用户" + username + "未注册，请先注册");
            return;
        }

        //键盘录入身份证号码和手机号码
        System.out.println("请输入身份证号码");
        String personID = sc.next();
        System.out.println("请输入手机号码");
        String phoneNumber = sc.next();


        //需要把用户对象通过索引先获取出来。
        int index = findIndex(list, username);
        User user = list.get(index);
        //比较用户对象中的手机号码和身份证号码是否相同。
        // 使用 equalsIgnoreCase() 的原因是因为身份证号码最后的小写x和大写X是一样的。
        if(!(user.getPersonID().equalsIgnoreCase(personID) && user.getPhoneNumber().equals(phoneNumber))){
            System.out.println("身份证号码或手机号码输入有误，不能修改密码");
            return;
        }

        //当代码执行到这里，表示所有的数据全部验证成功，直接修改即可
        String password;
        while (true) {
            System.out.println("请输入新的密码");
            password = sc.next();
            System.out.println("请再次输入新的密码");
            String againPassword = sc.next();
            if(password.equals(againPassword)){
                System.out.println("两次密码输入一致");
                break;
            }else{
                System.out.println("两次密码输入不一致，请重新输入");
                continue;
            }
        }

        //直接修改即可
        user.setPassword(password);
        System.out.println("密码修改成功");
    }

    private static int findIndex(ArrayList<User> list, String username) {
        for (int i = 0; i < list.size(); i++) {
            User user = list.get(i);
            if(user.getUsername().equals(username)){
                return i;
            }
        }
        return -1;
    }

    private static void register(ArrayList<User> list) {
        //1.键盘录入用户名
        Scanner sc = new Scanner(System.in);
        String username;
        while (true) {
            System.out.println("请输入用户名");
            username = sc.next();
            //在校验的时候会有个规矩，开发细节：先验证格式是否正确，再验证是否唯一
            //         因为在以后所有的数据，都是存在数据库中，如果我们要校验是否唯一，就需要使用到网络资源，有点浪费性能。一般会把浪费性能的放在最后
            boolean flag1 = checkUsername(username);
            if (!flag1) {
                System.out.println("用户名格式不满足条件，需要重新输入");
                continue;
            }

            //校验用户名唯一
            //username到集合中判断是否有存在
            boolean flag2 = contains(list, username);
            if (flag2) {
                //用户名已存在，那么当前用户名无法注册，需要重新输入
                System.out.println("用户名" + username + "已存在，请重新输入");
            } else {
                //不存在，表示当前用户名可用，可以继续录入下面的其他数据
                System.out.println("用户名" + username + "可用");
                break;
            }
        }
        //2.键盘录入密码
        //密码键盘输入两次，两次一致才可以进行注册。
        String password;
        while (true) {
            System.out.println("请输入要注册的密码");
            password = sc.next();
            System.out.println("请再次输入要注册的密码");
            String againPassword = sc.next();
            if (!password.equals(againPassword)) {
                System.out.println("两次密码输入不一致，请重新输入");
                continue;
            } else {
                System.out.println("两次密码一致，继续录入其他数据");
                break;
            }
        }
        //3.键盘录入身份证号码
        String personID;
        while (true) {
            System.out.println("请输入身份证号码");
            personID = sc.next();
            boolean flag = checkPersonID(personID);
            if (flag) {
                System.out.println("身份证号码满足要求");
                break;
            } else {
                System.out.println("身份证号码格式有误，请重新输入");
                continue;
            }
        }
        //4.键盘录入手机号码
        String phoneNumber;
        while (true) {
            System.out.println("请输入手机号码");
            phoneNumber = sc.next();
            boolean flag = checkPhoneNumber(phoneNumber);
            if (flag) {
                System.out.println("手机号码格式正确");
                break;
            } else {
                System.out.println("手机号码格式有误，请重新输入");
                continue;
            }
        }
        //用户名，密码，身份证号码，手机号码放到用户对象中
        User u = new User(username, password, personID, phoneNumber);
        //把用户对象添加到集合中
        list.add(u);
        System.out.println("注册成功");

        //遍历集合
        printList(list);
    }

    private static void printList(ArrayList<User> list) {
        for (int i = 0; i < list.size(); i++) {
            //i 索引
            User user = list.get(i);
            System.out.println(user.getUsername() + ", " + user.getPassword() + ", "
                    + user.getPersonID() + ", " + user.getPhoneNumber());
        }
    }

    private static boolean checkPhoneNumber(String phoneNumber) {
        //长度为11位
        if (phoneNumber.length() != 11) {
            return false;
        }
        //不能以0为开头
        if (phoneNumber.startsWith("0")) {
            return false;
        }
        //必须都是数字
        for (int i = 0; i < phoneNumber.length(); i++) {
            char c = phoneNumber.charAt(i);
            if (!(c >= '0' && c <= '9')) {
                return false;
            }
        }
        //当循环结束之后，表示每一个字符都在0-9之间
        return true;
    }

    private static boolean checkPersonID(String personID) {
        //长度为18位
        if (personID.length() != 18) {
            return false;
        }
        //不能以0为开头
        // 可以使用 personId.charAt(0) 或者 personId.startsWith（可以检测字符串是不是以0开头，如果是，返回true；如果不是，返回false。
        if (personID.startsWith("0")) {
            //如果以0开头，那么返回false
            return false;
        }
        //前17位，必须都是数字
        for (int i = 0; i < personID.length() - 1; i++) {
            char c = personID.charAt(i);
            //如果有一个字符不在0-9之间，那么直接返回false
            if (!(c >= '0' && c <= '9')) {
                return false;
            }
        }
        //最为一位可以是数字，也可以是大写X或小写x
        char endChar = personID.charAt(personID.length() - 1);
        if ((endChar >= '0' && endChar <= '9') || (endChar == 'x') || (endChar == 'X')) {
            return true;
        } else {
            return false;
        }
    }

    private static boolean contains(ArrayList<User> list, String username) {
        //循环遍历集合得到每一个用户对象
        //拿着用户对象中的用户名进行比较
        for (int i = 0; i < list.size(); i++) {
            //i 索引
            User user = list.get(i);
            String rightUsername = user.getUsername();
            if (rightUsername.equals(username)) {
                return true;
            }
        }
        //当循环结束了，表示集合里面所有的用户都比较完毕了，还没有一样的，则返回false
        return false;
    }

    private static boolean checkUsername(String username) {
        //用户名长度必须在3~15位之间
        int len = username.length();
        if (len < 3 || len > 15) {
            return false;
        }
        //当代码执行到这里，表示用户名的长度是符合要求的。
        //继续校验：只能是字母加数字的组合
        //循环得到username里面的每一个字符，如果有一个字符不是字母或者数字，那么就返回false
        for (int i = 0; i < username.length(); i++) {
            //i 索引
            char c = username.charAt(i);
            if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'))) {
                return false;
            }
        }
        //当代码执行到这里,表示什么？
        //用户名满足两个要求：1长度满足 2内容也满足（字母+数字）
        //但是不能是纯数字
        //统计在用户名中，有多少字母就可以了。
        int count = 0;
        for (int i = 0; i < username.length(); i++) {
            //i 索引
            char c = username.charAt(i);
            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
                count++;
                break; // 当有一个满足就可以break，这样可以减少循环次数，提高代码效率
            }
        }
        return count > 0;
    }

    private static String getCode() {
        //1.创建一个集合添加所有的大写和小写字母
        ArrayList<Character> list = new ArrayList<>();
        for (int i = 0; i < 26; i++) {
            list.add((char) ('a' + i));
            list.add((char) ('A' + i));
        }

        StringBuilder sb = new StringBuilder();
        //2.要随机抽取4个字符
        Random r = new Random();
        for (int i = 0; i < 4; i++) {
            //获取随机索引
            int index = r.nextInt(list.size());
            //利用随机索引获取字符
            char c = list.get(index);
            //把随机字符添加到sb当中
            sb.append(c);
        }

        //3.把一个随机数字添加到末尾
        int number = r.nextInt(10);
        sb.append(number);

        //4.如果我们要修改字符串中的内容
        //先把字符串变成字符数组，在数组中修改，然后再创建一个新的字符串
        char[] arr = sb.toString().toCharArray();
        //拿着最后一个索引，跟随机索引进行交换
        int randomIndex = r.nextInt(arr.length);
        //最大索引指向的元素 跟随机索引指向的元素交换
        char temp = arr[randomIndex];
        arr[randomIndex] = arr[arr.length - 1];
        arr[arr.length - 1] = temp;
        return new String(arr);
    }
}
~~~

----

## 二、User.java

~~~java
package com.itheima.studentsystem;

public class User {
    private String username;
    private String password;
    private String personID;
    private String phoneNumber;


    public User() {
    }

    public User(String username, String password, String personID, String phoneNumber) {
        this.username = username;
        this.password = password;
        this.personID = personID;
        this.phoneNumber = phoneNumber;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getPersonID() {
        return personID;
    }

    public void setPersonID(String personID) {
        this.personID = personID;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }

    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }
}
~~~

---

## 四、StudentSystem.java

```java
public class StudentSystem {
    public static void startStudentSystem() {
    }
}
```

----

## 三、总结

### 1）开发细节

在校验的时候会有个规矩，开发细节：先验证格式是否正确，再验证是否唯一。因为在以后所有的数据，都是存在数据库中，如果我们要校验是否唯一，就需要使用到网络资源，有点浪费性能。一般会把浪费性能的放在最后。

### 2）抽取变量

例如，代码中如果要多次用到 `username.length()`，就可以将  `username.length()` 单独抽成一个变量 `len`。

多次调用 `length()` 方法会降低效率。



----

# ----------------------------------

# Day 13  面向对象进阶

# 121.static —— 静态变量

## 一、引入

static翻译过来就是静态的意思。

首先来看一个需求：写一个JavaBean类来描述这个班级的学生。

属性：姓名、年龄、性别

行为：学习

> 从今天起我们涉及到的类就有很多个了，因此从现在开始每一个练习创建的不是一个类，而是一个包。而在IDEA中，包名是按照字母从小到大进行排序的，因此为了让大家在课后复习的时候更方便，就在前面加了一个 `a01` ，就表示是序号的意思，表示第一题，`a02` 表示第2题。但由于起名字不能以数字开头，因此在数字前面都加了一个 `a`。
>
> ![image-20240410150004348](./assets/image-20240410150004348.png)

Student.java

~~~java
package com.itheima.a01staticdemo1;

public class Student {
    //属性：姓名 年龄 性别
    //新增：老师的姓名
    private String name;
    private int age;
    private String gender;
    public String teacherName;

    public Student() {
    }

    public Student(String name, int age, String gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    //行为
    public void study() {
        System.out.println(name + "正在学习");
    }

    public void show() {
        System.out.println(name + ", " + age + ", " + gender + ", " + teacherName);
    }
}
~~~

StudentTest.java

~~~java
package com.itheima.a01staticdemo1;

import java.util.Random;

public class StudentTest {
    public static void main(String[] args) {
        //1.创建第一个学生对象
        Student s1 = new Student();
        s1.setName("张三");
        s1.setAge(23);
        s1.setGender("男");
        s1.teacherName = "阿玮老师";

        s1.study();
        s1.show();

        //2.创建第二个学生对象
        Student s2 = new Student();
        s2.setName("李四");
        s2.setAge(24);
        s2.setGender("女");
        s2.teacherName = "阿玮老师";

        s2.study();
        s2.show();
    }
}
~~~

由于一个班只有一个老师，`teacherName` 应该是共享的。既然是共享的，那每一次都需要用对象去调用 `teacherName` 去赋值，太麻烦了。能不能只赋值一次，就让这个类所有对象都共享一个值。这必定是可以的。

解决办法：在 `teacherName` 前面加一个修饰符 ——  `static`，一旦加上之后，`Strudent` 这个类所有的对象都共享同一个老师的姓名了。

~~~java
public String teacherName;
~~~

此时当第一个学生对 `teacherName` 赋值的时候，所有的对象再去获取 `teacherName` 的时候就已经有值了。

~~~java
s1.teacherName = "阿玮老师";
~~~

并且一旦用 `static` 修饰后，它还多了一种调用方式：直接用类名去调用。

~~~java
Student.teacherName = "阿玮老师";
~~~

----

## 二、概念

static：static表示静态，是Java中的一个修饰符，可以修饰成员方法、成员变量。

因此我们需要将 `static` 修饰成员方法、 `static` 修饰成员变量分开去学习。

---

## 三、`static` 修饰成员变量

成员变量一旦被 `static` 修饰之后，这个成员变量就叫做 `静态变量`。

`静态变量` 的特点：

- 被这个类所有对象共享

- 不属于对象，属于类

- 随着类的加载而加载，优先于对象存在

  而对象一定要等 `new` 关键字执行了，它才在内存中出现

调用方式：

- 类名调用（推荐）
- 对象名调用

至于推荐类名调用的原因：既然所有的对象都共享这个属性，这个属性就不属于某个特定的类，因此用一个特定的对象去调用它，在语法中是可以的，但是不合理，因此我们需要用 `类名调用`。

----

## 四、`static` 内存图

为了内存图尽可能让大家理解，所以下面代码的成员变量前面都没有加 `private`。

程序刚开始启动，肯定是main方法先进栈。

然后执行main方法中的第一行代码中：`Student.teacherName = "阿玮老师"`，在这行代码中，使用类名调用了 `Student` 类中的静态变量 `teacherName`，并赋值为 `"阿玮老师"`。此时就用到了 `Student` 类。因此在内存中，就会将 `Student` 类的字节码文件，加载到方法区，并在内存中创建了一个 **单独存放** 静态变量的空间，我们可以把这个空间叫做 `静态区`。

因此当 `Student` 的字节码文件加载到方法区后，`静态区` 就出现了。

在JDK8以前，静态区是在方法区里面的。JDK8以后，就挪到了堆空间当中。

在静态区中就存着这个内所有的静态变量，例如 `teacherName`。由于 `teacherName` 为引用数据类型，因此默认初始化值为 `null`。

要注意的是，现在内存中并没有对象，因为我们代码还没有执行到 `new` 关键字，只有 `new` 关键字执行了，在内存当中才有对象！

由此可见：静态变量是随着类的加载而加载的，优先于对象出现的。

在以后我们还会用 `static` 去修饰其他的内容，其他的内容也会去遵守这个规则，只要使用 `static` 修饰的，都是随着类的加载而加载，加载的时候是优先于对象出现的。

![image-20240410160029254](./assets/image-20240410160029254.png)

此时第一行还没完，等号的右边还需要赋值，因此它会将 `静态区` 中的 `teacherNamer` 赋值为 `"阿玮老师"`，原来的 `null` 就会被覆盖。

![image-20240410160625737](./assets/image-20240410160625737.png)

接下来再来看第二行代码：`Student s1 = new Student();`，这个时候就出现 `new` 关键字了，此时对象在内存当中才会出现。

等号的左边相当于在栈的main方法中定义了一个变量 `s1`，等号的右边有 `new` 关键字了，所以就在堆内存中开辟了一个空间。

假设这个空间的地址值是 `0x0011` ，这个空间也是我们平时所说的对象。

在这个空间里面存储的是所有的非静态的变量：`name`、`age`，并进行默认初始化 `null`、`0`。

再将这个小空间的地址赋值给 `s1`，因此 `s1` 记录的地址就是 `0x0011`。

![image-20240410161326967](./assets/image-20240410161326967.png)

现在如果我想通过 `s1` 去访问静态变量 `teacherName`，此时就回去静态区中去找对应的变量。

`s1.name = "张三"`，这里的 `s1` 记录的是 `0x0011`，这行代码就相当于将 `"张三"` 赋值给 `0x0011` 的 `name`。右上角的 `null` 就会被 `"张三"` 给覆盖。

再往下，`s1.age = 23` ，`s1` 记录的是 `0x0011`，因此这行我们就可以这么理解：把 `23` 赋值给 `0x0011` 的 `age`。右上角的 `0` 就会被 `23` 给覆盖。

![image-20240410161815444](./assets/image-20240410161815444.png)

再往下：`s1.show()`，用 `s1` 去调用 `show()` 方法。`show()` 方法就会被加载进栈，因为此时 `show()` 方法的调用者是 `s1`，就会通过 `s1` 去找里面的 `name`、`age`，然后再去找到静态区里面的 `teacherName`。

因此在控制台中打印的就是 `张三...23...阿玮老师`。

![image-20240410162603733](./assets/image-20240410162603733.png)

此时方法执行完毕，`show()` 方法出栈。

然后执行：`Student s2 = new Student();`，创建了第二个对象 `s2`，等号的右边还是有 `new` 关键字，因此在堆中又开辟了一个新的小空间，假设地址为 `0x0022`。在这个小空间里面，它就会存储所有非静态的成员变量 `name`、`age`，并默认初始化为 `null` 、`0`。

如果我想通过 `s2` 去获取静态变量，它也可以到下面静态区找到 `teacherName`。

最后再将 `0x0011` 的地址赋值给左边的变量 `s2`。

![image-20240410164456555](./assets/image-20240410164456555.png)

继续，`s2.show()`，通过 `s2` 再去调用 `show()` 方法，此时 `show()` 方法就会被加载进栈。

又因为此时 `show()` 方法的调用者是 `s2`，就会通过 `s2` 去找里面的 `name`、`age`，然后再去找到静态区里面的 `teacherName`。

因此在控制台中打印的就是 `null...0...阿玮老师`。

![image-20240410164918482](./assets/image-20240410164918482.png)

然后 `show()` 方法执行完毕，出栈。

通过上面的内存图接，我们可以看到里面的核心点。静态区里面的变量，是对象共享的，在内存中只有一份，谁要用谁去拿。

而非静态的东西，例如 `name`、`age`，都是每个对象独有的，每个对象都会单独存放一份，这就是它们的区别。

----

## 五、练习：请说出以下属性是否可以被定义为静态

在以后当中，以后有哪些属性可以用 `static` 来修饰呢？

其实很简单，我们只需要抓住两个字：**共享**。只要是所有对象都共享的，就必须要用 `static` 去修饰。

案例：在 `Student` 中有以下五个属性。有哪些属性可以被 `static` 修饰呢？

![image-20240410165646113](./assets/image-20240410165646113.png)

是否能被 `static` 修饰，就看两个字：**共享**。但是这个共享不是绝对的，我们要看具体的业务场景。

**1、name**

如果说 `name` 用 `static` 去修饰了，就表示说有的学生都共享同一个姓名，这种情况可能性非常少，因此这个 `name` 我们不会用 `static` 去修饰。

**2、age**

如果说 `age` 用 `static` 去修饰了，就表示说有的学生都共享同一个年龄，但每个学生的年龄也是不一样的，因此 `age` 也不会用 `static` 去修饰。

**3、teacherName**

如果现在这个 `Student` 表示一个班的学生，一个班的学生老师肯定是共享的，因此在这种情况下，`teacherName` 就必须用 `static` 去修饰。

但是还有种情况，就是你放学之后，你自己给自己请的私人家教，它就不是共享的了，因此在这种情况下，老师的姓名就不能加 `static` 修饰了。

因此在不同情况下是否用 `static` 修饰，你要自己想，抓住一个核心点：**共享**。



----

# 122.static —— 静态方法和工具类

## 一、引入

上一节中，我们已经学习完了静态变量，今天来学习一下静态方法。

被 `static` 修饰的成员方法就叫做静态方法。

因此我们以前写在测试类中的都是静态方法，写在JavaBean中的 get、set 都是普通的成员方法。

特点：

- 多用在测试类和工具类中

- JavaBean类中很少会用

  在JavaBean中就算用到了，也会涉及到后面的知识点，例如：设计模式。

调用方式：

- 如果是调用本类的，直接调用就行
- 如果是调用其他类的，可以用类名调用（推荐）
- 也可以使用其他类的对象去进行调用

当然我们还是推荐用类名去进行调用。

---

## 二、工具类

工具类：帮助我们做一些事情的，但是不描述任何事物的类。

我们可以将工具类跟其他的类进行对比学习，到目前为止我们已经学习完了三种类了：JavaBean类、测试类、工具类。

**JavaBean类：用来描述一类事物的类。比如：Student（用来描述学生）、Teacher（用来描述老师）、Dog（用来描述狗）、Cat（用来描述猫等。**

我们在书写JavaBean类的时候，要私有化成员变量、书写空参构造方法、书写带全部参数的构造方法，需要针对每个私有化的成员变量提供对应的 get 和 set 方法，如果还有额外的行为，例如：`sleep()`、`study()`等，还需要写额外的成员方法。

**测试类：用来检查其他类是否书写正确，带有main方法的类，是程序的入口。**

在以前我们是在测试类中创建JavaBean类的对象，并进行赋值调用的。

**工具类：不是用来描述一类事物的，而是帮我们做一些事情的类。**

在书写工具类的时候，我们需要遵守以下规则：

1、类名要见名知意。

例如要写一个类专门用来进行数学计算，类名就要写成 `Math`。

如果要写一个类专门用来操作数组，类名就可以写成 `ArrUil`，表示数组工具的意思

2、私有化构造方法

构造方法一旦私有了，那么在外界就不能创建这个类的对象了。这是因为工具类不是用来描述一类事务的，创建它的对象没有任何的意义。

例如现在是一个JavaBean类：`Student`，这个类是用来描述学生的，创建它的对象是有意义的：创建一个 `Student` 对象，就表示一个学生；创建两个 `Student` 对象，就表示两个学生.....

<img src="./assets/image-20240410173429988.png" alt="image-20240410173429988" style="zoom:67%;" />

但，例如我现在创建 `ArrUtil` 对象，这个对象什么都表示不了，因此我们私有化构造方法，不让外界创建它，因为创建它的对象，这个对象没有什么实际的意义。

3、方法都定义为静态方法

例如我们定义一个求数组最大值、最小值、和、平均值

![image-20240410174003318](./assets/image-20240410174003318.png)

----

## 三、练习：定义数组工具类

需求:在实际开发中，经常会遇到一些数组使用的工具类。

请按照如下要求编写一个数组的工具类:ArrayUtil

- 提供一个工具类方法printArr，用于返回整数数组的内容。

  返回的字符串格式如:`[10, 20, 50, 34, 100]`(只考虑整数数组，且只考虑一维数组)提供这样一个工具方法getAerage，用于返回平均分。(只考虑浮点型数组，且只考虑一维数组)

- 定义一个测试类TestDemo，调用该工具类的工具方法，并返回结果。

ArrayUtil.test

~~~java
package com.itheima.a02staticdemo2;

public class ArrayUtil {

    //私有化构造方法
    //目的：为了不让外界创建他的对象
    private ArrayUtil() {
    }


    //需要定义为静态的，方便调用
    public static String printArr(int[] arr) {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        for (int i = 0; i < arr.length; i++) {
            //i 索引 arr[i] 元素
            if (i == arr.length - 1) {
                sb.append(arr[i]);
            } else {
                sb.append(arr[i]).append(", ");
            }
        }
        sb.append("]");
        return sb.toString();
    }


    public static double getAverage(double[] arr) {
        double sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum = sum + arr[i];
        }
        return sum / arr.length;
    }
}
~~~

TestDemo.java

~~~java
package com.itheima.a02staticdemo2;

public class TestDemo {
    public static void main(String[] args) {
        //测试工具类中的两个方法是否正确

        int[] arr1 = {1, 2, 3, 4, 5};
        String str = ArrayUtil.printArr(arr1);
        System.out.println(str); //[1, 2, 3, 4, 5]

        double[] arr2 = {1.5, 3.7, 4.9, 5.8, 6.6};
        double avg = ArrayUtil.getAverage(arr2);
        System.out.println(avg); // 4.5
    }
}
~~~

----

## 四、练习：定义学生工具类

需求：定义一个集合，用于存储3个学生对象。

学生类的属性为：name、age、gender

定义一个工具类，用于获取集合中最大学生的年龄。

Student.java

~~~java
package com.itheima.a03staticdemo3;

public class Student {
    private String name;
    private int age;
    private String gender;

    // 空参、全称、get、set
}
~~~

Test.java

在导入 `Student` 的包的时候，会出现两个选择，这是因为我们在不同包下都创建了 `Student` 类。

而我们要导入的一个是我们现在所在的包 `a03staticdemo3` 下的 `Student`。

![image-20240410175353265](./assets/image-20240410175353265.png)

~~~java
package com.itheima.a03staticdemo3;

import java.util.ArrayList;

public class Test {
    public static void main(String[] args) {
        //1.创建一个集合用来存储学生对象
        ArrayList<Student> list = new ArrayList<>();

        //2.创建3个学生对象
        Student stu1 = new Student("zhangsan",23,"男");
        Student stu2 = new Student("lisi",24,"女");
        Student stu3 = new Student("wangwu",25,"男");


        //3把学生对象添加到集合当中
        list.add(stu1);
        list.add(stu2);
        list.add(stu3);

        //4.调用工具类中的方法
        int maxAgeStudent = StudentUtil.getMaxAgeStudent(list);

        System.out.println(maxAgeStudent);
    }
}
~~~

StudentUtil.java

~~~java
package com.itheima.a03staticdemo3;

import java.util.ArrayList;

public class StudentUtil {

    private StudentUtil(){}

    //静态方法
    public static int getMaxAgeStudent(ArrayList<Student> list){
        //1.定义一个参照物
        int max = list.get(0).getAge();

        //2.循环遍历集合，循环从1开始，提高效率
        for (int i = 1; i < list.size(); i++) {
            //i ——> 索引  list.get(i) ——> 元素/学生对象  我们还需要getAge获取到年龄之后再进行比较
            int tempAge = list.get(i).getAge(); // 一个方法的返回值如果需要反复去用，最好定义成一个变量去接收，提高代码效率。
            if(tempAge > max){
                max = tempAge;
            }
        }

        //3.直接返回max
        return max;
    }
}
~~~



----

# 123.static的注意事项

## 一、static的注意事项

- 静态方法只能访问静态变量和静态方法
- 非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法
- 静态方法中是没有this关键字的

总结：

- 静态方法中没有this关键字
- 静态方法中，只能访问静态。
- 非静态方法可以访问所有。

----

## 二、代码角度解释

### 1）代码

为了让大家更简单理解，下面用的就是最简单的JavaBean

Student.java

~~~java
public class Student {
    String name;
    int age;
    static String teacherName;
    
    public void show1() {
        System.out.println(name + "," + age + "," + teacherName);
    }
    
    public static void method() {
        System.out.println("静态方法");
    }
}
~~~

StudentTest.java

~~~java
public class StudentTest {
    public static void main(String[] args) {
        Student.teacherName = "阿玮老师"; // 对共享变量 teacherName 进行了赋值
        
        Student s1 = new Student();
        s1.name = "zhangsan";
        s1.age = 23;
        s1.show1();
        
        System.out.println("==============");
        
        Student s2 = new Student();
        s2.name = "lisi";
        s2.age = 24;
        s2.show1();
    }
}
~~~

首先将 `Student` 和 `StudentTest` 类都点开。

我们在观看的时候可以这样：右键点击上面测试类的选项卡，选择这里的 `Split and Move Right`（切割 and 移动到右边）。

![image-20240411084232455](./assets/image-20240411084232455.png)

这样可以一左一右对比着看，相对来讲比较方便。

![image-20240411084417215](./assets/image-20240411084417215.png)

---

### 2）`静态方法中没有this关键字` 的解释

#### 1、非静态方法中的 `this`  调用成员变量

看到这句话能不能反过来理解：普通的非静态方法中有一个隐藏的 `this`。

确实是这样的，那么它在哪呢？

在我们非静态方法的形参中，它有一个隐藏的 `this`（`Student this`）。

要注意的是，这个 `this` 并不是我们调用方法手动赋值的，我们不能手动去给这个`this`赋值。这个`this`是在调用方法的时候，`虚拟机`给这个方法赋值的 —— 谁调用当前的方法，this 就表示谁的地址值。

~~~ java
// this：表示当前方法调用者的地址值。
// 这个this：可以把它理解成是一个变量，类型是当前这个类的类型。由于现在是 Student 类，所以现在这个 this 就是 Student 类型的。这个变量记录的就是调用者的地址值。
public void show1(Student this) {
    System.out.println(name + "," + age + "," + teacherName);
}
~~~

虚拟机是怎么给它赋值的？

在右边的测试类当中，对 `show1()` 方法调用了两次。

![image-20240411085357119](./assets/image-20240411085357119.png)

在第一次调用的时候，虚拟机它就会把它的调用者 `s1` 赋值给这里的 `this`；

第二次调用的时候，虚拟机它就会把它的第二个调用者 `s1` 赋值给这里的 `this`；

![image-20240411085702232](./assets/image-20240411085702232.png)

我们可以写代码去验证一下，在右边的测试类中创建完 `s1`、`s2` 后分别打印出它们的地址。

在左边的 `show1` 方法中打印 `this` 的地址。要注意的是，第一次是 `s1` 调用的，第一次打印的应该就是 `s1` 的地址；第二次是 `s2` 调用的，第二次打印的应该就是 `s2` 的地址。

![image-20240411085833482](./assets/image-20240411085833482.png)

右键运行看下效果，程序运行完后，可以看见两个地址都是一样的。

![image-20240411090145852](./assets/image-20240411090145852.png)

正是因为 `this` 有了这样的特性，所以在这个方法里面，调用成员变量的时候，就可以区分不同的对象了。

又因为我们在调用成员变量的时候，其实每个成员变量前面都有一个隐含的 `this`。

~~~java
public void show1(Student this) {
    System.out.println(this.name + "," + this.age + "," + teacherName);
}
~~~

这样当你的 `s1` 调用 `show1()` 的时候，此时在 `show1()` 方法中打印的就是 `s1` 的 `name` 和 `s1` 的 `age`。

第二次，通过`s2` 调用 `show1()` 的时候，此时在 `show1()` 方法中打印的就是 `s2` 的 `name` 和 `s2` 的 `age`。

只不过我们平时在局部位置，也就是在方法里面没有跟成员位置重名，因此这里的 `this.` 其实是可以省略不写的，但是我们在这里写上也没有问题。

----

#### 2、非静态方法中的 `this`  调用其他方法

在 `show1()` 方法中再写一个 `show2()` 方法。

~~~java
public void show2() {
    System.out.println("show2");
}
~~~

此时我们要注意一点，在 `show1` 中调用其他方法，在之前我们直接写方法名就可以了

![image-20240411091326113](./assets/image-20240411091326113.png)

但是前面它其实也有一个隐含的 `this.`，这个 `this` 就是拿着当前调用 `show1` 的那个对象，再来调用 `show2`。

~~~java
public void show1(Student this) {
    // 调用其他方法
    this.show2();
}
~~~



**解释**

第一次的时候，是 `s1` 去调用的 `show1`，所以说这里的 `this` 就被赋值成了 `s1` 的地址。这个时候再来看`13行`代码，既然 `this` 是 `s1`，那么`13行`这句话我能不能理解成：使用 `s1` 再去调用 `show2`，是可以的。

![image-20240411092421605](./assets/image-20240411092421605.png)

第二次，它是拿 `s2` 去调用的 `show1`，因此这个 `this` 就表示的是 `s2`。下面的 `this.show2()` 方法就是表示拿着 `s2` 再去调用的 `show2()`。

所以我们知道了，在这种普通的成员方法里面，它是含有一个隐含的 `this` 的。这个 `this` 在形参的最前面，这个东西我们不能自己赋值，如果我们强行给它赋值就会报错。

![image-20240411092710907](./assets/image-20240411092710907.png)

它的赋值是方法在调用的时候，由虚拟机把调用者的地址值去赋值给它的。

----

#### 3、静态方法中没有 `this` 关键字

在静态方法中的形参位置如果加上 `this`，就会报错，翻译过来就是：`'com.itheima.a03staticdemo4.Student.this' 不能从静态上下文中引用`。因此在静态方法中，是没有 `this` 关键字的。

![image-20240411092949503](./assets/image-20240411092949503.png)

----

#### 4、Java这样设计的原因

因为像这种非静态的东西，它往往是跟对象相关的，例如 `show1()` 方法里面的方法体，它打印出来的就是某个对象的 `name`、某个对象的 `age`，因此在这个里面它必须要有 `this`。

![image-20240411093351478](./assets/image-20240411093351478.png)

那静态的东西呢？静态的东西一般都是共享的，共享的它跟某一个对象是没有什么太大关系的，既然你跟某一个对象没有什么关系，因此Java在设计的时候，在静态方法里面就没有 `this` 关键字。

有了这样一个结论之后，后面的两句话就很好理解了。

<img src="./assets/image-20240411093712975.png" alt="image-20240411093712975" style="zoom:67%;" />

----

### 3）静态方法中，只能访问静态

这句话我们返回来理解就是：静态方法中不能访问非静态的东西。非静态的东西有两个：`成员变量` 和 `成员方法`。

我们现在就在静态方法中强行调用一下 `成员变量` 和 `成员方法`。

此时它就报错了，翻译过来就是：`不能从静态上下文引用非静态字段 "name"`

![image-20240411093958255](./assets/image-20240411093958255.png)

报错的原因其实很简单，你在这打印 `name`，你是打印哪个对象的 `name`？如果需要表示是哪个对象的 `name` ，前面就需要有一个 `this.`，但是我们刚刚才说过，静态方法里面没有 `this`。因此静态方法不能调用非静态的成员变量。

----

同样，我们在静态方法中调用非静态成员方法 `show1()` 也是会报错的。

翻译过来就是：`不能从静态上下文中引用非静态方法 "show1()"`

![image-20240411094727360](./assets/image-20240411094727360.png)

报错的原因其实也很简单，如果说我们想要调用其他的非静态的成员方法，在前面也有一个隐含的 `this.`，又因为静态方法中压根就没有 `this`，所以它也调不了。

---

### 4）非静态方法可以访问所有

这句话也很好理解，它在调用 `static` 修饰的成员变量 `teacherName` 的时候，也相当于它的前面有一个 `this.`。

而静态有两种调用方式：`1、类名调用（推荐）；2、对象名调用`

第二种使用对象名调用，也是可以访问到共享的数据的。因此这么去调用一点问题也没有。

![image-20240411095515967](./assets/image-20240411095515967.png)

同样的在非静态方法 `show1()` 中调用非静态的 `method` 方法，也是必须可以的。

调用其他的方法，前面也有一个隐含的 `this.`，静态的成员方法是可以使用对象名调用的。

因此这种写法也是ok的。

![image-20240411095912445](./assets/image-20240411095912445.png)

----

搞懂了从代码方面解释这三句话，那么从语法的角度也就很好理解这三句话了。

1、静态方法中没有 `this` 关键字

2、静态方法中，只能访问静态内容

3、非静态方法中，可以访问所有

----

## 三、内存角度解释：静态方法中，只能访问静态内容

### 1）前置认知

在讲解内存之前，需要大家现有一个认知，这块内存就好比是我们程序运行的内存，静态的数据跟非静态的数据加载到内存中的时机是不一样的。

静态：随着类的加载而加载。

非静态：跟对象有关系的。

例如我们刚刚写的 `Student` 里面的 `name`，你要想那个 `name` 什么时候有值，是不是我们在创建学生对象的时候它才有值。那如果我们没有创建对象，在内存当中就不会有那个 `name`。

![image-20240411101454050](./assets/image-20240411101454050.png)

所以说当静态加载到内存之后，如果说我们没有创建对象，这个时候内存中它是没有非静态的数据的。而静态的东西它是可以互相调用的，这个是没有问题的。

![image-20240411101645321](./assets/image-20240411101645321.png)

但是非静态的东西是跟对象有关的，只要没创建对象，非静态的数据就不会出现在内存当中。因此静态是无法调用非静态的。

有了这个认知后，我们就从内存的角度去解释这个概念。

----

### 2）从内存角度解释

#### 1、静态方法不能调用实例变量

也就是说，在静态方法中，它只能调用其他的静态方法和静态变量，是不能调用 `非静态的方法` 和 `非静态的成员变量` 的。即静态方法不能访问非静态。

来看下面这段代码，首先在 `Student` 类中有一个成员方法 `name`，和一个静态变量 `teacherName`。

再往下有一个静态方法 `method`，静态方法中调用了 `name`、`teacherName`。当然我们知道这种方式的调用是错的，所以 `name` 用红色标记了，因为在 IDEA 中，红色就表示 错误 的意思。

下面还有一个非静态的 `show() 方法`，里面同样的调用了 `name` 、`teacherName`。

在下面的测试类中，我们首先先用类名调用 `teacherName` ，对静态变量做了一个赋值。然后再调用静态方法 `mathod()`。

接下来就来看一下右边的内存。

![image-20240411102558159](./assets/image-20240411102558159.png)

在刚开始的时候，main方法首先肯定还是要进栈，这个是死套路。然后执行main方法中的第一行代码：`Student.teacherName = "阿玮老师"`

这行代码就用到了 `Student`，用到了 `Student` 类，就会把 `Student` 的字节码文件加载到方法区，在这个里面会有所有的`成员变量`和`成员方法`。

并在内存中创建了一个 **单独存放** 静态变量的空间，我们可以把这个空间叫做 `静态区`。

因此当 `Student` 的字节码文件加载到方法区后，`静态区` 就出现了。

在JDK8以前，静态区是在方法区里面的。JDK8以后，就挪到了堆空间当中。

![image-20240411104144025](./assets/image-20240411104144025.png)

现在在静态区中有一个静态的 `teacherName`，因此它就会出现在静态区当中。由于 `teacherName` 是 `String`，属于引用数据类型，它默认初始化值就是 `null`。

![image-20240411104237373](./assets/image-20240411104237373.png)

然后又因为，在第一行代码中，给 `teacherName` 做了一个赋值，此时 `null` 就会被 `'阿玮老师'` 这个字符串所替代。

![image-20240411104301809](./assets/image-20240411104301809.png)

这个就是第一行代码。第二行代码 `Student.method()` 是调用了静态方法 `method()`，`Student.method` 就会找到方法区中的 `Student`  字节码文件，然后找到里面的 `method` ，然后把 `method` 加载到栈中，在方法里面它要获取两个变量：`1、name；2、teacherName`。

但由于当前的方法，是用 `Student` 这个类名去调用的，它就会到右边的 `Student` 类的静态区中找 `name`、`teacherName`。首先 `teacherName` 是可以找到的没有问题，但是 `name` 是找不到的，因为 `name` 不是静态的，既然不是静态的，就不会出现在静态区中。

通过这个我们就可以得出一个结论：静态方法不能调用非静态成员变量。

这种 `非静态的成员变量` 我们也称作 `实例变量`，这里的`实例`就是`对象`的意思。通过 `实例变量` 这个名字我们也能发现，这个变量是跟 `对象` 有关的，而现在在我们的代码中并没有对象，对象都没有，那怎么调用对象里面的示例变量呢？

![image-20240411104947917](./assets/image-20240411104947917.png)

----

### 2、静态方法不能调用非静态的成员方法

例如，在左边的 `method` 方法中，我添加了一段 `show()` 方法，`show()` 方法是非静态的，所以这是一种错误的调用方式，这里也把它加上了红色标记，IDEA中红色就是错误的意思。

![image-20240411105705638](./assets/image-20240411105705638.png)

那为什么不能调用呢？其实我们可以把它反过来理解，**假设它可以调用**。

要注意的是，在刚刚我们说过，像这种`普通的成员方法`在调用的时候，它必须要有一个`调用者`。

在方法里面打印的 `name`，实际上是调用者里面的 `name`。如果说我在静态方法 `mehtod` 里面，强行调用 `show()` 方法，这个时候它并没有调用者，没有调用 `show()` 方法的对象？是没有的。

那么既然这个对象都没有，那么下面的 `name`，它去哪找？没地找。

因此：在静态方法中同样的也不能调用非静态成员方法。

![image-20240411110016796](./assets/image-20240411110016796.png)

到现在为止，我们就已经知道了，静态方法中不能调用非静态的原因。

所以我们在书写方法的时候需要知道这个结论：静态方法中只能调用静态的内容，不能调用非静态的。

----

## 四、内存角度解释：非静态方法中，可以访问所有

先来看一下这段代码。`Student` 类里面有两个成员变量 `name`、`age`，有一个静态变量 `teacherName`。

静态方法 `method`，普通的成员方法 `show()`，`show()` 方法里打印一个 `name`，再打印一个 `teacherName`。

再往下，里面有一个测试类：创建一个 `Student` 对象，给 `name`、`age` 分别赋值，最后再去调用一下 `show()` 方法，最后再来看一下右边的内存图。

![image-20240411110538304](./assets/image-20240411110538304.png)

在一开始的时候还是main方法先进栈，然后执行到 `Student s1 = new Student();`。现在用到 `Student` 类了，它首先将 `Student` 类的字节码文件加载到方法区，在这个方法区里面会有所有的成员变量，和成员方法。

并在内存中创建了一个 **单独存放** 静态变量的空间，我们可以把这个空间叫做 `静态区`。

因此当 `Student` 的字节码文件加载到方法区后，`静态区` 就出现了。

在JDK8以前，静态区是在方法区里面的。JDK8以后，就挪到了堆空间当中。

而现在只有一个静态变量 `teacherName`，所以 `teacherName` 就被存放在了 静态区中，默认初始化值为 `null`。

等上面这些工作做好之后，到这里才叫做加载字节码文件成功。

![image-20240411111727369](./assets/image-20240411111727369.png)

加载完成之后，它才开始创建对象。等号的左边就是在栈中的 `main方法` 中定义了一个 `s1` 变量，等号的右边有 `new` 关键字，所以这里在堆中开辟了一个空间，假设这个空间的地址值是 `0x0011`，这个空间也就是我们平时所说的对象。

它里面存的是跟对象相关的，即所有的非静态的内容：`name`、`age`，默认初始化为 `null`、`0`。

最后再将 `0x0011` 赋值给 `s1`，这个才是创建一次对象。

如果我们想通过变量去访问静态也是可以的，我们能通过对象去访问到这个类中静态区中所有的内容。

![image-20240411112159088](./assets/image-20240411112159088.png)

然后再往下，去给 `name` 赋值，它是把 `"张三"` 赋值给了 `s1` 的 `name`，`s1` 是 `0x0011`，所以就是把  `"张三"` 赋值给 `0x0011` 的 `name`，原来的 `null` 就被覆盖成了 `"张三"`。

同理 `23` 赋值给 `s1` 的 `age`，那么上面的 `0` 就被 `23` 给覆盖了。

![image-20240411112452576](./assets/image-20240411112452576.png)

最后用 `s1` 调用 `show()`，这个时候要注意了，`show()` 方法是 `s1` 调用的，`s1` 是调用者，下面在获取 `name` 的时候，它获取的就是 `s1` 的 `name`。并且通过 `s1` 也是可以找到 `teacherName` 的。

因此在控制台中就会打印 `张三...null`

![image-20240411112643294](./assets/image-20240411112643294.png)

由上述的内存分析，静态的特点就是：随着类的加载而加载，字节码文件刚开始加载到内存的时候，这里的静态的 `teacherName` 在内存里面就已经存在了，它是优先于对象存在的。

因此在 `show()` 方法当中，是可以通过调用者 `s1` 是可以找到 `静态区` 中的静态变量 `teacherName` 的。

---

那么在普通的成员方法中，能不能调用静态方法呢？能不能找到这个 `method()` 呢？

其实也是可以的：现在 `show()` 方法是 `s1` 调用的，`s1` 会找到这边的对象，这个对象又是 `Student` 类型的，所以说它在调方法的时候，就会找到下面的方法区。方法区里面是有静态方法 `method` 的。

![image-20240411113153369](./assets/image-20240411113153369.png)

既然找到了 `method()` 方法，那它就可以加载到内存当中，因此非静态的方法中可以调用所有的东西。

---

## 五、总结

static翻译过来就表示：静态的意思，它是Java中的一个修饰符，可以修饰成员方法，成员变量。

其中，被 `static` 修饰的成员变量叫做静态变量。它的特点就是这个变量被该类所有对象都共享。

并且这个静态变量跟对象是没有关系的，随着类的加载而加载，优先于对象存在在内存当中。

在调用的时候它有两种方式：1、类名调用（推荐）；2、对象名调用。

----

其中，被static修饰的成员方法叫做静态方法。

它是多用在测试类和工具栏当中，在JavaBean中很少会去用，因为在实际开发当中，如果你需要在 JavaBean中去写静态方法，还需要集合到后面的一些知识才能解释，因此我们只需要记住这个结论就行了。

在调用的时候它有两种调用方式：1、类名调用（推荐）；2、对象名调用。

但是我们推荐，只要是静态的，不管是变量还是方法，都用类名调用，这样更好一些。

![image-20240411113909316](./assets/image-20240411113909316.png)

----

**static注意事项**

1、静态方法中没有 `this` 关键字

2、静态方法中，只能访问静态内容

3、非静态方法中，可以访问所有

----

这里是给有基础的同学看的，没基础的同学可以直接跳过一下内容。

有一些课程中在这里还会多讲单例设计模式，单例设计模式虽然说是用到了 `static`，但是它里面的核心亮点并不是 `static`，而是跟多线程相关的。只有在多线程里面才能把单例设计模式讲的非常的精彩。因此单例设计模式我们在static中先不讲，等后面学习到多线程的时候，再带着你慢慢去分析。

----

## 六、重新认识main方法

main方法我们每天都会写，现在我们已经能知道里面每个单词的意思了。

- `public` ：因为main方法是被JVM调用的，访问权限需要足够的大。

- `static`：main方法是静态的，所以虚拟机在调用的的时候不需要创建对象，直接类名就可以调用了

  而且因为main方法是静态的，所以测试类中其他的方法也是需要用静态修饰。

- `void`：表示方法的返回值，它表示main方法被虚拟机调用的时候，不需要给虚拟机做一个数据的返回

- `main`：main是一个方法的名字，是Java规定程序主入口方法的名。

  它是一个通用的名字，虽然它不是关键字，但是只有main才能被虚拟机识别，如果你写成其他名字了，虚拟机是不认识的

- `String[] args`：以前用于接收键盘录入数据的，现在是没有用的。

  但是Java为了上下兼容，将这个参数还是保留了。

----

## 七、以前接收数据的方式

在这需要带着大家再来读一下这里的参数：`String[] args`。

在参数中看到一个 `[]`，表示的是数组。

`String` 表示的是数组里面数据的类型，即数组里面只能存字符串。

`args` 是数组的名字。

```java
public class Test {
    public static void main(String[] args) {
        // 看到数组我就有一种浑身不舒服的感觉，看到数组我就忍不住来遍历它
        //在遍历数组前先打印 args.length
        System.out.println(args.length); // 打印的结果长度为0，因为默认情况下，这个数组中是没有数据的
        for (int i = 0; i < args.length; i++) {
            System.out.println(args[i]);
        }
    }
}
```

打印的结果长度为0，因为默认情况下，这个数组中是没有数据的

在低版本的JDK中，`args` 是用来接收键盘输入的数据，但并不是在控制台中接收的，而是在IDEA右上角中按下图点击

![image-20240411132743395](./assets/image-20240411132743395.png)

此时会弹出一个窗口，如下图，在 `Program arguments`（程序参数） 中，我们可以把要传递给程序的参数写在这个里面，数据之间要用空格隔开。

如果不隔开，全部写在一块，它就会把这个参数作为一个整体，交给 `String[] args` 数组，数组的长度就是 `1`。

![image-20240411132806666](./assets/image-20240411132806666.png)

例如我在这里传入 `Hello World Java` ，三个参数用空格隔开，`0` 索引 `Hello`，`1` 索引 `World`，`2` 索引 `Java`。

![image-20240411133100139](./assets/image-20240411133100139.png)

然后应用、保存一下。

![image-20240411133325568](./assets/image-20240411133325568.png)

此时再来运行。此时数组的长度已经变成 3 了，刚刚的 `Hello World Java` 就已经传递给这个程序了。

![image-20240411133358924](./assets/image-20240411133358924.png)

这种方式不需要大家掌握，了解一下就可以了，因为我们现在还想要键盘接收数据的话，直接用 `Scanner` 就好了，而刚刚学习的是一以前的接收方式。



----

# 124.继承的概述

## 一、引入

继承是面向对象三大特征（封装、继承、多态）之一，可以让类跟类之间产生子父的关系。

之前我们已经学习完了 `封装`，现在我们来学习第二个 —— `继承`。

<img src="./assets/image-20240411134105031.png" alt="image-20240411134105031" style="zoom: 50%;" />

所有的技术，它都是为了解决问题而出现的，继承也不例外。

接下来我们就一起推到一下继承是为什么出现的，它又可以解决什么样的问题。

----

## 二、封装

在推导继承之前，我们还是要来看一下封装。在之前我们讲解封装的时候曾经说过：

对象代表什么，就得封装对应的数据，并提供数据所对应的行为。

有了封装之后，程序员就可以把一些零散的数据，和一些行为都封装成一个整体，这个整体就是我们所说的对象。以后我们面对的就是这个对象的整体，而不是一些零散的数据了。

这个整体在实际开发当中有什么好处呢？我们来看一个场景：我们现在要在方法当中打印学生的信息，如果我们没有封装，我们就需要把这些零散的数据 `name`、`age`、`gender`、`address` 。。。都要大幅度传递给方法，方法就要写很多很多的参数。

但是有了封装之后，我们就可以将这个整体传递给方法了，方法需要什么参数，就可以通过 `get` 方法直接获取出来就行了。它想获取什么行为，直接用这个对象 `s` 调用那就行了，非常的方便。

![image-20240411134739385](./assets/image-20240411134739385.png)

-----

## 三、推到继承出现的原因

但是会有个小问题，当这样的JavaBean类越来越多之后，问题就会出现了。

例如现在有第二个JavaBean去描述老师，老师也有 `name`、`age`、`gender`、`address`....这样的属性，行为有 `sleep()`、`teach()`、`eat()` 这些方法。

此时就会发现了 `Student` 和 `teacher` 类中重复的代码太多了！

![image-20240411135133489](./assets/image-20240411135133489.png)

那该怎么解决呢？你会怎么解决呢？

你肯定会想着将相同的内容放到单独的地方，那么 `Student` 和 `Teacher` 当中就不需要去写重复的内容了，只要写上各自单独的内容就行了。

![image-20240411135316140](./assets/image-20240411135316140.png)

其实Java也是这么去设计的，它会把 `Student` 类、`teacher` 类中重复的内容写在第三个类中。这个类既要表示学生，又要表示老师，所以我们会给这个类起个名字，它表示的范围更大，就叫做：`Person`。

`Person` 你就可以理解成，是这个体系的 `爸爸`，下面的`Student`、`teacher` 就可以理解为 `儿子`。

这跟现实中就很像了，爸爸有的东西，儿子都可以去用。在代码当中其实也是一样的，爸爸中的 `name`、`age`、`gender`、`address`、`sleep()`、`eat()`、`set/get()`，在下面的两个儿子当中就不需要再写一遍了，儿子里面要用的时候，直接过来拿就可以了。

![image-20240411135844241](./assets/image-20240411135844241.png)

这个就是我们Java中的继承。

继承其实就是类与类之间的父子关系，有了这种关系之后，我们就可以少写很多很多重复的代码了。

![image-20240411135752644](./assets/image-20240411135752644.png)

----

## 四、继承

在Java中，提供了一个 `extends` 关键字，用这个关键字，我们就可以让一个类和另一个类建立起继承关系。

~~~java
pulic class Student extends Person { }
~~~

- `Student` 称为 `子类（派生类）`，`Pserson` 称为 `父类（基类或超类）`。

为什么会有这么多不同的称呼呢？其实是因为这些东西最原版的都是老外编写的，而清朝大国在翻译的时候往往加上了自己的理解，因此名字起的都不一样。但我们一般来讲都是叫做`子类`、`父类`。

例如有这样的继承关系，`Person` 就是父类，`Student` 和 `Teachr` 就是两个不同的子类。

有了这种继承关系后的好处：

- 可以把多个子类中重复的代码抽取到父类里面，子类中就不用再写一遍了，而是直接使用，减少代码冗余，从而提高了代码的复用性。

- 子类可以在父类的基础上，再去增加其他的功能，使子类更加的强大。

  例如子类 `Student`，还可以添加一个 `study()` 学习方法，而 `teacher` 子类还可以在父类的基础上添加一个 `teach` 教书方法。

![image-20240411144631383](./assets/image-20240411144631383.png)

----

## 五、继承到底要学习什么呢？

1、我们如何自己设计一个继承结构，并把代码写出来

2、我们如何去用别人已经写好的继承结构

---

## 六、自己设计继承结构

首先我们来说自己设计，自己会设计了，自然就会用别人已经写好的继承结构了。

那你觉得我们自己在设计的时候，首先第一步你要想什么？是代码该怎么写吗？

其实并不是这样的，我们自己在设计的时候，摆在我们面前的第一个难题不是里面的代码该怎么写，而是我们什么时候会用到继承技术。

----

## 七、什么时候用继承？

当类与类之间，存在相同（共性）的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码。

例如现在有 `Student` 跟 `Teacher`，`Student` 中会有姓名、年龄这两个属性，`Teacher` 里面也会有姓名、年龄。

此时我们就可以定义一个父类 `Person` ，然后把重复的内容都放到父类中，子类就不需要再写一遍了，这就是一个完美的继承结构。

此时我们就可以用这个结构去推导一下上面的概念。

![image-20240411145427935](./assets/image-20240411145427935.png)

上面概念第一句话说：`类与类之间，存在相同（共性）的内容`，这句话的意思其实就是说，下面的 `Student`、`Teacher` 之间，它是存在相同的内容的：姓名、年龄。

![image-20240411145649442](./assets/image-20240411145649442.png)

但是满足这个条件还不够，还需要看第二句话。

第二句话：`并且满足子类是父类中的一种`，才可以考虑使用继承，来优化代码。

例如下面，`Student —— 学生`，就是 `Person  ——  人` 中的一种。下面的 `Teacher ———— 老师`，也是 `Person ———— 人` 中的一种。

因此它就是一个完美的继承结构。

![image-20240411145839628](./assets/image-20240411145839628.png)

现在我们来看右边的第二个例子。现在它有两个类：`Manager`（项目经理）、`Coder`（程序员）。

`Manager`（项目经理）里面会有：`姓名、工资、管理奖金` 这三个属性。

`Coder`（程序员）里面会有：`姓名、工资` 这两个属性。

那你觉得父类应该叫什么，属性该怎么抽取呢？

应该取名为 `Employ`，这个父类的名字取名字需要规范，因为 `项目经理、程序员` 都是员工中的一种。

然后我们就可以把重复的东西写在父类中了，注意，`Manager`（项目经理）的`管理奖金`就不应该写在父类中，因为`管理奖金`是项目经理独有的，所以它应该单独写在 `Manager` 这个类当中。

![image-20240411150915923](./assets/image-20240411150915923.png)

现在我们来看第三个案例，假如现在有两个类：`Coder`（程序员）、`Phone`（手机）

`Coder`（程序员）里面会有：`id、名字、年龄` 这三个属性。

`Phone`（手机）里面会有：`id、名字、价格` 这三个属性。

能不能去设计一个 `Goods` 类（物品、商品），然后把 `Coder`、`Phone` 中共同的属性抽取上去呢？

如果你在代码中这么写了，首先语法当中是没有什么问题的，代码不会报错，但是它不符合实际的开发情况。

如果在公司你真的这么设计，绝对要挨骂。被骂的时候还不觉得自己错了，脸上笑嘻嘻，心里MMP的程序员。

![image-20240411151442439](./assets/image-20240411151442439.png)

正确答案就是，左边的这种设计结构它是不对的，因为我们在设计继承结构的时候，不能光看到相同的就抽取，还必须要满足 `子类是父类中的一种` 才可以。

现在 `Goods` 翻译过来是商品，你说 `Phone` 是个商品，没问题。那 `Coder` 程序员是商品吗？这肯定不合理。	

那到底该怎么去设计呢？此时就需要告诉你，此时它就不能写继承结构了。 `Coder`、`Phone` 需要单独的书写。

以后我们在实际开发当中，你不要想着把所有的类都设计到一个继承结构当中，这是不合理的。

在我们实际开发当中，它会有很多很多完全不同的继承结构。你可以将 `Coder`（程序员）跟其他相同的类放在一个继承结构当中；然后可以把 `Phone`（手机）跟其他的商品再去放到同一个继承结构当中，这个才是正确的设计。

----

## 八、总结

**1、什么是继承，继承的好处？**

继承是面向对象三大特征（封装、继承、多态）之一，可以让类跟类之间产生子父的关系。

我们可以把多个子类中重复的代码抽取到父类里面，子类中就不用再写一遍了，而是直接使用，减少代码冗余，从而提高了代码的复用性。

**2、继承的格式？**

在定义的子类后面，加上一个 `extends` 关键字，再跟随父类的名称就可以了。

这就表示我定义了一个子类，它继承于后面的父类

~~~java
public class 子类 extends 父类 { }
~~~

**3、继承后子类的特点？**

子类可以得到父类的属性和行为，子类可以直接使用。

子类可以在父类的基础上新增其他功能，子类更强大。

---

## 九、继承中的语法特点

在下一章中，我们就要来学习继承中的语法特点了，它会包括以下的知识点：

1、什么是继承？继承的好处

这个我们已经在刚刚学习过了

2、继承的特点

我们会从 `继承的特点` 开始继续学习

3、子类到底能继承父类中的哪些内容？（内存图 / 内存分析工具）

第三点是一个难点，是一个非常底层的东西，我们要一起来研究一下子类到底能继承父类中的哪些内容？

父类中的成员变量、成员方法、构造方法，是所有的东西都可以继承下来吗？

其实并不是的，它会有这样的关系，这个关系需要注意，跟目前市面上很多课程中讲的都不一样，甚至有些结论是完全对立、完全相反。

为了验证我们所讲的内容是对的，我们会从两个角度讲。

最开始我们会给大家画一个内存图，另外还会用Java给我们提供的一个内存分析工具带你深挖对象中的内存结构。

![image-20240411153349417](./assets/image-20240411153349417.png)

学完了上面这些之后，还会带你来学习 `成员变量、成员方法、构造方法` 的访问特点。

![image-20240411153452344](./assets/image-20240411153452344.png)

最后再跟大家讲一个 继承中独有的关键字：super。

![image-20240411153512464](./assets/image-20240411153512464.png)

敬请期待吧~



----

# 125.继承的特点和继承体系的设计

## 一、继承的特点

继承的特点用一句话就能说明白：Java只支持单继承，不支持多继承，但支持多层继承。

我们可以把这句话分成三部分，挨个去解释一下。

![image-20240411174937833](./assets/image-20240411174937833.png)

----

### 1）Java只支持单继承

- 单继承：一个子类只能继承一个父类。

  这个跟我们现实生活中也是一样的，一个儿子只能有一个爸爸。

- Java不支持多继承：子类不能同时继承多个父类。

  这个跟我们现实生活当中也是一样的，一个儿子不能有两个亲爸。

![image-20240411175227940](./assets/image-20240411175227940.png)

Java在当时为什么要这么去设计呢？

当时 `James Gosling` ，也就是右边的这哥们。当时它在设计 `Java` 的时候，是为了改进 `C++` 语言中各种不合理的设计。在 `C++` 中是允许多继承的，因此在 `C++` 里面一个儿子可以有多个爸爸。但是 `James Gosling` 发现了，如果Java也沿袭这一设计的话，用起来相当不爽，有一种浑身蛋疼的感觉。

怎么个蛋疼法，我们来看一个场景。

假设 Java 也沿袭了 C++ 的多继承，第一个父类里面有一个方法 `method`，方法中打印一句话：`让儿子去复习数学`。

第二个父类中也有 `method` 方法，方法中打印一句话：`让儿子去复习语文`

子类同时继承了这两个父类，此时我们就可以来创建子类的对象，并调用方法。

在之前我们曾经说，子类可以直接使用父类中的方法。但是现在就会有个问题了，现在我调用的 `method` 是调用父类A里的，还是调用父类B中的呢？此时子类就不知道了。

因此为了避免这么尴尬的问题出现，`James Gosling` 在设计Java的时候，就取消了这一设计。

因此在Java中只能单继承，不能多继承。

![image-20240411204230211](./assets/image-20240411204230211.png)

但是它是可以多层继承的。

----

### 2）Java支持多层继承

多层继承：子类A继承父类B，父类B 可以 继承父类C。

这样跟我们现实中的祖宗三代是一样的了。

![image-20240411204414872](./assets/image-20240411204414872.png)

 在它们的这个关系中，如果你单独来看左边的这两个类，儿子是子，爸爸是父。单看右边的这两个类，爸爸是子，爷爷是父。

那最左边的小孩，跟右边的爷爷，他们两个直接是什么关系呢？

![image-20240411204617224](./assets/image-20240411204617224.png)

在Java中，我们模糊了爷爷、太爷爷这样的关系，统称为父类。只不过我们会称爷爷是孙子的间接父类，而爸爸则是它的直接父类。

![image-20240411204739186](./assets/image-20240411204739186.png)

那子类又有父类，父类又有父类，那有没有一个尽头呢？

其实在Java中有一个最大的祖类，它叫做 `Object`。这个 `Objcet` 是Java提前写好的，每一个类都直接或者间接的继承 `Object`。

在代码中，假如我书写了

~~~java
public class A extends B { }
~~~

此时A是子类，B是父类，这个很明显。但是如果我没有写这样的继承关系，那么A就没有爸爸了吗？不是这样的。

~~~java
public class B { }
~~~

A会默认的继承 `Object` 类，这个关系不是我们自己写的，而是虚拟机在运行的时候自动帮你加上去的。

虚拟机在运行的时候会查看你当前这个类有没有父类，如果有，那没事了。如果说没有，虚拟机会给它加一个默认的继承关系，即继承 `Objcet` 类。

----

### 3）继承体系

当我们这样的JavaBean类写的越来越多的时候，会出现一个叫做：`继承体系`。

在继承体系最上面的类都是默认的继承于 `Object`，下面所有的类都是间接继承于 `Object` 类。

![image-20240411205531970](./assets/image-20240411205531970.png)

在一个继承体系当中，针对于任意一个子类，它可以使用自己直接父类里面的内容。

![image-20240411205614748](./assets/image-20240411205614748.png)

也可以使用自己间接父类里面的内容。

![image-20240411205635501](./assets/image-20240411205635501.png)

但是要注意，它不能使用这种类似于叔叔类中的内容。

![image-20240411205655045](./assets/image-20240411205655045.png)

----

### 4）总结

1、Java只能单继承：一个类只能继承一个直接父类

2、Java不支持多继承、但是支持多层继承。

3、Java中所有的类都直接或间接继承于 `Object` 类。

----

## 二、练习：继承的练习（自己设计一个继承体系）

<img src="./assets/image-20240411210256561.png" alt="image-20240411210256561" style="zoom:67%;" />

### 1）分析

自己在设计继承体系的时候有个诀窍：千万千万不要在自己的脑子里去脑补，光靠脑子去想肯定是不行的。

因为当一个体系比较复杂的时候，就会完全想不明白。

分享一个思想：画图法。顾名思义，先不要盲着去写代码，先把图画出来，然后再去利用那个图再去写代码，这样非常的方便。

画图的小诀窍：从下往上画，下面的东西是子类，上面的东西是父类。

我们在画的时候需要把子类中的共性内容抽取到父类中。

![image-20240411210559616](./assets/image-20240411210559616.png)

书写代码也有个小诀窍：从上往下写，因为需要先写爸爸，再写儿子。

----

### 2）代码

Animal.java

~~~java
package com.itheima.a01oopextendsdemo1;

public class Animal {
    public void eat(){
        System.out.println("吃东西");
    }

    public void drink(){
        System.out.println("喝水");
    }
}
~~~

Ragdoll.java（布偶猫）

~~~java
package com.itheima.a01oopextendsdemo1;

public class Ragdoll extends Cat{

}
~~~

Cat.java

~~~java
package com.itheima.a01oopextendsdemo1;

public class Cat extends Animal {
    public void catchMouse() {
        System.out.println("猫在抓老鼠");
    }
}
~~~

Dog.java

~~~java
package com.itheima.a01oopextendsdemo1;

public class Dog extends Animal{
    public void lookHome(){
        System.out.println("狗看家");
    }
}
~~~

LiHua.java

> 由于中国狸花猫是我们清朝大国的品种，所以说它的名字就叫做：LiHua。
>
> 因为在之前我们说了，阿里巴巴编码规范，在阿里巴巴编码规范中有一条：如果拼音等同于英文，那么这个拼音是可以用的，例如这里的Lihua（狸花）。

~~~java
package com.itheima.a01oopextendsdemo1;

public class LiHua extends Cat{

}
~~~

Husky.java

~~~java
package com.itheima.a01oopextendsdemo1;

public class Husky extends Dog{

    public void breakHome(){
        System.out.println("哈士奇在拆家");
    }
}
~~~

Teddy.java

~~~java
package com.itheima.a01oopextendsdemo1;

public class Teddy extends Dog{
    public void touch(){
        System.out.println("泰迪又在蹭我的腿了~");
    }
}
~~~

到目前为止，7个类就已经全部写完。这个代码其实还没有真正结束，因为我们还需要创建对象。现在我们写的这些类都属于 JavaBean 。接下来我们还需要再写一个测试类。在测试类里面写一个 `main方法`。

~~~java
package com.itheima.a01oopextendsdemo1;

public class Test {
    public static void main(String[] args) {
        //创建对象并调用方法

        //1.创建布偶猫的对象
        Ragdoll rd = new Ragdoll();
        rd.eat();
        rd.drink();
        rd.catchMouse();

        System.out.println("----------------------");

        //2.创建哈士奇的对象
        Husky h = new Husky();
        h.eat();
        h.drink();
        h.lookHome();
        h.breakHome();
    }
}
~~~

----

### 3）注意细节

#### 1、测试

要注意，在下面代码中，使用 `rd` 去调用方法的时候，虽然我们在布偶类中一个方法也没写，但是它能调用的方法有很多很多。

<img src="./assets/image-20240411212509806.png" alt="image-20240411212509806" style="zoom:67%;" />

那剩下的 `equals` 等方法是哪来的呢？在Java中，它有个最大的祖宗类。如果一个类是没有父类的，这个类就会默认继承于 `Object`。

因此 `Animal` 类其实还继承于 `Object` 类，`Object` 中有很多很多方法，这些方法有哪些作用，现在我们不用着急，后面会有个单独的章节去说这个 `Object`。

----

#### 2、权限修饰符

如果说写方法的时候前面的权限修饰符，没有写 `public` ，而是 `private`，这个时候子类就无法访问了。

这是因为 `private` 表示的是私有的意思，私有的东西只能在本类中访问，即 `Animal` 类，在其他类中就访问不到了。例如：爸爸的私房钱，是不是只有爸爸自己能用。

注意事项：子类只能访问父类中非私有的成员

~~~java
package com.itheima.a01oopextendsdemo1;

public class Animal {
    // 代码会报错
    private void eat(){
        System.out.println("吃东西");
    }

    public void drink(){
        System.out.println("喝水");
    }
}
~~~

----

## 三、总结

1、Java只能单继承，不能多继承，但是可以多层继承

2、Java中所有的类都直接或者间接继承于Object类

3、子类只能访问父类中非私有的成员

4、独立完成继承体系的案例



----

# 126.子类到底能继承父类中的哪些内容

## 一、引入

在将这个知识点的时候，首先要跟大家讲两个误区，很多课程中都会认为：

误区1：父类私有的东西，子类就无法继承了

误区2：父类中非私有的成员，子类可以访问的，就一定是被子类继承下来了。

接下来我们会从两个角度介绍一下，真正情况到底是怎么样的，因为难度比较大，所以首先会通过内存图的方式告诉你结论，等你知道结论之后，再利用Java提供的 `内存分析工具`，带着你让你看一下事实情况究竟是怎么样的。

第二个 `内存分析工具` 是不需要大家掌握的，在后面学习到虚拟机的时候还会来说明。

那为什么现在要用 `内存分析工具` 呢，其实这是传智教育一直的教学观念。传智教育总裁方立勋老师曾经说过：知识点要有出处，特别是像这种比较有争议的知识点，别人怎么知道你讲的就是对的呢？你需要有证据，证据就在今天要学习的 `内存分析工具` 当中。

废话不多扯，开始来撸。

----

## 二、子类到底能继承父类中的哪些内容

子类能继承父类中的哪些内容呢，首先要来看父类中到底有什么。

在父类中总共其实也只有三部分内容：构造方法、成员变量、成员方法，这三个统称为类的成员，不同的成员修饰符它的结果是不一样的。

第一类：非私有，第二类：私有，就是用 `private` 来修饰的。

其中非私有我们就学了一个：`public` ，在后面我们还会学习其他的非私有修饰符，它们的规则是一样的。

----

首先我们来看第一个：构造方法。

构造方法不管是什么样的修饰符，都是是不能够被子类继承下来的。

不管是什么样的修饰符，子类都可以把父类的成员变量继承下来。只不过私有的子类是不能直接使用的，如果一定要使用，就需要通过对应的 `get、set` 方法来使用。

私有的成员变量子类不能调，但是继承下来和调用不是一个概念。

继承下来指的是，父类里面有的东西，子类没有写，但是它可以把父类中的拷贝一份拿过来，这样相当于子类也有了，这才叫做继承下来。

但是有的时候，子类虽然把东西拿过来了，却调用不了。

但结论就是：不管是什么样的修饰符，成员变量都能被子类继承下来。我们先不管子类能不能用，只要知道关于成员变量子类都可以继承下来就可以了。

3、成员方法

这个跟上面又不一样了，非私有的，它能被继承下来；但是如果成员方法是私有的，就不能继承下来。

![image-20240411215803380](./assets/image-20240411215803380.png)

----

## 三、构造方法是否可以被继承

构造方法不管是什么样的修饰符，都是是不能够被子类继承下来的。

那为什么不能被继承下来呢？关于这个知识点，我们可以反过来理解。

假设构造方法是可以被子类继承的。

下面我在父类中可以写一个空参构造，再写一个有参构造，假设它能被子类继承，那么子类里面就不用再写一遍了，相当于就是把父类里面的构造方法拿过来就可以用了。

但是拿过来之后你有没有发现，它违背了构造方法的定义规则。

![image-20240411220043274](./assets/image-20240411220043274.png)

构造方法的名字跟子类的类名不一样了！，因此父类的构造方法它是不能被子类继承的。

![image-20240412141544449](./assets/image-20240412141544449.png)

当子类想要有多个构造方法，必须要自己手动写一遍。

---

## 四、构造方法是否能被继承 —— 代码演示

注意，下面代码只建了一个文件，文件里面包含了三个类，这样写是为了大家看代码的时候更加的方便。但是在以后写综合项目的时候还是要按照以前的习惯：一个Java文件中只写一个类。

~~~java
package com.itheima.a02oopextendsdemo2;

public class Test {
    public static void main(String[] args) {
        //利用空参构造创建子类对象
        Zi z1 = new Zi();

        //利用带参构造创建子类对象
        Zi z2 = new Zi("zhangsan",23); // 会报错，就是因为子类中没有这个有参构造
    }
}

class Fu{
    String name;
    int age;

    public Fu(){}
    public Fu(String name,int age){
        this.name = name;
        this.age = age;
    }
}

class Zi extends Fu{
    //如果一个类中没有构造方法，虚拟机会自动的给你添加一个默认的空参构造
}
~~~

-----

## 五、成员变量是否可以被继承

### 1、解释

不管是什么样的修饰符，子类都可以把父类的成员变量继承下来。只不过私有的子类是不能直接使用的，如果一定要使用，就需要通过对应的 `get、set` 方法来使用。

例如下图，就是直接将 `gongFu` 成员变量继承了下来。

![image-20240412193820194](./assets/image-20240412193820194.png)

刚刚看到的是非私有的情况，那如果这个变量用 `private` 来修饰了呢。其实也很好理解，儿子也将上图的武功招式继承下来了，只不过它拿到的是锁起来的武功招式，不能直接用，如果实在想用，得用钥匙去打开，这里的钥匙指的其实就是 `get` 、`set`方法。

![image-20240412194133281](./assets/image-20240412194133281.png)

----

### 2、`没有用 private 修饰` 的继承的内存图

看内存图前先来看代码，代码有两段，第一段是关于子父类的，父类中有两个成员变量，一个是 `name`、一个是 `age`。

在子类继承了父，里面有一个独有的成员变量 `game`，相当于是儿子玩的游戏。

另一个就是一个测试类。此时我们就可以来看一下最右边的内存。

![image-20240412194541688](./assets/image-20240412194541688.png)

其中，栈是跟方法有关的，方法被调用，进栈执行；方法里面的代码执行完毕，需要从栈里面出去。

堆是跟 `new` 关键字有关系的，创建的对象都是在堆里面的。

而右下角的方法区，它是跟字节码文件有关的。一个类想要被使用了，这个类的字节码文件就要加载到方法区当中临时存储。

首先是测试类先来执行，因此 `TestStudent` 这个类的字节码文件就要加载到方法区，字节码文件中存储的就是 `main` 方法。

![image-20240412205202583](./assets/image-20240412205202583.png)

 `main方法` 被虚拟机自动调用，因此 `main方法` 就需要进栈里去运行 。

然后执行 `main方法` 里面的第一行代码，在 `main方法` 的第一行代码中，它用到了子这个类了，因此首先它要把子这个字节码文件先加载到内存当中，在这个里面它存储的就是成员变量 `game`，在加载的时候它发现了，子类有一个爸爸，因此此时它还会把父类的字节码文件加载到内存当中，在这个里面存储的父里面的 `name`、`age`。此时还没结束，父类还有自己的爸爸，

如果一个类没有写继承关系，虚拟机会给它添加一个默认的爹：`Object`，因此在方法区中，它还会加载 `Object` 的字节码文件，但是在我们现在的这个内存当中，那个 `Object` 关系不大，因此那个 `Object` 暂时可以不用考虑。

![image-20240412211636600](./assets/image-20240412211636600.png)

继续往下，现在字节码文件都已经加载完毕了，所以说它再来执行等号的左边，等号的左边相当于在栈里面声明了一个变量，变量的名字叫做 `z`，即栈中的这块小空间名字就叫做 `z`，前面加了一个 `Zi` 的类型限定，表示这个小空间以后，能存储 `Zi` 这个对象的地址值。

等号的右边有一个 `new` 关键字，一旦看到了 `new` ，那就一定是在堆里面开辟了一个空间，这个空间就是我们说的对象。因此现在它在堆里面开辟了一个空间，跟以前不一样的是，在以前，我们没有将继承，这个对象里就只有一块，但是现在有了继承了，就会把对象里面一分为二，一份它会去记录父里面的成员变量，还有一部分就是去记录 `子` 里面的 成员变量。

因此在左边这块当中，它会记录 `name`、`age`，这个是从父类里面继承过来的。还有一块是记录自己的 `game`（游戏），然后给它们三个做一个默认初始化值，`String` 引用数据类型，所以默认初始化值是 `null`。`int` 默认初始化值就是 `0`。

最后再把地址 `001` 赋值给左边的 `z`，`z` 就可以通过 `001` 找到右边堆内存中创建的对象。

![image-20240412212822774](./assets/image-20240412212822774.png)

再往下 `sout(z)`，相当于就是把变量 `z` 里记录的东西做一个打印。由于现在 `z` 中记录的是一个地址值，所以在控制台中打印的就是地址值 `001`。

再往下，`z.name = "钢门吹雪"`，相当于就是把 `"钢门吹雪"` 赋值给 `z` 的 `name`，`z` 又是 `001`， `001` 就是右边的这块空间，所以它就会把 `"钢门吹雪"`  赋值给右边的这块空间里面的 `name`，它在找的时候，会先找存储子类的成员变量，即右边的这块空间；如果没有找到，再到左边存储父类成员变量这块空间里面找，此时就找到了，因此 `name` 此时记的值就是 `"钢门吹雪"` 。

![image-20240412213414903](./assets/image-20240412213414903.png)

再来往下，`z.age = 23`，相当于把 `23` 赋值给 `001` 的 `age`，找到了就是把 `23` 赋值给 `age`，原来的 `0` 就被覆盖了。

接下来，`z.game = "王者荣耀"`，相当于就是把 王`者荣耀` 赋值给 `001` 的 `game`，一下子在右边就能找到了，所以说 `game` 中记的就是 `"王者荣耀"`。

最后再用 `z` 获取 `name`、`age`、`game`，分别找到里面对应的值，然后打印出来。

这个就是带有继承结构完整的内存

![image-20240412213714768](./assets/image-20240412213714768.png)

最后 `main方法`里的代码全都执行完了，`main方法` 出栈，一旦方法出去了，方法里的变量也就消失了，变量一旦消失了，针对右边的对象而言，就没有人去用它了，一旦没有人去用它，它就会变成垃圾。

在Java虚拟机里面其实还有个叫做：垃圾回收器。垃圾回收器你可以把它理解成 `保洁阿姨`，`保洁阿姨` 会在合适的时候会把内存里面这些用不到的垃圾去给清理掉。但是它什么时候去清理我们不知道，它是自动的，我们不管，我们只要知道对象一旦变成垃圾，就不能再用了就可以了。

----

### 3、`没有用 private修饰` 内存图总结

与之前内存图不一样的地方：

1）再加载字节码文件的时候，它会把父类也加载进来

2）在创建对象的时候，它里面会有一部分空间是存储父类继承下来的成员变量；还有一部分空间，才是存储自己子类里面的成员变量。

----

### 4、`使用private修饰` 的内存图

在刚刚，我们父类里面的成员变量没有用 `private` 修饰，但如果我们用 `private` 修饰了，这个内存会变成什么样呢，跟刚刚是一样的吗？

如下图，代码已经将成员变量的修饰符都变成了 `private`。一旦父类中用 `private` 修饰了，在测试类中，如果用 `z` 直接调用，就报错了。因此在这里就用红色加以区分，在IDEA中，红色就是错误的意思。

还是来看右边的内存。

![image-20240412215126270](./assets/image-20240412215126270.png)

在一开始，还是会把 `TestStudent` 的字节码加载到方法区中，然后 `main方法` 被虚拟机调用，会进到栈中运行，再来执行main方法中的第一行代码：`Zi z = new Zi()`。

第一行代码中用到了 `Zi` 这个类，所以会把 `Zi` 的字节码文件加载到内存。但又因为 `Zi` 是有一个爹的，它的爹叫做 `Fu`，因此会把 `Fu` 的字节码文件也加载到内存。

在加载的时候它又发现了，`Fu` 也有一个默认的爹 `Object`，所以在方法区中，其实还会把 `Object` 字节码加载进来，而由于在这个案例中，`Object` 暂时没有什么太大的关系，因此我们可以暂时忽略 `Object`。

继续再来往下，此时就轮到等号的左边去执行。等号的左边相当于就是一个变量的定义，因此在栈里面，它会定一个变量，变量的名字叫做 `z`，类型限定 `Zi`。

再来看等号的右边，有 `new` 关键字，因此会在堆里面开辟一个空间，再把这块空间一分为二，一部分存储父类成员变量，一部分存储子类的成员变量。然后默认初始化值，最后再把 `001` 赋值给左边的变量 `z`，`z` 通过变量，就可以找到右边的对象。

这个时候你就发现了，虽然他是 `private` 私有的，但是在子类里面，也真的能继承下来。现在，第一行代码就正式执行完了。

![image-20240412220014197](./assets/image-20240412220014197.png)

继续往下，走第二行 `System.out.println(z)`，相当于就是把变量 `z` 里面记录的内容打印出来，这里变量里记的就是 `001`，因此打印的就是 `001`。

再往下，`z.name = "钢门吹雪";`，由于 `z` 是 `001`，所以就把 `"钢门吹雪"` 赋值给 `001` 的 `name`。在找 `name` 的时候先找右边（子类）发现没有 `name`，然后再到左边（父类）中找，但是这个时候问题就出现了，`name` 是被 `private` 修饰的，一旦被 `private` 修饰了，像这种直接调用，它是找不到的。所以此时赋值失败，代码报错。

再往下：`z.age = 23;`，同样的道理，把 `23` 赋值给 `001` 的 `age`，先在右边找，没找到，再到左边找，发现有 `private` 修饰，因此这个时候也无法赋值，那么 `name` 跟 `age` 还是原来的默认初始化 `null` 、`0`。

![image-20240414214747275](./assets/image-20240414214747275.png)

再往下，`z.game = "王者农药"`，这个时候它是可以成功的赋值的，在右边这里找到了 `game` ，把它赋值成了 `"王者农药"`，原来的 `null` 就被覆盖了。

最后 `sout(z.game)`，但是由于 `name` 跟 `age` 都是由 `private` 去修饰的，所以它是找不到的，就算打印，它也找不到值，它会报错。

因此在这个地方只能打印 `z.game`，控制台显示 `"王者农药"`。

![image-20240414215820899](./assets/image-20240414215820899.png)

最后，代码执行完了，`main方法需要出去`，栈中的变量消失，堆中的对象没有人用了，对象就会变成垃圾，垃圾回收器会在合适的时候把这个垃圾从内存当中清理掉。

这个就是关于 `成员变量` 的继承情况。我们要知道，只要是成员变量，不管你是私有的，还是非私有的，在子类里面其实都是可以继承下来的，只不过私有的虽然继承下来了，但是不能直接去使用。

![image-20240415201059655](./assets/image-20240415201059655.png)

----

## 六、成员方法是否可以被继承

### 1）虚方法表

成员方法就不一样的，`私有` 跟 `非私有` 是两个不一样的情况。

首先我们先来看一个创建对象调用方法的规则，知道了这样的规则之后，我们再来画内存图。

首先有下面这样的继承结构，`A` 继承 `B`，`B` 继承 `C`，现在在代码当中，我们创建了 `A` 的对象，用 `A` 的对象去调用 `方法C`，你觉得是怎么调用的呢？

很多课程里面是这么解释的：既然我们现在创建的是 `A` 的对象，首先就应该先到 `A类` 里面去找 `方法C`，没有找到，再到它的父类 `B类` 中找，还是没有，继续到父类 `C类` 中去找 `方法C`，一级一级的往上。但这种解释其实是不对的，如果说Java虚拟机真的是这么设计的话，它会被别人骂死。

<img src="./assets/image-20240415202139605.png" alt="image-20240415202139605" style="zoom:80%;" />

如果你想不明白，那为什么先将这个继承结构复杂化

![image-20240415202226362](./assets/image-20240415202226362.png)

再复杂化

![image-20240415202246095](./assets/image-20240415202246095.png)

此时再来看，如果我们创建的还是 `A类` 对象，但是我现在想要调用 `方法P`，按照其他课程的理解方式，那我是不是要从 `A类` 开始找，然后一级一级的往上，一直找到 `P类` 才行（其中一共有15个类），你想一下，你只是想要调用 `P类的` 一个方法，却要查 `15个类`，这样会让代码的效率变得非常的慢！！！ 

因此Java在底层它做了一些优化，它会从最顶级的父类开始，设立了一个 `虚方发表`，它会把这个类当中，经常可能要用到的方法单独抽取出来，放到一个 `虚方法表` 中。

![image-20240415202636974](./assets/image-20240415202636974.png)

那什么叫做经常要用的方法呢？它有三个条件：1、方法不能被 `private` 修饰；2、方法不能被 `static` 修饰；3、方法不能被 `final` 关键字修饰。

![image-20240415203019050](./assets/image-20240415203019050.png)

只要方法满足要求，这样的方法叫做 `虚方法`，Java就会把这些虚方法抽取出来，放到 `虚方法表中`，在继承的时候，`父类C` 它会把自己的 `虚方发表` 交给儿子 `B类`，那么在 `B类` 中它也会有自己的 `虚方法表` ：它会在 `C类` 给它的 `虚方法表` 中再添加自己类中的 `虚方法`。

![image-20240415203108903](./assets/image-20240415203108903.png)

那么当 `A类` 再继承 `B类` 的时候，`B类` 就会把自己的 `虚方法表` 再交给儿子 `A类`，在 `A类` 中它也会有自己的 `虚方法表` ：它会在 `B类` 给它的 `虚方法表` 中再添加自己类中的 `虚方法`。

![image-20240415203310291](./assets/image-20240415203310291.png)

有了 `虚方发表` 后，程序的性能就会大大的提高。

当然除了提高性能之外，`虚方法表` 还有其他的作用，比如说我们后面马上学习到的 `方法重写`，关键点就是在 `虚方法表` 中。

此时，当我们在创建一个 `A类` 对象的时候，并调用 `方法C`，此时它就不会一层一层的去往父类找了，因为在 `A类` 的虚方法表中就能直接找到 `方法C`，但是它有一个前提条件：`方法C` 必须是一个 `虚方法` 才行。

如果 `方法C` 不是一个虚方法，那么程序还是会跟以前一样，一层一层往上，先找 `A类`，再找 `B类`，再找 `C类`。

所以我们要知道一点，子类是可以继承父类里面的方法的，但是不是所有的方法都能被继承下来，**只有父类中的虚方法才能被子类继承**。

![image-20240415204119109](./assets/image-20240415204119109.png)

有了 `虚方法表` 的概念之后，我们就可以来画内存图了。

----

### 2）内存图

看下下面这段代码，上面是两个 `JavaBean类`，父类中有一个用 `public` 修饰的 `fuShow1()`，还有一个用 `private` 修饰的 `fuShow2`。

第二个类是 `Zi`，继承了 `Fu`，在 `Zi类` 中，它有一个 `public` 修饰的 `ziShow1()`。

下面是测试类，在测试类中执行一系列代码。其中，由于 `fuShow2()` 是由 `private` 修饰的，因此我直接调用，它是会报错的，在这里我们用红色来标记，表示报错的意思。

在右边我们就要开始来画一画它的内存图。

![image-20240415204648950](./assets/image-20240415204648950.png)

首先还是测试类 `main方法` 要运行，所以会把测试类 `main方法` 的字节码文件加载到方法区，然后虚拟机会自动去调用 `main方法`，`main方法` 加载进栈。

![image-20240415204911858](./assets/image-20240415204911858.png)

开始执行 `main` 方法里面的第一行代码。在第一行代码当中，它用到 `Zi`，此时，它就会去加载 `Zi` 的字节码文件，在 `Zi` 的字节码文件中，它会有 `Zi` 的 `所有成员变量` 和 `所有的成员方法` 。但是在这个代码中我们没有写成员变量，所以`成员变量`就可以忽略，在这里我们只需要关注`成员方法`就可以了。

在加载 `Zi` 的时候，它发现它继承了 `Fu`，所以它还会把 `Fu.class` 加载到内存当中。而 `Fu` 还有个父类 `Object`，因此 `Object` 字节码文件也会被加载到方法区。

![image-20240415205646370](./assets/image-20240415205646370.png)

在它们的下面还会有自己的`虚方法表`，在 `Object类` 中它有很多很多的方法，但是不是所有的方法都是 `虚方法` ，只有满足 `非 private 修饰、非 static 修饰的、非 final 修饰的` ，在 `Object类` 中，它一共会有 `5`个 `虚方法`，所以 `Object` 被 `Fu.class` 继承下来的是 `虚方法表中的5个虚方法`。

![image-20240415210154166](./assets/image-20240415210154166.png)

与此同时，在这个 `Fu类` 中，它也有两个方法，由于 `fuShow2()` 它是被 `private` 修饰的，所以不能被叫做 `虚方法`。

但是它会把上面的 `fuShow1()` 添加到自己的 `虚方法表` 中。此时在 `Fu.class` 的虚方法表中，它一共就有 `6个` 虚方法。

然后它再把自己的 `虚方法表` 交给 `Zi.class`。

![image-20240415210555782](./assets/image-20240415210555782.png)

`Zi.class` 也会把这个类的 `虚方法` 添加到 `虚方法表` 中。又由于这里的 `ziShow`() 是满足 `虚方法` 的条件的，因此，它会把 `ziShow()` 也添加进去。

这个时候就要注意了，在 `Zi.class` 的虚方法表中，它一共有 `7个` 方法。其中有 `5个方法`，是从它爷爷 `Object.class` 中继承下来的，还有一个它是从父类 `Fu.class` 中继承下来的，还有最后一个 `ziShow()` 是自己类中的虚方法，一共会有这样的关系。

![image-20240415210902160](./assets/image-20240415210902160.png)

到目前为止，整个`Zi.class`字节码文件就算是加载完毕了。

然后再来看 `=`(等号) 的左边：`Zi z` ，相当于就是在栈中定义了一个变量，变量的名字叫做 `z`，类型叫做 `Zi`，其实也就是在栈中的 `main方法` 中开辟了一个这样的小空间，就表示这个变量里面以后只能存储 `Zi` 这个对象的地址值。

再来看 `=`(等号) 的右边，等号的右边它是有 `new` 关键字的，看到了 `new`，就一定是在堆中开辟了一个小空间。

在这个小空间里面，左边这部分用来存储从父类中继承下来的 `成员变量` 的信息。右边部分使用来记录自己类中 `成员变量` 的信息，但是现在在代码中没有写`成员变量`，因此这个空间它就会空着。

![image-20240415213918912](./assets/image-20240415213918912.png)

整个对象的地址值假设是 `001`。最后再把 `001` 赋值给左边的 `变量z`，`z` 通过 `001` 就可以找到堆中的对象。

现在 `main方法` 中的第一行代码才算执行完毕。

![image-20240415214539706](./assets/image-20240415214539706.png)

接下来执行第二行代码 `sout(z)`，相当于打印 `变量z` 中记录的内容，你记录什么，就打印什么，由于它现在记录的是堆中的地址值 `001`，所以在控制台中打印的就是 `001`。

再往下，第三行 `z.ziShow()`，相当于就是来调用 `ziShow()` 这个方法。它在调用的时候首先会判断一下你当前的这个方法它是不是 `虚方法`，如果是 `虚方法`，它就会从 `虚方法表` 中直接调用。

现在发现了，`ziShow()` 是虚方法，所以就会从 `Zi.classs的虚方法表中` 直接调用。

一旦调用之后，它就会加载到栈中，打印 `public --- ZiShow`

![image-20240415215516208](./assets/image-20240415215516208.png)

再往下，执行 `z.fushow1`，这个方法也是虚方法，因此它会从 `Zi.class` 的 `虚方法表` 中直接把 `z.ziShow()` 方法加载到栈中。

然后执行 `ziShow()` 中的方法，在控制台中打印 `public --- fuShow`。

![image-20240415215837016](./assets/image-20240415215837016.png)

最后一个 `z.fuShow2()`，在调用的时候，虚拟机还是回来判断 `fuShow2()` 是`虚方法`吗，明显不是。

既然不是虚方法，明显就不会在 `虚方法表` 中找，它会在自己的类中找有没有 `fuShow2()`，如果没有，到父类中找。

当它找到 `fu.class` 的时候，它发现这个方法是一个私有的，是不能直接调用的，所以在这里它就会报错。

![image-20240416082621294](./assets/image-20240416082621294.png)

----

## 七、总结

因此到目前为止，关于子类中到底能继承父类中的哪些内容，就已经全部学习完毕了。

其中，构造方法不管是什么样的修饰符，子类都不能继承。

成员变量：不管是什么样的修饰符，子类都可以继承。

成员方法：当前的成员方法能被添加到 `虚方法表` 中，那么这个方法就能被子类继承下来。但是如果你不能添加到 `虚方法表` 中，那么它就不能被子类继承。

上面是通过内存图的方式说明白的，接下来我们要通过 Java 提供的 内存分析工具去验证一下我们刚刚的结论。

----

## 八、通过 `内存分析工具` 验证结论

### 1）代码分析

首先，根据下面代码注解中的序号逐一阅读代码

```java
package com.itheima.a03oopextendsdemo3;

import java.io.IOException;
import java.util.Scanner;

public class Test {
    public static void main(String[] args) throws IOException {
        // 7.在测试类中创建了一个 `Zi` 的对象
        
        // 8.这句话大家自己在打的时候会报错，因为它用到了Java中的第三方工具，这个代码大家就不需要自己练了，你能看懂我们做的是什么就行
        // 如果想要执行这段代码，如要在项目中引入 `jol-core-0.16` 的jar包
        // 这句话的意思是：把对象的地址值z以16进制的形式打在控制台上
        System.out.println(Long.toHexString(VM.current().addressOf(z)));

        // 9. 在这里加 Scanner 的原因是：因为内存分析工具需要程序不停止
        // 如果在这里没有加 Scanner，那么程序刷的一下，直接就会将代码运行完，运行完，程序就会停止了。
        Scanner sc = new Scanner(System.in);
        // 加了键盘录入后，程序会一直停在 18 行
        sc.next();
    }
}


class Fu {
    // 1.`a` 用 `private`(私有) 修饰了，它的值是 `0x111`
    // 0x 开头是十六进制，写成十六进制是在内存结构中，我们看上去会更加方便
    private int a = 0x111;
    // 2.`b` 是非私有的，值是 `0x222`
    int b = 0x222;

    // 3.里面有两个方法
    // 3.1 一个是 `public` 修饰的 `fuShow1()`
    public void fuShow1() {
        System.out.println("public --- FuShow");
    }

    // 3.2 还有一个 `private` 私有修饰的 `fuShow2()`
    private void fuShow2() {
        System.out.println("private --- FuShow");
    }
}

// 4.在 `Zi`类 中它继承了 `Fu`
class Zi extends Fu {
    // 5.里面有个成员变量 `c`，值为 `0x333`
    int c = 0x333;

    // 6.`Zi`类中有 `public` 修饰的 `ziShow()`方法
    public void ziShow() {
        System.out.println("public --- ZiShow");
    }
}
```

右键运行来看下效果，在控制台中我们看到的就是 `Zi` 这个对象的地址值。这个是 对象 在内存中的 真实地址。

![image-20240416084745314](./assets/image-20240416084745314.png)

----

### 2）内存分析工具的使用

接下来我们需要点击控制台下面的 `Terminal`，这个工具相当于就是IDEA集成的CMD工具

![image-20240416084949233](./assets/image-20240416084949233.png)

在控制台中输入 `jps`，这个就可以把在内存当中运行的这些 `类的 ID` 打印出来。

例如我现在运行的是 `Test类`，`Test类` 的 `ID` 就是 `18036`。

![image-20240416085139060](./assets/image-20240416085139060.png)

重新再来打开一个 Terminal

 ![image-20240416085228317](./assets/image-20240416085228317.png)

输入内存分析工具： `jhsdb hsdb`，此时这个分析工具就已经弹出来了。

![image-20240416085410091](./assets/image-20240416085410091.png)

这个工具是 JDK 自带的。

我们可以点击左上角的 `File`，第一个选项 `Attach to HotSpot process...`（`Attach`：连接；`HotSpot`：虚拟机的名字）

![image-20240416085454367](./assets/image-20240416085454367.png)

点击完成后，我们可以将 `进程的ID` 粘贴过去。

`进程的ID` 通过 `jps` 就能看到了，我这里的 `Test` 的进程ID是 `18036`，因此在这我们就输入 `18036` 即可。

输入完毕后回车即可。

![image-20240416085954225](./assets/image-20240416085954225.png)

然后我们可以打开一个 `内存分析工具`：Tools ——> Memory Viewer（这个就是一个内存分析工具）

![image-20240416090249455](./assets/image-20240416090249455.png)

在 `Address` 这里，可以把刚刚看到的地址值输入过来，我这里是 `713d4fbe8`，这个数字前面一定要记得加上 `0x`，因为它是十六进制的

![image-20240416090440764](./assets/image-20240416090440764.png)

然后回车即可。

现在看到右边的这一堆，这一堆其实就是 `z` 这个对象里面的所有信息

![image-20240416090627533](./assets/image-20240416090627533.png)

----

### 3）验证成员变量是否可以被继承

那么这些信息到底是什么呢？我们先来简单的说一下，后面我们在学习虚拟机的时候，会跟大家补充说明。

先来看第一行，是16个字节，它表示对象的对象头，它里面会有我们后面所学习到的 `锁` 信息、`哈希值` 的信息......

在下面的第二行，它又是 `16个字节`，在读的时候，右边是低位，左边是高位，所以我们在读的时候，需要从右往左读。

![image-20240416091005506](./assets/image-20240416091005506.png)

那么在第二行的前八个字节，它就表示 `当前对象的类型`，这里我们看到了 `01000c08`，这个就表示 `Zi` 的类型。

![image-20240416091535033](./assets/image-20240416091535033.png)

再往前看 `111`、`222`、`333`，这个就是对象里面记录的成员变量的信息

![image-20240416091518146](./assets/image-20240416091518146.png)

<img src="./assets/image-20240416091931027.png" alt="image-20240416091931027" style="zoom:67%;" />

我们打开之前画的内存图，我们曾经说过，我们创建对象的时候，对象的空间里面会有自己子类成员变量里面的信息（右边），还有从父类中继承下来的父类里面的成员信息（左边）。

![image-20240416092752217](./assets/image-20240416092752217.png)

这些值在内存结构中我们就能看到了。

![image-20240416093323833](./assets/image-20240416093323833.png)

在这里，我们通过内存分析工具就知道了，父类中成员变量的信息，它是会被子类继承下来的。

并且父类中的 `a` 的修饰符是 `private` 私有的，但是也被继承下来了。

-----

4）验证

我们可以再来打开一个工具 `Inspector（检查员）`，通过这个工具我们就能看到字节码文件中 `类的信息`

![image-20240416093534040](./assets/image-20240416093534040.png)

我们需要在下面的输入框中输入 `Zi`，那么 `Zi` 是谁呢？

在刚刚的 `MemoryViewer` 工具中，在第二行的前八个字节，它就表示 `当前对象的类型`，这里我们看到了 `01000c08`，这个就表示 `Zi` 的类型。

在输入的时候你是不需要手动输入的，它是支持粘贴复制的，并且还可以将它手动拖过去。

![image-20240416094230743](./assets/image-20240416094230743.png)

然后将前面的 `00000111` 成员变量信息删掉。

只不过IDEA做了一个内存地址的压缩，前序还需要补一个 `8`，这才是它完整的地址。

你会发现，下面的这一些就是关于 `Zi类` 的字节码文件相关信息，当然这个字节码文件的信息并不是Java形式的，而是 `C++` 形式的，我们挑几个关键的来阅读一下。

在这个里面看一个东西：`super.Klass`（`super`：父类），双击将其展开





















